# Transport Layer

## [传输层](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=395)

-   传输层与网络层一起构成了网络协议层次的核心。
    
-   网络层使用数据报或虚电路技术为端 到端通信提供了数据包交付服务。传输层架构在网络层提供的服务之上，把数据传递服务从 两台计算机之间扩展到了两台计算机上的进程之间，并且服务所需的可靠性程度独立于当前 使用的物理网络。
    
-   传输层为应用层使用网络提供了抽象的模式。如果没有传输层 ， 分层协议 的整个概念将毫无意义。
    
-   ==传输层的最终目标是向它的用户提供高效的、可靠的和成本有效的数据传输服务，它 的用户通常是应用层的进程。==
    
-   传输层需要充分利用网络层提供给它的 服务。在传输层内，完成这项工作的硬件和/或软件称为传输实体（transport entity)

-   **连接的传输服务在许多方面与面向连接的网络服务类似，两者的连接都要经历 3 个阶段: 连接建立、数据传输和连接释放。**

 [传输层服务的细化-有链接/无连接](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=397)

-   与此相反，面向连接的传输服务是可靠的。当然，实际网络并非没有错误，但是，这 恰好是传输层的目标一一在不可靠的网络之上提供可靠的服务。
    
-   另一方面，传输层也可以提供不可靠(数据报)服务。然而，相对来说关于这种服务 除了“它是数据报”外并没有太多内容可说，所以本章我们将注意力主要集中在面向连接 的传输服务上。
    
-   不过，有一些应用建立在无连接传输服务上，比如客户机-服务器计算和流 式多媒体应用，
    
-   传输服务类似于网络服务，但是两者之间有一些重要的区别。最主要的区别在于网络 服务毫不掩盖地按照实际网络提供的服务来建立模型。实际网络可能会丢失数据包，所以 网络服务一般来说是不可靠的。

[传输层在网络层次传输中的位置和意义](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=398)

-   因此，段(传输层之间交换的单元)被包裹在数据包(网络层之间交换的单元)中， 而数据包则被包含在帧(数据链路层之间交换的单元)中。当一帧到达时，数据链路层对 帧头进行处理，如果帧目标地址与本地传递地址匹配，则把帧的有效载荷宇段中的内容传 递给网络实体。网络实体对数据包头进行类似处理，然后把数据包的有效载荷宇段内容向 上传递给传输实体。这种嵌套关系如图 6-3 所示。

### [连接建立](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=411)

-   为了解决这个特殊问题，( Tomlinson, 1975)引入了三次握手( three-way handshake)。 这是一个建立连接采用的协议，它要求一方检查连接请求是否的确是当前的。图 6-11 Ca) 显示了主机 l 发起连接请求时的正常建立过程。主机 1 选择一个序号 x，并且发送一个包 CONNECTION REQUEST 段给主机 2。主机 2 回应一个 ACK 段作为对 x 的确认， 并且宣告它自己的初始序号 y。最后，主机 1 在它发送的第一个数据段中，对主机 2 选择 的初始序号进行确认。

[TCP三次握手简介](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=412)

-   TCP 使用三次握手机制来建立连接。在连接期间，时间戳被用来辅助扩展 32 位序号， 以便它在最大数据包生存期间不会回绕，甚至对于每秒千兆位的连接也一样。当 TCP 被用 在越来越快的链路上时，这种机制是对 TCP 的必要修复。该机制由 RFC1323 描述，称为 防止序号回绕 CPAws·, Protection Against Wrapped Sequence numbers)

### [连接释放](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=413)

-   释放一个连接要比建立一个连接容易得多。然而，这其中也存在着许多让人意想不到 的陷阱。正如我们前面提到过的，终止连接的方式有两种:非对称释放和对称释放。非对 称释放连接是电话系统的工作方式:当一方挂机后，连接就被中断了。对称释放连接是把 连接看成两个独立的单向连接，要求单独释放每 个单向连接.

### [差错控制和流量控制](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=416)

-   差错控制和流量控制
    
-   4)滑动窗口(sliding window)协议结合了这些功能，还能被用于支持数据的双向 传送。
    
-   2)帧中携带的序号用于标识本帧，发送方在收到接收方成功接收后返回的确认之前， 必须重发帧。这种机制称为自动重复请求 CARQ, Automatic Repeat reQuest)。
    
-   3)任何时候允许发送方发送一定数量的帧，如果接收方没有及时返回确认，则发送 方必须暂停。如果只允许发送一帧，则协议称为停等式 Cstop-and-wait)协议。较大的窗口 可使得发送管道化，因而提高距离长且速度快的链路性能。

## [6.3 拥塞控制](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=422)

-   如果许多机器上的传输实体以太快的速度发送太多的数据包，就会使得网络不堪重负 而变得拥塞，继而数据包被延迟和丢失，从而导致网络性能严重下降。避免这个问题的拥 塞控制是网络层和传输层的共同责任。
    
-   拥塞发生在路由器上，因此在网络层检测拥塞。然 而，拥塞究竟还是由传输层注入到网络中的流量引起的，因此控制拥塞的唯一途径是传输 层放缓往网络中发送数据包的速度。
    
-   在第 5 章，我们学习了网络层的拥塞控制机制。本节，我们将学习问题的另一半，即 传输层的拥塞控制机制。在描述完拥塞控制的目标后，我们将描述主机如何调节它们往网 络发送数据包的速率。 Internet 的拥塞控制严重依赖于传输层，特殊的算法被嵌入到 TCP 和其他协议中。
    
-   拥塞控 制算法的目标是更加易于避免拥塞，即为使用网络的传输层找到一种好的带宽分配方法。

### [理想的带宽分配-最大最小公平性](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=423)

-   最大-最小公平性
    
-   我们没有涉及如何在多个传输实体之间划分带宽。
    
-   解决带宽分配问题
    
-   这看上去只回答 了一个简单问题一一给全部的发送端以均等的带宽比例，但这里有几点值得考虑。
    
-   也许，首先考虑的是拥塞控制究竟要解决什么问题。
    
-   功率最初将随着提交负载的上升而上升，延迟仍然很小并且基本保持不变:但随着延 迟快速增长功率将达到最大，然后开始下降。达到最大功率的负载表示了传输实体放置在 网络上的有效负载。

 [最大最小公平理解](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=424)

-   第二个要考虑的是公平对网络中的流意味着什么。
    
-   不太富裕的那些流的情况变得更糟。 无法得到进一步增长，那么就不给这个流更多带宽。也就是说，增加一个流的带宽只会让 大，最小公平分配指的是，如果分配给一个流的带宽在不减少分配给另一个流带宽的前提下 公平的形式是最大·最小公平 Cm缸，min fairness)，通常表示理想的网络使用情况。

[收敛](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=425)
-   最后一个标准是拥塞控制算法能否快速收敛到公平而有效的带宽分配上。
    
-   由于需求的变化，网络的理想操作点也随着时间推移而改变着。一个良好的拥塞控制 算法，应迅速收敛到理想的操作点，并跟踪这随时变化的操作点。

### [调整发送速率](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=426)

-   传输协议调节发送速率的方式依赖于网络返回的反馈意见形式。不同的网络层可能会 返回不同类型的反馈。反馈可能是显式的，也可能是隐式的:而且反馈信息可能精确，也 可能不精确。
    
-  显式拥塞协议 （XCP, eXplicit Congestion Protocol) 就是以这种方式工作的 CKatabi 等， 2002)。另一个显式的但不精确的设计例子是使用 TCP 的显式拥塞通知 CECN, Explicit Congestion Notification) 

[加法递增 乘法递减 AIMD原则](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=427)

-   减少速率的方式由控制法则( control law)决定。这些法则对性能有重大的影响。. 情况下，发送端应该增加发送速率:当给出拥塞信号时，发送端应降低发送速率。增加或 在没有拥塞信号的
    
-   同样，考虑当两个用户随着时间的推移按乘法(加倍)法则递增带宽直到他们收到一 个拥塞信号的情况。
    
-   用户的操作点将沿着乘法线振荡。这种行为也如图 6-24所示。乘法线的 斜率和加法线的斜率不同 (它指向源点，而加法线呈 45。角)。不过它也没有更好的选择。 在这两种情况下，用户都难以收敛到同时兼顾公平与效率的最佳发送速率。
    
-   他们得出的结论是加法递增乘法 递减(AIMD, Additive Increase Multiplicative Decrease)法则是达到有效和公平操作点的适 当流量规则。为了表明这种情况，他们构建了一 个简单实例的图形表示，在这里有两个流竞争单 条链路的带宽。
    
-   他们必须减少各自分配的带宽。然而，加法递减只会导致他们沿着递增线振 荡。这种情况如图 6-24所示。这种行为将保持操作点接近效率线，但它并不一定是公平的。 加法递减为什么会是不公平的

[这种行为就是 AIMD 控制法则，如图 6-25 所示。由此可以看出，这种行为的轨 迹路径能收敛到兼顾公平与效率的最佳点。这种收敛不管从什么出发点开始都能发生，因 而使得 AIMD 得到了广泛使用。同样的论点，唯一的其他组合，即乘法递增和加法递减， 将会偏离最佳点。](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=428)

## [6.4 UDP](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=430)

-   Internet 的传输层有两个主要协议，无连接和面向连接各一个，两个协议互为补充。无 连接协议是 UDP，它除了给应用程序提供发送数据包功能并允许它们在所需的层次之上架 构自己的协议之外，儿乎没有做什么特别的事情。面向连接的协议是 TCP，该协议儿乎做 了所有的事情。
    
-   Internet协议集支持一个无连接的传输协议，该协议称为用户数据报协议( UDP, User Datagram Protocol)。 UDP 为应用程序提供了一种无需建立连接就可发送封装的 IP 数据报 的方法。

[远程过程调用](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=432)

-   这项技术称为远程过程调用
    
-   RPC 背后的思想是尽可能地使一个远程过程调用看起来像本地过程调用一样。在最简 单的形式中，为了调用一个远程过程，客户程序必须绑定(链接)到一个小的库过程，这 个库过程称为客户存根( client stub)，它代表了客户地址空间中的服务器过程。类似地，服 务器需要绑定到一个称为服务器存根( servers阳b)的过程。正是这些过程，隐藏了从客户 机不在本地调用服务器的事实

[实时传输协议 RTP]x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=434)

-   于是实时传输协议 CRTP, Real-time Transport Protocol) 诞生了。 RTP 由 RFC 3550 述，目前已经广泛应用于多媒体应用程序。我们将描述实时传输的两个方面。第一个是 RTP 协议，它以数据包形式传输音频和视频数据。
    
-   RTP 通常运行在用户空间，位于 UDP 之上。

[RTP-一实时传输协议](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=435)

-   RTP 的基本功能是将几个实时数据流复用到一个 UDP 数据包流中。这个 UDP 流可以 被发送给一台目标主机(单播传输模式)，也可以被发送给多台目标主机(组播传输模式)。 因为 RTP 仅仅使用了常规的 UDP，所以路由器不会对它的数据包有任何特殊的对待，除非 开通了某些通常的 IP 服务质量特性。特别地，这里没有任何保障传递可靠性的措施，数据 包可能会丢失、延迟或者损坏等。
    
-   最终多媒体应用从 RTP 库函数接收到多媒体数据， 它负责播放所收到的媒体。这种情况的协议战如图 6-30 Ca)所示。数据包的嵌套封装情 况如图 6-30 Cb)所示
    
-   另一方面，它又是一个与具体应用无关 的通用协议，它仅仅提供了一些传输设施，所以它看起来也像一个传输协议。可能最恰当 的描述是 z 它是一个在应用层上实现的传输协议，这就是为什么我们在本章涉及它的原因。

## [6.5 TCP](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=438)

-   传输控制协议( TCP, Transmission Control Protocol)是为了在不可靠的互联网络上提 #计算机网络考点 

UDP主要是报文序列 TCP是字节流

-   不可靠的互联网： IP层提供的是无连接的不可靠的传输方式 但VC是有连接可靠的 但不是说层层可靠才可靠 有一层可靠就会可靠
    
-   UDP 是一个简单的协议，它有一些非常重要的用途，比如客户·服务器交互和多媒体应 用，但是对于大多数 Internet 应用来说，它们需要可靠的、按序递交的传输特性。 UDP 能提供这样的功能，所以 Internet还需要另一个协议。这就是 TCP，它是 Internet上的主力 军。

[TCP主要内容](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=439)

-   供可靠的端到端字节流而专门设计的一个传输协议。
    
    
-   互联网络与单个网络有很大的不同， 因为互联网络的不同部分可能有截然不同的拓扑结构、带宽、延迟、数据包大小和其他参 数。 TCP 的设计目标是能够动态地适应互联网络的这些特性，而且具备面对各种故障时的 健壮性。
    
-   每台支持 TCP 的机器都有一个 TCP 传输实体。 TCP 实体可以是一个库过程、一个用 户进程，或者内核的一部分。在所有这些情形下，它管理 TCP 流，以及与 IP 层之间的接 口。
    
-   四层并不保证数据报一定被正确地递交到接收方，也不指示数据报的发送速度有多快。
    
-   正是 TCP 负责既要足够快地发送数据报，以便使用网络容量，但又不能引起网络拥塞:而 且， TCP 超时后，要重传没有递交的数据报。
    
-   TCP 必须提供可靠性的良好性能，这正是大多数用户所期望的而 IP 又没有提供的功能。

-   TCP 服务由发送端和接收端创建一种称为套接字(socket)的端点来获得，正如我们 6.1.3 节中所讨论的那样。每个套接字有一个套接字编号(地址)，该编号由主机的 IP 址以及一个本地主机的 16 位数值组成的。这个 16 位数值称为端口( port)，端口是 TCP TSAP 名字。为了获得 TCP 服务，必须显式地在一台机器的套接字和另一台机器的套接字 之间建立一个连接，有关套接字的调用如图 6-5 中所列。 一个套接字有可能同时被用于多个连接。换句话说，两个或者多个连接可能终止于同 一个套接字。每个连接可以用两端的套接字标识符来标识，即( socket1, socket2)。 TCP 使用虚电路号或者其他的标识符。

[一个 TCP 连接就是一个字节流，而不是消息流。端到端之间不保留消息的边界。](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=440)

-   TCP的一个连接 套节字编程
    
-   例如， 如果发送进程将 512宇节的数据块写到一个 TCP流中，那么这些数据有可能按 512 字节块、 1024字节块、 2048 字节块或者其他的方式被递交给接收进程(见图 6-35)。 接收端不管多么努力尝试，都无法获知这些数据被写入字节流时的单元大小。
    
-   所有的 TCP 连接都是全双工的，并且是点到点的。所谓全双工，意味着同时可在两个 方向上传输数据:而点到点则意味着每个连接恰好有两个端点。 TCP 不支持组播或者广播 传输模式。

[Page 429](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=442)

-   有序号是因为要拆分数据包传输然后组装 UDP不需要因为其传送的都是一个个的数据包

### [TCP段的头](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=443)

-   序号( Sequence number)和确认号( Aclmowledgement number)字段执行它们的常规 功能。请注意，后者指定的是下一个期待的字节，而不是已经正确接收到的最后一个字节 它是累计确认( cumulative aclmowledgement)，因为它用·一个数字概括了接收到的所有数 据，它不会超过丢失的数据。这两个字段都是 32 位长， 因为一个 TCP 流中的每一个数据 字节都己经被编号了。
    
-   ACK 被设置为 1 表示确认号字段是有效的。几乎所有的数据包都会用到这个标志位。 如果 ACK 为 0，则该段不包含确认信息，所以，确认号字段可以被忽略。

### [TCP连接建立](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=445)

-   TCP 连接建立
    
-   TCP 使用了三次握手法来建立连在，这个方法我们在 6.2.2 节中讨论过。为了建立一个 连接，某一端，比如说服务器，必须先依次执行口STEN 和 ACCEPT 原语，然后被动地等 待入境连接请求:并且可以指定只接受一个特定的请求源，也可以不指定。
    
-   所有的连接都是三个过程
    

### [TCP连接释放](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=446)

-   虽然 TCP 连接是全双工的，但是，为了理解 TCP 连接是如何释放的，最好将 TCP 接看成一对单工连接。
    
-   每个单工连接的释放彼此独立。为了释放一个连接，任何一方都可 以发送一个设置了 FIN 标志位的 TCP 段，这表示它己经没有数据要发送了。
    
-   FIN 段被另 一方确认后，这个方向上的连接就被关闭，不再发送任何数据。
    
-   然而，另一个方向上或许 还在继续着无限的数据流。当两个方向都关闭后，连接才算被彻底释放。通常情况下，释 放一个连接需要 TCP段:每个方向上一个 FIN和一个 ACK。然而，第一个 ACK和第 二个 FIN 有可能被组合在同一个段中，从而将所需段总数降低到 3 个。
    
-   正如在电话通话过程中，双方说完再见之后同时挂断电话一样，一个 TCP 连接的两端 也可能会同时发送 FIN 段。这两个段按常规的方法被单独确认，然后关闭连接。实际上， 两台主机可以先后释放连接，或者同时释放连接，这两者之间并没有本质的区别。
    
-   这种攻击称为 SYN 洪( SYN flood)

### [TCP连接管理模型](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=447)

-   TCP 连接管理模型 从不同的角度出发看如何连接与断开连接 客户端和服务器端
    
-   每个连接都从 CLOSED 状态开始。当它执行了一个被动打开操作( LISTEN)，或者一 个主动打开操作( CONNECT)后，它就离开 CLOSED 状态。如果另一端执行了相反的操 作，则连接就建立起来，当前状态变成 ESTABLISHED。连接的释放过程可以由任何一方 发起。当释放完成时，状态又回到 CLOSEDo
    
-   为了更好地理解这个图，你可以首先沿着客户的路径(粗实线)，然后沿着服务器的路 径(粗虚线)来查看。当客户机器上的一个应用程序发出 CONNECT 请求，本地的 TCP 实体创建一条连接记录，并将它标记为 SYN SENT 状态，然后发送一个 SYN 段。请注意， 在一台机器上可能同时有许多个连接处于打开(或者正在被打开)状态，它们可能代表了 多个应用程序，所以，状态是针对每个连接的，并且每个连接的状态被记录在相应的连接 记录中。当 SYN+ACK 到达的时候， TCP 发出三次握手过程的最后一个 ACK 段，然后切 换到 ESTABLISHED 状态。现在可以发送和接收数据了。
    
-   当一个应用结束时，它执行 CLOSE 原语，从而使本地的 TCP 实体发送一个 FIN 段， 并等待对应的 ACK (虚线框标记了“主动关闭”)。当 ACK 到达时，状态迁移到 FIN W AIT ，而且连接的一个方向被关闭。当另一方也关闭时，会到达一个 FIN段，然后它被确认。 现在，双方都已经关闭了连接，但是， TCP 要等待一段长度为最大数据包生存期两倍的时

[TCP 连接管理有限自动机](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=448)
    
-   才能确保该连接上的所有数据包都己寿终正寝，以防万一发生确认被丢失的情形。当 计时器超时后， TCP 删除该连接记录。
    
-   现在让我们从服务器的角度来看连接管理的情况。服务器执行 LISTEN，并等待入境 连接请求。当收到一个 SYN 时，服务器就确认该段并且进入到 SYNRCVD 状态。当服务 器本身的 SYN 被确认后，就标志着三次握手过程的结束，服务器进入到 ESTABLISHED 状态。从现在开始双方可以传输数据了。
    
-   当客户完成了自己的数据传输，它就执行 CLOSE，从而导致 TCP 实体发送一个 FIN 到服务器(虚线框标记了“被动关闭”)。然后，服务器接到信号:当它也执行了 CLOSE 时， TCP 实体给客户发送一个 FIN 段。当该段的来自客户的确认返回后，服务器释放该连 接，并且删除相应的连接记录。

 [Page 436](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=449)

-   当窗口变为 0 时，发送端不能如通常那样发送段了，但这里有两种意外情形。第 紧急数据仍可以发送，比如，允许用户杀掉远程机器上运行的某一个进程。第二， 发送端 可以发送 字节的段，以便强制接收端重新宣告下一个期望的字节和窗口大小。这种 数据包称为窗口探测( windowprobe)。 TCP 标准明确地提供了这个选项，来防止窗口更新 数据包丢失后发生死锁。

[Page 437](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=450)

-   降低 TCP 性能的另一个问题是低能窗口综合症( silly window syndrome) (Clark, 1982)。 当数据以大块形式被传递给发送端 TCP 实体，但是接收端的交互式应用每次仅读取一个字 节数据的时候，迭个问题就会发生。

 [Page 438](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=451)

-   低能窗口综合症
    
-   当 TCP 实体发出一个段时，它同时启动一 个重传计时器。如果在该计时器超时前该段被确认，则计时器被停止。另一方面，如果在 确认到来之前计时器超时，则段被重传(并且该计时器被重新启动)。于是问题就来了:超 时间隔应该设为多长?
    

[Page 439](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=452)

-   来回时间 即：RTT
    
-   而且，确认到达时间分布的均值和方差也会随着拥塞的发生或者解 决而在几秒钟时间内迅速地改变。

## [TCP拥塞控制](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=453)

-   TCP 拥塞控制
    
-   我们把 TCP 的关键功能之一保留到最后，即拥塞控制。当提供给任何网络的负载超过 它的处理能力时，拥塞便会产生。

[Page 441](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=454)

-   我们在 6.3 节中介绍了拥塞控制的一般情况。关键在于如果一个传输协议使用 AIMD (加法递增乘法递减)控制法则来响应从网络传来的二进制拥塞信号，那么该传输协议应该 收敛到一个公平且有效的带宽分配。 TCP 的拥塞控制就是在这个方法的基础上实现的，它 使用了一个窗口，并且把丢包当作二进制信号。要做到这一点， TCP 维持一个拥塞窗口 (congestion window)，窗口大小是任何时候发送端可以往网络发送的字节数。相应的速率 则是窗口大小除以连接的往返时间。 TCP 根据 AIMD 规则来调整该窗口的大小。
    
-   回想一下，除了维护一个拥塞窗口外，还有一个流量控制窗口， 和上一节的WIN窗口中所提到的一致
    
-   在 Internet 上， TCP 在控制拥塞以及可靠传输 中发挥着主要的作用。这就是为什么 TCP 是如此特殊的一个协议。

[Page 442](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=455)

-   关键的观察是这样的 z 确认返回到发送端的速率恰好是数据包通过路径上最慢链路时 的速率。这正是发送端应该使用的精确发送速率。如果发送端以这个速率往网络注入新的 数据包，这些数据包就能以慢速链路允许的速率一样快的速度被转发出去，但它们不会再 排队和堵塞沿途上的任何一个路由器。这个时序就是确认时钟( ack clock)

## [Page 443](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=456)

-   这种算法称为慢速启动( slow start)，但它根本不慢一一它呈指数增长一一相比以前的 算法，即一次发送整个流量控制窗口大小的数据，它应该算启动得不快。慢速启动算法如 6-44 所示。在第一次往返时间，发送端把一个数据包注入网络(并且接收端接收到一个 数据包)。在接下来的一个往返时间，发送端发出两个数据包，然后在第三个往返时间发送 四个。

[Page 444](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=457)

-   由于慢速启动导致拥塞窗口按指数增长，最终(很快而不是很晚〉它将太多的数据包 以太快的速度发到网络。当发生这种情况时，网络中将很快建立起队列。当队列满时，一 个或多个包会被丢弃
    
-   为了保持对慢速启动的控制，发送端为每个连接维持一个称为慢启动阑值( slow start threshold)的阔值。最初，这个值被设置得任意高，可以达到流量控制窗口的大小，因此 它不会限制连接速度。
    
-   每当检测到丢包，比如超时了，慢启动阔值就被设置为当前拥塞窗口的一半，整个过 程再重新启动。基本想法是当前的窗口太大，因为是它在过去造成了阻塞，所以现在才检 测到超时。
    

[Page 445](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=458)

-   6-46 给出了迄今为止我们己经构建的拥塞算法示意图。此版本的 TCP 称为 TCP Tahoe，它包括了 1988年发布的 4.2BSD TCP Tahoe。这里的最大段长为 1 KB。最初，拥 塞窗口为 64阻:但发生超时后，这样的阙值被设置为 32 阻，并且拥塞窗口被设置为 1 阻， 开始传输。拥塞窗口呈指数增长，直到达到阔值 (32 阻)。每次到达一个新的确认就 增加窗口的大小，而不是连续增加，因而导致窗口的大小表现出离散的阶梯模式。当窗口 大小达到阔值后，窗口大小就按线性增长。每个 RTT 只增加一段。 线性增长
    
-   。重传后，慢启动阔值被设置为当 前拥塞窗口的一半，就像发生了超时一样。重新开始慢启动过程，拥塞窗口被设置成一个 包。有了这个窗口大小，如果在一个往返时间内确认了该重传的数据包以及丢包之前己发 送的所有数据，则发出一个新的数据包。
    
-   40的一半变为20 试探性变化
    

[Page 446](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=459)

-   TCP Reno 的快速恢复和锯齿模式
    
-   因为满启动太快 指数级增加
    
-   快速恢复( Fastrecovery)就是实现这种行为的启发式机制。这是一个临时模式，其目 的是保持拥塞窗口上运行确认时钟，该拥塞窗口有一个新阔值或者快速重传时把拥塞窗口 值减半。要做到这一点，对重复确认要计数(包括触发快速重传机制的那三个重复确认)， 直到网络内的数据包数量下降到新阑值。这大概需要半个往返时间。从此时往后，每接收 到一个重复确认就发送一个新的数据包。快速重传之后的一个往返时间后，丢失的包将被 确认。在这个时间点，重复确认流将停止，快速恢复模式就此退出。拥塞窗口将被设置到 新的慢启动阔值，并开始按线性增长。
    
-   这种启发式的结果是 TCP避免了’攫速启动，只有第一次启动或者发生超时时才进入真 正的慢速启动
    

 [Page 447](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=460)

-   TCP Reno及它用来调整拥塞窗口的机制形成了 TCP 的拥塞控制，至今己有超过二十 年的历史。

##  [小结](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=479)

-   传输层是理解分层协议的关键。它提供了各种服务，其中最重要的服务是一个从发送 端至接收端的端到端的、可靠的、面向连接的字节流。
    
-   通过一组服务原语可以访问此服务 原语可用来建立、使用和释放连接。
    
-   协议必须能在不可甜的网络上完成连接管理工作。由于延迟的重复数据包可能会重新出现 在不恰当的时刻，因而连接的建立过程非常复杂。为了处理这些问题 ， 需要使用 三 次握手 法来建立连接。释放连接比建立连接要容易得多，但由于存在两军对垒问题，释放连接也 并非轻而易举.
    
-   Internet有两个主要的传输协议: UDP和TCP. UDP是一个无连接的协议，它主要对 数据包进行了包装， 由此引入了多个进程复用和分用一个 IP 地址这一特性。 UDP 可以被用 于客户机.服务器之间的交互〈比如 RPC) , UDP 也可以被用来建立实时协议(比如 RTP).
    
-   主要的 Internet传输协议是 TCP。它提供了一个可靠的、双向的、拥塞可控的字节流

-   构成字节流的所有段都有一个 20 个字节长的头。大量的工作针对 TCP 性能进行了优化， 它们主要是 Nagle、 Clark、 Jacobson、 Kam 和其他的算法。