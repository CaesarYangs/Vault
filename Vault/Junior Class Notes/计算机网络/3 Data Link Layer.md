# 3 Data Link Layer
## 3.1 数据链路层设计问题
[数据链路层](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=164)

 在本章，我们将学习网络模型中的第二层(即数据链路层〉的设计原则。学习内容涉 及两台相邻机器实现可靠有效的完整信息块(称为帧〉通信的一些算法，而不像物理层那 样只关注单个比特传输。这里的相邻指两台机器通过一条通信信道连接起来，通信信道在 概念上就像一条线路(比如同轴电缆、电话线或者无线信道〉。信道像一条线路的本质特性 使得信道上传递的比特顺序与发送顺序完全相同。

刚开始，你可能认为这个问题非常简单，似乎没有什么内容需要学习一一机器 A 把比 特放到线路上，然后机器 B 将这些比特取下来。不幸的是，通信线路偶尔会出错。而且， 它们只有有限的数据传输率，并且在比特的发送时间和接收时间之间存在一个非零延迟。 这些限制对数据传输的效率有非常重要的影响。通信所采用的协议必须考虑所有这些因素。 这些协议正是本章的主题。

-   ==数据链路层使用物理层提供的服务在通信信道上发送和接收比特。==
    
1. 向网络层提供一个定义良好的服务接口。 
2. 处理传输错误。
3. 调节数据流，确保慢速的接收方不会被快速的发送方淹没。
    
-   ==帧的管理构成了数据链路层工作的核心。==
    
-   为了实现这些目标，数据链路层从网络层获得数据包，然后将这些数据包封装成帧 (Frame)以便传输。每个帧包含一个帧头、一个有效载荷(用于存放数据包〉以及一个帧 尾，如图 3-1 所示。

### [3.1.1 提供给网络层的服务](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=165)

-   数据链路层的功能是为网络层提供服务。最主要的服务是将数据从源机器的网络层传 输到目标机器的网络层。
    
-   数据链路层可以设计成向上提供各种不同的服务。实际提供的服务因具体协议的不同 而有所差异。一般情况下，数据链路层通常会提供以下 3 种可能的服务: Cl )无确认的无连接服务。 (2)有确认的无连接服务。 (3)有确认的有连接服务。
    
-   无确认的无连接服务是指源机器向目标机器发送独立的帧，目标机器并不对这些帧进 行确认。以太网就是一个提供此类服务的数据链路层极好实例。采用这种服务，事先不需 要建立逻辑连接，事后也不用释放逻辑连接。
    
-   这类服务合适 两种场合，第一种是错误率很低的场合，此时差错恢复过程可以留给上层来完成:第二种是实时通信，比如语音传输，因为在实时通信中数据迟到比数据受损更糟糕。

-   迈向可靠性的下一步是有确认的无连接服务。当向网络层提供这种服务时，数据链路 层仍然没有使用逻辑连接，但其发送的每一帧都需要单独确认
    
-   比如无线系统。 802.11 CWiFi)就是 此类服务的一个很好例子。
    
-   数据链路层向网络层提供的最复杂服务是面向连接的 服务。采用这种服务，源机器和目标机器在传输任何数据之前要建立一个连接。连接上发 送的每一帧都被编号，数据链路层确保发出的每个帧都会真正被接收方收到。它还保证每 个帧只被接收一次，并且所有的帧都将按正确的顺序被接收。因此，面向连接的服务相当 于为网络层进程提供了一个可靠的比特流。它适用于长距离且不可靠的链路，比如卫星信 道或者长途电话电路。如果采用有确认的无连接服务，可以想象丢失了确认可能导致一个 帧被收发多次，因而将浪费带宽。

### [3.1.2 成帧](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=166)
-   对于数据链路层来说，通常的做法是将比特流拆分成多个离散的帧，为每个帧计算一 个称为校验和的短令牌(本章后面将讨论校验和算法)，并将该校验和放在帧中一起传输。
    
-   检测错误和 纠正错误(有必要的话)的工作正是数据链路层该做的。

-   拆分比特流的实际工作比初看上去的要复杂得多。 一个好的设计方案必须使接收方很 容易发现一个新帧的开始，间时所使用的信道带宽要少。我们将考察下列 4种方法: (1 )字节计数法. (2)字节填充的标志字节法。 (3)比特填充的标志比特法。 (4)物理层编码违禁法。
    
-   种成帧方法利用头部中的一个字段来标识该帧中的字符数。当接收方的数据链路 层看到字符计数值时，它就知道后面跟着多少个字节 ， 因此也就知道了该帧在哪里结束。
    
-   第二种成帧方法考虑到了出错之后的重新同步问题，它让每个帧用 一些特殊的字节作 为开始和结束.这些特殊字节通常都相同 ， 称为标志字节( flag byte)，作为帧的起始和结 束分界符，如图 3-4 (a)中的 FLAG所示。
    
-   因此，如果接收方丢失了同步，它只需搜索两个标志字节就能找到当前帧的结 束和下一帧的开始位置.
    
-   有一种方法可以解决这个问 题，发送方的数据链路层在数据中“偶尔”出现的每个标志字节的前面插入一个特殊的转 义字节( ESC)。因此，只要看它数据中标志字节的前面有没有转义字节，就可以把作为帧 分界符的标志字节与数据中出现的标志字节区分开来。接收方的数据链路层在将数据传递给网络层之前必须删除转义字节。这种技术就称为字节填充( byte stuffing)。

[另外两种填充方案](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=168)
    
-   3-4 中描述的字节填充方案是 PPP 协议( Point-to-PointProtocol) 使用的略微简化形 式，该协议通常用在通信链路上传送数据包。我们将在本章后面讨论 PPP 协议。
    
-   第三种区分比特流边界的方法考虑了字节填充的缺点，即只能使用 8 比特的字节。 帧的划分可以在比特级完成，因而帧可以包含由任意大小单元(而不是只能以 8 比特为 单元)组成的二进制比特数。

### [3.1.3 差错控制](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=169)

-   解决了如何标识每一帧的起始和结束位置之后，我们现在来看下一个问题:如何确 保所有的帧最终都被传递给目标机器的网络层，并且保持正确的顺序
    
-   确保可靠传递的常用方法是向发送方提供一些有关线路另一端状况的反馈信息。通常 情况下，协议要求接收方发回一些特殊的控制帧，在这些控制帧中，对于它所接收到的帧 进行肯定的或者否定的确认。如果发送方收到了关于某一帧的肯定确认，那么它就知道这 帧己经安全地到达了。另一方面，否定的确认意味着传输过程中产生了错误，所以这帧必 须重传。

### [3.1.4 流量控制](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=170)

-   很显然，必须要采取某种措施来阻止这种情况发生。常用的办法有两种。第一种方法 是基于反馈的流量控制(feedback-basedflow control)，接收方给发送方返回信息，允许它 发送更多的数据，或者至少告诉发送方自己的情况怎么样。第二种方法是基于速率的流量 控制 Crate-based flow control)，使用这种方法的协议有一种内置的机制，它能限制发送方 传输数据的速率，而无须利用接收方的反馈信息。

## [3.2 差错检测和纠正](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=171)

-   网络设计者针对错误处理已经研究出两种基本策略。这两种策略都在发送的数据中加 入冗余信息。一种策略是在每一个被发送的数据块中包含足够多的冗余信息，以便接收方 能据此推断出被发送的数据是什么。另一种策略也是包含一些元余信息，但这些信息只能 让接收方推断出是否发生了错误(而推断不出哪个发生了错误〉，然后接收方可以请求发送 方重传。前一种策略使用了纠错码(error-correcting code)，后一种策略使用了检错码 ( error-detecting code )。使用纠错码的技术通常也称为前向纠错( FEC , Forward Error Correction)。

## **[3.3 基本数据链路层协议](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=181)**
-   在涉及数据链路层时，通过接口从网络层传递到数据链路层的数据包是纯粹的数据， 它的每一位都将被递交到目标机器的网络层。
    
-   当数据链路层接收到一个数据包，它就在数据包前后增加一个数据链路层头和尾，由 此把数据包封装到一个帧中(见图 3-1)。因此，一个帧由一个内嵌的数据包、一些控制信息 (在头中)和一个校验和(在尾部)组成。然后，帧被传输到另一台机器上的数据链路层。

[为什么网络层永远得不到任何帧头的信息，理由非常简单，那就是要保持网络层和数 据链路层的完全分离。只要网络层对数据链路协议和帧格式一无所知，那么当数据链路协 议和帧格式发生变化时，网络层软件可以不作任何改变](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=182)

### [3.3.1 一个乌托邦式的单工协议](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=184)

-    作为第一个例子，我们来考虑一个简单得不能再简单的协议，它不需要考虑任何出错 的情况。
    
-   在这个协议中，数据只能单向传输。发送方和接收方的网络层总是处于准备就绪 状态。
    
-   协议由两个单独的过程组成 z 一个发送过程和一个接收过程。发送过程运行在源机器 的数据链路层上:接收过程运行在目标机器的数据链路层上。

-   乌托邦协议是不现实的，因为它不处理任何流量控制或纠错工作。其处理过程接近于 无确认的无连接服务，必须依赖更高层次来解决上述这些问题，即使无确认的无连接的服 务也要做一些差错检测的工作。

### [3.3.2 无错信道上的单工停等协议](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=185)

-   无错信道上的单工停.等式协议 现在我们将处理这样的问题:发送方以高于接收方能处理到达帧的速度发送帧，导致 接收方被淹没。这种情形实际上很容易出现，因此协议是否能够防止它非常重要。
    
-   这个问题的更一般化解决方案是让接收方给发送方提供反馈信息。接收方将数据包传 递给网络层之后给发送方返回一个小的哑帧，实际上这一帧的作用是给发送方一个许可， 允许它发送下一帧。发送方在发出一帧之后，根据协议要求，它必须等待一段时间直到短 哑帧(即确认〉到达。这种延缓就是流量控制协议的 一个简单例子。
    
-   发送方发送一帧，等待对方确认到达后才能继续发送，这样的协议称为停·等式协议 (stop-and-wait)。图 3-13给出了一个单工停·等式协议的例子。


- 就像在协议 l 中那样，发送方首先从网络层获取一个数据包，用它构造一帧，然后发 迭出去。但现在，与协议 1 不同的是，发送方在开始下一轮循环从网络层获取下一个数据包之前必须等待，直到确认帧到来。发送方的数据链路层甚至根本不检查接收到的帧，因 为对它而言只有一种可能性，即入境帧总是来自接收方的确认。

### [3.3.3 有错信道上的单工停-等式协议](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=186)

-    现在让我们来考虑比较常规的情形，即通信信道可能会出错。帧可能会被损坏，也可 能完全被丢失。然而，我们假设，如果一帧在传输过程中被损坏，则接收方硬件在计算校 验和时能检测出来。

-   粗看起来，协议 2 稍作修改就能应付这项工作:增加一个计时器。发送方发出一帧， 接收方只有在正确接收到数据之后才返回一个确认帧。

[为了看清楚哪里可能出错，必须牢记:数据链路层的目标是在两个网络层进程之间提 供无差错的、透明的通信。](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=187)

*[ARQ](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=188)*
    
-   如果在一个协议中，发送方在前移到下一个数据 之前必须等待一个肯定确认，这样的协议称为自动重复请求( ARQ , Automatic Repeat reQuest)或带有重传的肯定确认( PAR, Positive Acknowledgement with Retransmission)。 与协议 2类似，这类协议也只在一个方向上传输数据。

-   协议 3 与其前任协议的不同之处在于，当发送方和接收方的数据链路层处于等待状态 时，两者都用一个变量记录下了有关的值。发送方在 next 企ame to send 中记录了下一个 要发送的帧的序号:接收方则在企ame_expected 中记录了下一个期望接收的序号。每个协 议在进入无限循环之前都有一个简短的初始化阶段。

## [3.4 滑动窗口协议](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=189)

-   还需要再看看其他的讲解 不太明白 # 再复习
    
-   在前面的协议中，数据帧只在一个方向上传输。而在大多数实际环境中，往往需要在 两个方向上同时传输数据。实现全双工数据传输的一种办法是运行前面协议的两个实例， 每个实例使用一条独立的链路进行单工数据传输(在不同的方向上〉。因此，每条链路由一 个“前向”信道(用于数据〉和一个“逆向”信道(用于确认〉组成。两种情况下的逆向 信道带宽几乎完全被浪费了。
    
-   尽管让数据帧和控制帧在同一条链路上交错传输是对前面提到的两条独立物理链路方 案的一种改进，但仍然有更进一步改进的可能。当到达一个数据帧时，接收方并不是立即 发送一个单独的控制帧;而是抑制自己并开始等待，直到网络层传递给它下一个要发送的 数据包。然后，确认信息被附加在往外发送的数据帧上(使用帧头的 ack宇段〉。实际上， 确认信息搭了下一个出境数据帧的便车。==这种暂时延缓确认以便将确认信息搭载在下一个 出境数据帧上的技术就称为捎带确认 Cpiggybacking)。==
    
-   ==与单独发确认帧的方法相比，使用捎带确认的最主要好处是更好地利用了信道的可用带宽。==帧头的 ack 宇段只占用很少几位，而一个单独的帧则需要一个帧头、确认信息和校 验和。而且，发送的帧越少，也意味着接收方的处理负担越轻。在下面讨论的协议中，捎 带宇段只占用帧头中的 1 位，它很少会占用许多位。

[滑动窗口概览](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=190)

-   接下去的 3 个协议都是双向协议，它们同属于一类称为滑动窗口 Csliding window)的 协议。这 3 个协议在效率、复杂性和缓冲区需求等各个方面有所不同，本节后面将会逐个 讨论。
    
-   所有滑动窗口协议的本质是在任何时刻发送方总是维持着一组序号，分别对应于允许 它发送的帧。我们称这些帧落在发送窗口( sendingwindow)内。
    
-   发送方窗口内的序号代表了那些可以被发送的帧，或者那些已经被发送但还没有被确 认的帧。任何时候当有新的数据包从网络层到来时，它被赋予窗口中的下一个最高序号， 并且窗口的上边界前移一格。当收到一个确认时，窗口的下边界也前移一格。按照这种方 法发送窗口持续地维持了一系列未被确认的帧。

-   由于当前在发送方窗口内的帧最终有可能在传输过程 中丢失或者被损坏，所以，发 方必须在内存中保存所有这些帧，以便满足可能的重传需要。

-   接收方数据链路层的窗口对应于它可以接受的帧。

### [3.4.1 1位滑动窗口协议](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=191)
    
-   在讨论一般情形以前，我们先来考察一个窗口尺寸为 1 的滑动窗口协议。由于发送方 在发出一帧以后，.必须等待前一帧的确认到来才能发送下一帧，所以这样的协议使用了停. 等式办法。

### [3.4.2 回退N协议](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=193)

-   到现在为止，我们一直有这样的默契假设，即一个帧到达接收方所需要的传输时间加 上确认帧回来的传输时间可以忽略不计。有时候，这种假设明显是不正确的。在这些情形 下，过长的往返时间对于带宽的利用效率有严重的影响
    
-   很显 然，站在效率的角度，长发送时间、高带宽和短帧这三者组合在一起就是一种灾难。
    
-   这里描述的问题可以看作是这种规则的必然结果，即发送方在发送下一帧之前必须等 待前一帧的确认。

[管道化](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=194)
- 保持多个帧同时在传送的技术是管道化( pipelining)的一个例子。在一个不可靠的通 信信道上像管道一样传送帧会引起一些严重的问题

-   一种选择办法称为回退 n (go-back-n)，接收方只需简单丢弃所有到达的后续帧，而且针对这些丢弃的帧不返回确认。

[选择重传](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=195)
-   针对管道化发送帧发生的错误，另一种通用的处理策略称为选择重传( selective rep阅t)。使用这种策略，接收方将收到的坏帧丢弃，但接受并缓存坏帧后面的所有好帧。 当发送方超时，它只重传那个最早的未被确认的帧。

### [3.4.3 选择重传协议](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=198)
    
-   如果错误很少发生，则回退 n 协议可以工作得很好:但是，如果线路质量很差，那么 重传的帧要浪费大量带宽。另一种处理错误的策略是选择重传协议，允许接收方接受并缓 存坏帧或者丢失帧后面的所有帧。
    
-   在这个协议中，发送方和接收方各自维持一个窗口，该窗口分别包含可发送或己发送 但未被确认的和可接受的序号。发送方的窗口大小从 0 开始，以后可以增大到某一个预设 的最大值。相反，接收方的窗口总是固定不变，其大小等于预先设定的最大值。

## [3.5 数据链路协议实例——PPP](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=203)

-   为了在这些链路上承载数据包，需要某种成帧机制，以便将偶尔出现的数据包从传输 它们的连续比特流中区分出来。运行在 E 路由器上的 PPP 就提供了这种运行机制 3-23所示.
    
-   PPP 提供了 3 个主要特性: (1) 一种成帧方法。它可以毫无歧义地区分出一帧的结束和下一帧的开始. (2) 一个链路控制协议.它可用于启动线路、测试线路、协商参数 ， 以及当线路不再 需要时温和地关闭线路。该协议称为链路控制协议 (LCP, Link Control Protocol)。 (3)一种协商网络层选项的方式。协商方式独立于网络层协议.所选择的方法是针对 每一种支持的网络层都有一个不同的 网络控制协议 (NCP, Network Control Protocol)

## [本章小结](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=207)

-   数据链路层的任务是将物理层提供的原始比特流转换成由网络层使用的帧流。链路层 为这样的帧流提供不同程度的可靠性，范围从无连接无确认的服务到可靠的面向连接服务 不等。
    
-   链路层采用的成帧方法各种各样，包括字节计数、字节填充和比特填充。数据链路协 议提供了差错控制机制来检测或纠正传输受损的帧，以及重新传输丢失的帧。为了防止快 速发送方淹没慢速接收方，数据链路协议还提供了流量控制机制。滑动窗口机制被广泛用 来以一种简单方式集成差错控制和流量控制两大机制。当窗口大小为 1 个数据包时，则协 议是停·等式的。
    
-   我们考察了一系列协议，这些协议在更现实的假设下通过确认和重传，或者 ARQ (自动重复请求〉机制为上层提供了一个可靠的链路层。从一个无错误的环境开始，即接收方 可以处理传送给它的任何帧，我们引出了流量控制，然后是带有序号的差错控制和停.等式 算法。然后，我们使用滑动窗口算法允许双向通信，并引出捎带确认的概念。最后给出两 个协议把多个帧的传输管道化，以此来防止发送方被一个有着漫长传播延迟的链路所阻塞。 接收方可以丢弃所有乱序的帧，或者为了获得更大的带宽效率而缓冲这些乱序帧，并且给 发送方反馈否定确认。前一种策略是回退 n 协议，后一种策略是选择重传协议。

-   Internet使用 PPP 作为点到点线路上的主要数据链路协议。 PPP 协议提供了无连接的无 确认服务，使用标志字节区分帧的边界，
    