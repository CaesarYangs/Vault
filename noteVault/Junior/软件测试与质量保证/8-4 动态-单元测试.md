- Q：什么是单元测试
- Q：为什么要进行单元测试
- Q：单元测试环境
- Q：单元测试工具

# 什么是单元测试
- **软件测试整体的 4 个阶段概述：按阶段进行测试是一种基本的测试策略**
    - 单元测试：对源代码的每一个程序单元进行测试
    - 集成测试：把已经测试过的程序模块组装起来进行集成测试 与设计相关的软件体系结构
    - 系统测试：把经过测试的软件在实际环境中运行 便于其他系统组合在一起进行测试
    - 验收测试：由用户进行最终的验收检查

- 测试 V 模型图
    - ![](https://raw.githubusercontent.com/CaesarYangs/MyPictureHotel/main/BasicImg/202205051049022.png)

-  *Q：单元测试是什么？*
    - 对软件基本组成单元进行的测试
    - 开发者编写的一小段代码，用于检验被测代码的一个很小的、很明确的功能是否正确
    - 用于判断某个特定条件（或者场景）下某个特定函数的行为。
    - 证明某段代码的行为确实和开发者所期望的一致
    - 用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作。
- <u>与集成测试、系统测试的区别</u>[](marginnote3app://note/471FFBCF-1640-4FE1-B701-C02F2E63B3CB)
    - ![](https://raw.githubusercontent.com/CaesarYangs/MyPictureHotel/main/BasicImg/202205051051275.png)
    - <u>如何对函数 abs()进行单元测试?</u>[](marginnote3app://note/4BE2FDA8-5AEB-4CF7-9E40-E6C1510D6E7C)
    - <u>要向客户演示系统的基本功能</u>[](marginnote3app://note/13227641-48C3-47D5-9340-BD5696505AD1)

- **单元测试的目的**
    - 验证代码是否与设计相符合的
    - 跟踪需求和设计的实现
    - 发现设计和需求中存在的错误，发现在编码过程中引入的错误
    - 会使你的工作完成的更轻松，而且会令你的设计变得更好，甚至大大减少你花在调试上面的时间。
    - 可以提高底层代码的正确性，从而提高调用它的高层代码的正确性。

## 单元测试的意义
- **单元测试的意义**
    - 例子：如何对函数 abs()进行单元测试？
        - 在各种输入值的环境下的返回结果情况
    - 如果我们对 abs()函数代码做了修改，只需要再跑一遍单元测试
        - 如果通过，说明我们的修改不会对有的行为造成影响
        - 如果测试不通过，说明我们的修改与原有行为不一致，要么修改代码，要么修改测试。
    - **确保一个程序模块的行为符合我们设计的测试用例。** 在将来修改的时候，可以极大程度地保证该模块行为仍然是正确的。
    - 不写单元测试的借口
        - 编写单元测试太花时间了
        - 运行测试的时间太长了
        - 测试代码并不是我的工作
        - 我并不清楚代码的行为，所以也就无从测试
        - 这些代码都能够编译通过
        - 公司请我来是为了写代码，而不是写测试
        - 如果我让测试员或者 QA 人员没有工作，那么我会觉得很内疚
        - 我的公司并不会让我在真实系统中运行单元测试

- **检查代码是否符合设计和规范**
- **尽早发现错误**
    - 错误发现越早,成本越低.
    - 开发人员过于自信,后期复杂度高,发现解决BUG困难.
    - 检查代码是否符合设计和规范
    - ![](https://raw.githubusercontent.com/CaesarYangs/MyPictureHotel/main/BasicImg/202205051100990.png)

- **单元测试的特点**
    - 时间短 效率高
    - 由一个程序员完成
    - 有详细的设计说明来包括输入定义 输出定义和加工说明
    - 它是一个可识别的 看得见的程序组成部分
    - 并且容易被组合成程序
    - 并能够单独的编译和测试
    - 规模小 逻辑简单

- 编程过程中，每写 100 行代码会犯 150 个错误
- 编程与编译运行结束后，每 100 行大约残留有 1-3 个 Bug
- 寻找与修改程序错误的代价占总体开发投资的 40%-80%
- Bug 在整个研发流程中被发现的越早，修改的代价就越低

- 开发流程时间表与修改 Bug 代价的关系图
    - ![](https://raw.githubusercontent.com/CaesarYangs/MyPictureHotel/main/BasicImg/202205051103107.png)
- 例子：<u>查找 list[]中的最大值:</u>[](marginnote3app://note/F391727E-C2E1-4884-A062-2CA14BF17FCD)

## 单元测试的内容
- 单元测试的对象：软件设计的最小单位，即模块或函数
- ![](https://raw.githubusercontent.com/CaesarYangs/MyPictureHotel/main/BasicImg/202205051108568.png)

### 模块接口测试
- 检查模块接口是否正确
    - 对通过所有被测模块的数据流进行测试。
- Myers 在关于软件测试的书中为接口测试提出了一个检查表
    - 调用本模块的输入参数是否正确
        - 模块各输入的参数属性与对应的形参属性是否一致。
        - 模块各输入的参数类型与对应的形参类型是否一致。
    - 本模块调用子模块时输入给子模块的参数是否正确
        - 传到被调用模块的实参的数目是否与被调用模块形参的数目相同。
        - 传到被调用模块的实参的属性是否与被调用模块形参的属性相同。
        - 传到被调用模块的实参的类型是否与被调用模块形参的类型相同。
    - 引用内部函数时，实参的次序和数目是否正确。
    - 是否引用了与当前入口无关的参数。
    - 用于输入的变量有没有改变。
    - 在经过不同模块时，全局变量的定义是否一致。
    - 限制条件是否以形参的形式传递。
    - 使用外部资源时，是否检查可用性并及时释放资源，如内存、文件、硬盘、端口等

### 局部数据结构测试
- 是最常见的错误来源
- 检查局部数据结构完整性
- Checklist
    - 不正确或不一致的数据类型说明
    - 使用尚未赋值或尚未初始化的变量
    - 错误的初始值或错误的默认值
    - 变量名拼写错或书写错——使用了外部变量或函数
    - 不一致的数据类型
    - 全局数据对模块的影响
    - 数组越界
    - 非法指针

### 路径测试
- 检查由于计算错误、判定错误、控制流错误导致的程序错误。
- 根据“白盒”测试和“黑盒”测试用例设计方法设计测试用例，对模块中重要的执行路径进行测试。
- 重要的执行路径
    - 指那些处在完成单元功能的算法、控制、数据处理等重要位置的执行路径，也指由于控制较复杂而易错的路径，有选择地对执行路径进行测试是一项重要的任务。

- Checklists
    - 死代码
    - 错误的计算优先级
    - 算法错误
    - 混用不同类的操作
    - 初始化不正确
    - 精度错误——比较运算错误、赋值错误
    - 表达式的不正确符号——> >= = == !=
    - 循环变量的使用错误——错误赋值以及其他错误等

### 错误处理测试
- 可能引发错误处理的路径及进行错误处理的路径
- 错误出现时错误处理程序重新安排执行路线，或通知用户处理，或干脆停止执行使程序进入一种安全等待状态。
- 测试人员应意识到，每一行程序代码都可能执行到，不能自己认为错误发生的概率很小而不去进行测试。

- 应考虑下面几种可能的错误
    - 出错的描述是否难以理解，是否能够对错误定位。
    - 显示的错误与实际的错误是否相符；
    - 对错误条件的处理正确与否；
    - 在对错误进行处理之前，错误条件是否已经引起系统的干预等。
- 在进行错误处理测试时，要检查如下内容：
    - 在资源使用前后或其他模块使用前后，程序是否进行错误出现检查。
    - 出现错误后，是否可以进行错误处理，如引发错误、通知用户、进行记录。
    - 在系统干预前，错误处理是否有效，报告和记录的错误是否真实详细。

### 边界测试
- 边界测试是单元测试中最后的任务
- 软件常常在边界上出错，要特别注意数据流、控制流中刚好等于、大于或小于确定的比较值时出错的可能性。
- 检查局部数据结构完整性

- Checklist
    - 普通合法数据是否正确处理。
    - 普通非法数据是否正确处理。
    - 边界内最接近边界的（合法）数据是否正确处理。
    - 边界外最接近边界的（非法）数据是否正确处理等。
    - 在 n 次循环的第 0 次、第 1 次、第 n 次是否有错误
    - 运算或判断中取最大最小值时是否有错误；
    - 数据流、控制流中刚好等于、大于、小于确定的比较值时是否出现错误。
- <u>边界值分析</u>[](marginnote3app://note/8EFF307B-F431-4CDF-8EB0-4F16B6DF08AE)

## 单元测试策略
### 自顶向下的单元测试
- 方法：先对最顶层的基本单元进行测试，把所有调用的单元做成桩模块。然后再对第二层的基本单元进行测试，使用上面已测试的单元做驱动模块。依此类推直到测试完所有基本单元。
- 优点：在集成测试前提供早期的集成途径。在执行上和详细设计的顺序一致。**不需要开发驱动模块。**
- 缺点：随着测试的进行，测试过程越来越复杂，开发和维护成本增加。

### 自底向上的单元测试
- 方法：先对最底层的基本单元进行测试，模拟调用该单元的单元做驱动模块。然后再对上面一层进行测试，用下面已被测试过的单元做桩模块。依此类推，直到测试完所有单元。
- 优点：在集成测试前提供系统早期的集成途径。**不需要开发桩模块。**
- 缺点：随着测试的进行，测试过程越来越复杂。

### 孤立单元测试
- 方法：不考虑每个单元与其它单元之间的关系，为每个单元设计桩模块或驱动模块。每个模块进行独立的单元测试。
- 优点：简单、容易操作
- 缺点：不提供一种系统早期的集成途径。
- 总结：**最好的单元测试策略。**

## 单元测试步骤
- **构造测试用例运行环境**
    - 确定用例运行的前提条件，启动测试驱动，设置桩，设置预期输出条件判断
- **设计黑盒测试用例**
    - 设计基本功能测试用例
        - 证明在正常环境下能运行
    - 设计功能正面测试用例
        - 找出对正确输入可能做出的不正确的处理
    - 设计功能反面测试用例
        - 找出对错误输入可能做出的不正确的处理
    - 设计性能测试用例
- **设计白盒测试用例**
    - 测试内部控制结构和数据使用存在的问题

## 单元测试达到的要求
- 语句覆盖率达到 100%
- 分支覆盖率达到 100%
- 覆盖错误处理路径
- 单元的软件特性覆盖
- 对试用额定数据值、奇异数据值和边界值的计算进行检验，用假想的数据类型和数据值运行，测试排斥不规则输入的能力。

# 单元测试环境
由于自动化的机器无法完美完成动态测试部分的内容，所以需要静态测试人员来手工发挥能力进行处理和完成

单元测试和编码共同属于实现阶段。编码完成并编译通过后
检查出
典型：代码和逻辑的一致性 代码规则的正确性等等


![](https://raw.githubusercontent.com/CaesarYangs/MyPictureHotel/main/BasicImg/202205051120457.png)

## 驱动程序和桩程序
- **驱动程序 driver**
    - 对底层或子层模块进行单元测试时所编制的调用被测模块的程序，用以模拟被测模块的**上级模块**
    - 驱动程序的作用
        - 接受测试数据
        - 调用被测模块，并把相关测试数据传送给被测模块
        - 获得测试结果
- **桩程序 stub**
    - 也称为存根程序，对顶层或上层模块进行测试时，所编制的替代下层模块的程序，用以模拟被测模块工作过程中所调用的模块

## 单元测试的方法和步骤
- **单元测试方法和步骤**
    - ![](https://raw.githubusercontent.com/CaesarYangs/MyPictureHotel/main/BasicImg/202205051127975.png)

- 打桩的目的
    - 隔离
        - 将测试任务从产品项目中分离出来，使之能够独立编译、链接，并独立运行。
        - 例如函数 A 调用了函数 B，函数 B 又调用了函数 C 和 D，如果函数 B 用桩来替代，函数 A 就可以完全割断与函数 C 和 D 的关系
    - 补齐
        - 是指用桩来代替未实现的代码
        - 例如，函数 A 调用了函数 B，而函数 B 由其他程序员编写，且未实现，那么，可以用桩来代替函数测试。
    - 控制
        - 在测试时，人为设定相关代码的行为，使之符合测试需求。
        - 如果函数B返回随机数,或者返回网络状态,或者返回环境温度,等等,则当调用其实际代码时,函数A很难测试,这时可以用桩函数B1来代替B,使其返回测试所需要的数据。

- 编写桩
    - 一般来说，桩函数要具有与原函数完全一致的原形，仅仅是实现不同，这样测试代码才能正确链接到桩函数。
    - 用于实现隔离和补齐的桩函数一般比较简单，只需把原函数的声明拷过来，加一个空的实现，能通过编译链接就行了。
    - 比较复杂的是实现控制功能的桩函数，要根据测试的需要，输出合适的数据。

# 单元测试工具
- JUnit：Java 环境单元测试的终极利器
- CppUnit : JUnit 移植而来
- C++Test ：C/C++ 语言开发的首选利器
- Nunit：.Net 环境单元测试的首选利器
