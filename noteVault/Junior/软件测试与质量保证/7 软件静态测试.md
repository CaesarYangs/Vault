- *Q：有哪些测试技术？*
- *Q：什么是静态测试？*
- *Q：静态测试内容是什么？*
- *Q：静态测试技术有哪些？*

# 静态测试基本概念
- **软件测试的复杂性**
    - 无法对软件进行完全测试
    - 测试无法显示潜在的软件缺陷和故障
    - 用户发现的故障现象与测试发现的故障数量成正比
        - *约 47% 的软件故障是由用户发现的，并只与系统当中 4% 的程序模块有关*
    - 不能修复所有软件故障
        - 杀虫剂现象

- **测试工作量与缺陷数量的关系**
    - ***软件测试根据测试的目标、阶段、方法将采用不同的技术。***
    - ![](https://raw.githubusercontent.com/CaesarYangs/MyPictureHotel/main/BasicImg/202205041617287.png)
- 不同阶段修复缺陷的成本有很大不同
    - <u>不同阶段修复缺陷的成本</u>[](marginnote3app://note/FC86A90E-6E06-457A-BDD3-0CD0507D67BE)
    - 在用户需求分析阶段，概要设计阶段，详细设计阶段的修复成本较低
    - 在编码和实现部分的修复成本明显比在测试阶段的成本低
    - 集成测试，系统测试的修复成本高很多
    - **用户验收和使用阶段发现和修复的成本最高**

## 测试技术分类
<u>测试技术分类</u>[](marginnote3app://note/D7F2DB49-7C02-4081-B716-D50AE90B98BE)
- **白盒、黑盒**
    - 按照测试用例设计方法和是否分析程序的内部结构
- **静态、动态**
    - 按照软件测试针对是否运行软件和执行程序
- **手工测试、自动化测试、混合测试**
    - 软件测试在具体测试时是否运用测试工具
- **单元测试、集成测试、系统测试（功能测试、性能测试、安全性测试、回归测试、确认性测试）、验收测试**
    - 将软件产品按照局部与整体的关系和功能而论——按照阶段划分
- **传统面向过程的测试、面向对象的测试**
    - 软件架构设计是否采用了面向对象技术
- **单机模式测试、特定应用系统的测试（网络性能测试、数据库性能测试、服务器性能测试、客户端性能测试等）、嵌入式系统测试**
    - 按照软件系统的架构或设计是否在网络环境下运行，还是在单机环境下进行，或是特定环境下的应用（如嵌入式系统等）

## 静态测试概念
- **静态测试定义**
    - 不执行程序代码而寻找代码中可能存在的错误或评估程序代码的过程。
    - 静态测试可以手工进行，也可以借助软件工具自动进行。

- *Q：为什么要进行静态测试？*
- 一个软件产品可能实现了所要求的功能
    - 但如果它的内部结构复杂、混乱，代码的编写也没有规范的话，这时软件中往往会隐藏一些不易被察觉的错误
- 即使这个软件基本满足了用户目前的要求
    - 但到了日后对该产品进行维护升级工作的时候，会发现维护工作相当困难

- **静态测试特点**
    - 不必动态执行程序，也就是不必进行测试用例设计和结果判读等工作
    - 由人手工方式进行，充分发挥人的优势
        - 在充分利用人思维互补的情况下，检验出错误的水平非常高。
    - 实施不需要特别条件，容易开展

- <u>静态测试与动态测试有效性对比</u>[](marginnote3app://note/80B4B53A-1C14-455A-8F05-1C3E8B359A90)

## 静态测试过程
### 需求分析
- 依据开发计划、需求文档，确定测试需求，建立测试基础和评审基础，建立标准测试计划，细节的设计，数据库的测试

### 概要设计
- 完成测试方案的制订，包括测试内容、测试策略、测试方法、测试目标
- 建立测试详细设计的基础与测试评审的基础，进入静态测试评审阶段

### 详细设计
- 完成测试进程的具体安排和测试实施的具体细节考虑

### 计划执行
帮助更好地维护代码结构

# 静态测试内容
<u>缺陷产生的原因图</u>[](marginnote3app://note/C8D432B3-3C51-4534-8F37-BE2B32B291AF)
- **检查需求**
    - 静态测试的对象不仅仅包含代码。
- **检查设计**
    - 原因：错误往往有很多来自之前的需求分析和设计阶段
- **检查代码**

- 缺陷产生的原因
    - 需求占超过一半的比例
    - 设计占大约四分之一比例
    - 编码和其他原因占据剩余的四分之一

## 检查需求
> 错误往往有很多来自之前的需求分析和设计阶段
> 对应于之前的全生命周期软件测试

- **着重于测试对用户需求的描述和解释是否完整、准确；**
- **按照所测试的软件质量因素划分**——<u>作为需求中的重要质量因素需要关注 更关注需求中的质量因素</u>
    - 兼容性、完备性、一致性、正确性、可行性、易修改性、健壮性、易追溯性、易理解性、易测试性、可验证性
        - *举例：易理解性*
            - 是否每一个需求都只有一种解释？
            - 功能性需求是不是以模块方式描述的，是否明确的标识出了其功能？
            - 是否有术语定义一览表？
            - 是否使用了形式化或半形式化的语言？
            - 语言是否有歧义性？
            - 需求定义中是否只包含了必要的实现细节而不包含不必要的实现细节？是否过分细致了？
            - 需求定义是否足够清楚和明确使其能够作为开发设计规约和功能性测试数据的基础？
            - 需求定义的描述是否将对程序的需求和所提供的其它信息分离开来了？
        - *举例：易测试性和可验证性*
            - 需求是否可以验证？（即是否可以检验软件是否满足了需求？）
            - 是否对每一个需求都指定了验证过程？
            - 数学函数的定义是否使用了精确定义的语法和语义符号？

## 检查设计
- **着重于分析**
    - 设计是否与需求定义一致
    - 所采用的数值方法和算法是否适用于待解问题
    - 程序的设计中对程序的划分是否与待解问题相适应
    - 需求是否都被满足了
    - etc.
- **按照所测试的软件质量因素划分**
    - 完备性、一致性、正确性、可行性、易修改性、模块性、可预测性、结构化、易追溯性、易理解性、可验证性/易测试性
        - *举例：一致性*
            - 在设计文档中，是否始终使用标准的术语和定义？文档的风格和详细程度是否前后始终一致？
            - 界面之间是否相容？
            - 设计是否包含内在矛盾？
            - 模型、算法和数值方法之间是否在数学上是相容的？
            - 输入/输出的格式是否一致？
            - 类似的功能和相关的功能的设计是否一致？
            - 计算中的输入、输出和数据库成分的计量单位和计算精度是否一致？逻辑表达式是否一致？
        - *举例：正确性*
            - 设计文档是否满足有关标准的要求？
            - 设计是否只完成需求定义中要求的功能？若包含额外的功能，则这些功能的必要性是否经过论证？
            - 测试文档是否准确？
            - 设计逻辑是否正确？即，程序是否会完成所需的功能？
            - 设计是否与所描述的操作环境相一致？
            - 界面的设计是否与文档所描述的界面部分一致？
            - 对于设计者不能选择的输入输出和数据库成分的数据格式、内容和数据率，设计是否正 确地给予了安排？

---
## 检查代码
***这一章节包含了几乎所有的软件静态测试 代码测试中需要的上层方法论概念定义***
- **大部分的错误可通过代码检查发现**
> 80% 的问题是由于 20% 的代码引起的

- 研究分析代码而不用实际执行
- 需要提供的信息
    - 度量标准
    - 容易产生错误的代码
    - 代码规则的执行
    - 流图和调用图的分析

### 代码审核内容
- **分析容易产生错误的代码:**
    - **控制流分析**
        - 非结构化代码
        - 死代码
    - **数据流分析**
        - 未定义的数据的使用
        - 未使用的数据
- **流图和调用关系图**
    - 作为理解代码的帮助
    - 作为审核符合设计的帮助
    - 作为测试设计的帮助
    - 作为调试的帮助
- **代码规则的执行**
    - 针对不同语言的特征
    - 格式和形式
    - 命名规范
    - 度量标准的强制
- e.g. <u>一个例子</u>[](marginnote3app://note/960F4B57-43E7-4B21-99DD-B59FA64D3DB3)
    - 程序没有注释，没有返回值类型
    - 没有参数列表
    - 一行代码只定义一个变量
    - 精度丢失
    - 程序适当加些空行

### 编码规则
- 编码规则定义（编程风格）
    - 是对程序代码的格式、注释、标识符命名、语句使用、函数、类、程序组织、公共变量等方面的要求
        - 开发人员书写的代码更健壮、更安全、更可靠
        - 提高代码的可读性，使代码易于查看和维护
- 规范分为两个级别——规则和建议
    - 规则级的规范要求开发人员必须要遵守
    - 建议级的规范开发人员应尽量遵守

# 静态测试技术
## 1. 代码检查
- **代码检查内容**
    - 检查代码和设计的一致性
    - 代码对标准的逻辑、可读性
    - 代码逻辑表达的正确性
    - 代码结构的合理性
    - 违背程序编写标准的问题，不安全、不明确和模糊的部分，找出程序中不可移植部分、违背程序编程风格的问题
        - 变量检查、命名和类型审查、程序逻辑审查、程序语法检查和程序结构检查

- **代码检查优缺点**
    - 优点：
        - 比动态测试更有效率，能快速找到缺陷，发现 30%-70% 的逻辑设计和编码缺陷
        - 看到的是问题本身而非征兆
    - 缺点：
        - 耗费时间
        - 需要知识和经验的积累

### 检查内容和流程
- 主要由人工进行
    - **桌面检查**
        - 程序员阅读自己所编的程序
        - 缺点：心理上认为没有错误；由于思维定势，习惯性错误不易发现；功能理解有错，错误无法被发现
        - <u>所以这种方法效率不高，可作为个人自我检查程序中明显的疏漏或笔误</u>
    - **代码审查 Code Inspection**
    - **代码走查 Walkthrough**
        - 由若干程序员与测试员组成一个小组，集体阅读并讨论程序，或者用“脑”执行并检查程序的过程
        - 分两步完成
            - 预先作一定的准备工作
            - 然后举行会议进行讨论
        - 会议的主题是发现错误而不是纠正错误
        - 优点：
            - 不仅比桌面检查优越得多，而且与动态测试的方法相比也有很多优点
            - 第一，使用这种方法测试，一旦发现错误，就知道错误的性质和位置，因而调试所花费的代价低
            - 第二，使用这种方法一次能揭示一批错误，而不是一次只揭示一个错误
            - 如果使用动态测试，通常仅揭示错误的征兆。
        - **效果**
            - 经验表明，使用这种方法能够优先的发现 30~70％的逻辑设计和编码错误
            - IBM 使用代码审查方法表明，错误的检测效率高达全部查出错误的 80％
            - Myers 的研究发现代码审查和代码走查平均查出全部错误的 70%
    - **代码审查、走查与动态测试相互补充**
        - 研究表明使用代码审查和代码走查发现某类错误比用动态测试更有效
        - 由此可见代码审查和代码走查方法与动态测试结合，测试效果更佳。
- 可由软件工具自动进行静态分析

### 代码审查
- **代码审查的测试内容**
    - 检查代码和设计的一致性
    - 检查代码对标准的遵循、可读性
    - 检查代码的逻辑表达的正确性
    - 检查代码结构的合理性
- **代码审查的组成和方式**
    - 由一组程序和错误检查技术组成
    - 以代码审查组方式组织
    - 代码审查组
        - 通常由四人组成，其中一人为组长
        - 组长是关键，最好是一个称职的程序员，但不是被测试程序的编写者，也不需要对所检查的程序很熟悉，但需要较强的组织协调和语言能力
        - 组长的职责包括分配资料、安排计划、主持开会、记录并保存被发现的错误
        - 其余成员包括资深程序员、程序编写者与专职测试人员
        - 根据测试的组织方式（如内部测试和独立测试）不同，代码审查小组组成可以调节，但组长角色不能变动
    - **代码审查的步骤**
        - 准备
            - 组长提前把程序目录表和设计说明书等材料分配给小组成员。小组成员熟悉这些材料
            - 由被测程序的设计和编码人员向审查组详细说明所准备的材料，特别是代码的主要功能与功能间的关系
        - 程序阅读
            - 审查组人员仔细阅读代码和相关材料
            - 对照代码审查单标出明显缺陷及错误
        - 审查会议
            - 审查会由组长主持
            - 首先由程序员逐句阐明程序的逻辑，在此过程中可由程序员或其他小组成员提出问题，追踪错误是否存在
            - 经验证明在上述阐述过程中，有很多错误由讲述程序者而不是其他小组成员发现
            - 大声地朗读程序给听众，这样简单的工作是有效的错误检测技术
            - 然后利用代码审查单来分析讨论
            - 组长负责讨论沿着建设性的方向前进，而其他人则集中注意力发现错误，但不去纠正错误
        - 跟踪和报告
            - 会后把发现的错误登记造表并交给程序开发人员
            - 如果发现错误较多或发现重大错误，那么在改正之后，组长要再次组织审查会议
            - 为了改进以后的审查工作，对错误登记表也要分析，归类和精炼
        - 审查会议的时间
            - 1.5~2 小时为宜
            - 审查会需要高度集中注意力，时间太长反而容易使效率降低
            - 每次会议可能处理一个或几个模块
- **代码审查单**
    - 代码审查单是代码审查过程所用的主要技术
    - 通常是把程序设计及编码中可能发生的各种错误进行分类，对每一类列举出尽可能多的典型错误，然后制成表格
    - 其它测试中发现的错误也要及时归入代码审查单，形成某一类型软件针对性的代码审查单，以供审查时使用
    - 还可以包括编程风格、标准、规范的符合性方面的内容
    - 在代码审查单的错误登记表中，应写明所查出的错误的类型、错误类别、错误的严重程度、错误的位置、错误的原因等信息。
- **G.J.Myers 的代码审查单**
    - **数据引用错误**
        - 是否引用了未赋值或者未初始化的变量？
        - 所有的数组引用，其下标值是否都在各自的相应维数定义界内？
        - 所有的数组引用，每一个下表是否是整数值？
        - 所有引用的指针或变量当前是否已经分配储存了？（即是否存在“悬挂引用”的问题）
    - **数据说明错误**
        - 所有变量是否都显式地说明了？
        - 是否每个变量都赋予正常的长度、类型和存储分类？
        - 变量的初始化和它的存储类型是否有矛盾？
    - **计算错误**
        - 是否使用过非一致的数据类型的变量进行运算？
        - 是否存在混合运算？
        - 赋值语句的目标变量是否比其右边的表达式小
- **代码审查辅助工具**
    - 汇编或编译器生成的交叉引用表（变量、标号、子程序）
    - 逆向工程工具（例如从源代码生成流程图）
    - 带有快速查找的编辑器

### 阅读方法
- 要仔细阅读需求设计等文档，特别是了解软件的整体物理意义、应用背景以及在大系统中的地位
- 对大型软件而言，这些信息会在阅读程序时有效地帮助读者从一定的高度审视，而不是停留在逐行扫描代码
- 有些错误要有整体观才能发现
- 阅读结构化代码的两种方法
    - 深度优先遍历——追踪通过每个子程序的主要逻辑行，主要逻辑行全部跟踪完，然后开始跟踪第二条路径
    - 广度优先遍历——按排列顺序追踪代码，从主要行开始，然后检查较低层的程序段
    - 两种阅读方法综合使用
        - 这两种方式的差别在于何时进入下层模块，选择那种方式要视具体程序特点而定
        - 广度优先遍历有助于很快地了解程序的全貌
        - 深度优先适于详细查阅功能处理步骤
    - 应综合使用上述两种方法，在头一两遍阅读时，采用广度优先，然后用深度优先
- 阅读次数
    - Beizer 提出至少要读程序 4 次，分别针对印刷错误、数据结构、控制流和处理
    - 4 次阅读要比读一次能更快、更容易、更可靠的完成任务

### 代码走查
- 代码走查与代码审查相似，它也是由一组程序和错误检查技术组成，只是程序和错误检查技术不完全相同。
- 代码走查组
    - 代码走查以小组方式进行
    - 代码走查组包括
        - 组长，类似代码审查组长
        - 秘书，负责记录发现的错误，要有一定水平
        - 测试人员，应是具有经验的程序设计人员，或精通程序设计语言的人员，或从未介入被测试程序的设计工作的技术人员（这样的人没有被已有的设计框住），没有约束，比较容易发现问题。
- **代码走查过程**
    - 与代码审查过程相似
    - 先把材料交给每个小组人员，让他们认真研究程序，然后再召开代码走查会议。
- 代码走查会议内容
    - 与代码审查不同，不是读程序和使用代码审查单，**而是由被指定的作为测试员的小组成员提供若干测试用例**（程序的输入数据和期望的输出结果）
    - 以 1－2 小时为宜，但不允许中断
    - 如果发现问题由秘书记下来，中间不讨论任何纠错问题，主要是发现错误
- 测试用例在代码走查中的作用
    - **测试用例并不是关键**，也并不是仅想验证这几个测试用例运行是否正确
    - 测试用例是作为**怀疑程序逻辑与计算错误的启发点**，在随测试实例游历程序逻辑时，在怀疑程序的过程中发现错误
        - 比几个测试用例本身直接发现的错误要多得多
- 代码走查缺点
    - 代码走查使用测试用例启发检测错误，**人们注意力会相对集中在随测试用例游历的程序逻辑路径上，不如代码审查检查的范围广，错误覆盖面全。**
- 技术评审
    - 综合运用走查和审查技术，逐页、逐节地检查软件开发前期需求分析和设计的文档，对软件的需求，设计结构等方面提出问题
    - 评审也被当作一种管理工具，经过评审不仅可以提高各阶段软件产品的质量，还可以收集到一些有关该软件产品质量的数据
    - 技术评审属于广义的测试范畴，也是一种质量保证手段
    - 软件开发过程中每个阶段的评审都必须十分正规的，严格的加以定义，并根据规程实施。

## 2. 静态结构分析
- **程序流分析**
    - 通过静态分析发现程序在运行行为方面的某些特性
    - 控制流分析、数据流分析
- **以图形的方式表现程序内部结构**
    - 函数调用关系图、函数内部控制流图
- 检查项
    - 代码风格和规则审核
    - 程序设计和结构审核
    - 业务逻辑的审核
    - 走查、审查与技术复审手册

### 各种流图
#### 程序流程图
- **以描述程序控制的流动情况为目的，表示程序中的操作顺序**
    - 指明实际处理操作的处理符号，包括根据逻辑条件确定要执行路径的符号
    - 指明控制流的流线符号
    - ![](https://raw.githubusercontent.com/CaesarYangs/MyPictureHotel/main/BasicImg/202205041706788.png)

#### 控制流图
- 两种图形符号
    - 节点
        - 标有编号的圆圈
        - 代表程序流程图中句型、菱形、多条流线相交的汇合点
    - 控制流线或弧
        - 带箭头的有向弧，表明控制的顺序
        - 控制流通常有名字
    - 从程序流程图转化为控制流图
        - 一个节点包含 1 个或多个连续的无分支语句
        - 节点不允许含有复合节点
        - 单入单出的可以合并成一个节点
    - ![](https://raw.githubusercontent.com/CaesarYangs/MyPictureHotel/main/BasicImg/202205041707335.png)
- **控制流图的作用**
    - ==不但提供程序控制结构分析的基础，还帮助发现程序结构上的问题==
        - 从入口进入后无法到达的语句
            - 从入口结点开始对控制图进行遍历，不能遍历到的结点或边所对应的代码
        - 不能到达结束的语句
        - 未使用过的语句标号

#### 数据流图
- 最常用的结构化分析工具，**从数据传递和加工角度**，以图形的方式刻画系统内的数据运动情况
- 数据流表示数据的流动情况
- 加工
    - 表示对数据的加工处理过程，它的名字应能简明扼要地表明所完成的是什么加工
- 数据存贮
    - 在数据流图中起着保存数据的作用
    - 指向数据存贮的数据流可以理解为写数据，从数据存贮引出的数据流可以理解为读数据
    - 双向数据流可以理解为修改数据
- 数据源点或终点
    - 表示图中出现数据的始发点或终止点，它在图中的出现仅仅是一种符号，并不需要以软件的形式进行设计和实现
- ***数据流问题***
    - 定义：程序中某一语句执行时能改变变量的值，称 V 被该语句定义
    - 引用：如果某一语句的执行引用了内存中变量 V 的值，称该语句引用变量 V
    - **查找出对未定义变量的使用和未曾使用的定义**

#### 调用关系图
- 函数调用关系图或程序调用关系图（被调用）
    - 对源程度中函数调用关系的一种静态描述
    - 在函数调用图中，节点表示函数，边表示函数之间调用关系
    - 函数调用图在软件工程领域有广泛的应用，如编译优化，过程间数据流分析，回归测试，程序理解等

e.g. Linux 0.11 的主函数 main 的调用层次关系

- **缺陷诊断**
    - 利用调用关系图发现递归调用的问题，从而进行诊断

#### 程序流程图 -> 控制流图
- 一个节点包含 1 个或多个连续的无分支语句
- **节点不允许含有复合节点**
- 单入单出的可以合并成一个节点

*实际问题：从流程图转化为控制流图*
步骤：
1.  分析控制流图中应该有几个节点
2.  用新的流线或弧将其连接

![](https://raw.githubusercontent.com/CaesarYangs/MyPictureHotel/main/BasicImg/202205041709728.png)

#### 数据流问题
- **定义**：程序中某一语句执行时能改变变量的值，称 V 被该语句定义
- **引用**：如果某一语句的执行引用了内存中变量 V 的值，称该语句引用变量 V
- **查找出对未定义变量的使用和未曾使用的定义**
- <u>数据流问题</u>[](marginnote3app://note/D76A5041-037A-4AF1-B1CA-EB389DD72579)

### 静态分析工具
- 扫描程序正文，分析数据流和控制流，输出测试报告
- 常见功能：
    - 检查变量一致性
    - 检查模块接口一致性
    - 检查逻辑上错误结构以及多于不可达的程序段
    - 检查变量错误可能影响到的语句变量
    - 检查违反编程标准的错误
    - 统计功能
- 结构
    - 语言程序的预处理器、数据库、错误分析器、报告生成器
- 常用工具
    - PC-Lint

# 代码质量度量

- *Q：如何评估软件质量？*

## 质量概念
- 软件质量
    - 软件产品满足用户要求的程度----《Handbook of Software Quality Assurance》
    - 软件特性的总和,软件满足规定或潜在用户需求的能力。------ISO14598
    - 质量是系统、部件或过程满足(1)明确需求,(2) 客户或用户需要或期望的程度。---IEEE《Standard Glossary of Software Engineering Terminology》
    - 软件满足规定或潜在用户需求特性的总和。包括“内部质量”、“外部质量”和“使用质量”三部分。----ISO9126
- 用户对软件质量的理解
    - 没有××功能(功能)
    - 运行速度太慢(性能)
    - 有太多的错误(故障)
    - 软件不好改动(维护)
    - 界面不美观(人机界面)
    - 这个软件不好使用(易用性)
- 不同视角理解软件质量
    - **软件质量是一个复杂的概念,不同的人从不同的角度来看待软件质量问题会有不同的理解**
        - 用户视角:质量就是满足客户的需求
        - 开发者的视角:质量就是与需求说明保持一致
        - 产品视角: 质量就是产品的内在特点
        - 价值视角:质量就是客户是否愿意购买
        - 项目经理视角:质量就是能“令人满意”地工作以完成预期功能的软件产品

### 软件质量指标
- 正确性:实现的功能达到设计规范,并满足用户需求的程度
- 可靠性:规定的时间和条件下,仍能维持其性能水准的程度
- 易用性:用户掌握软件操作所要付出的时间及努力程度
- 效率:软件执行某项功能所需电脑资源(含时间) 的有效程度
- 可维护性:当环境改变或软件发生错误时,执行修改或恢复所做努力的程度
- 可移植性:从一个系统/环境移到另一系统/环境的容易程度

- 可维护性
    - 模块化(Modularity)
    - 增强能力/灵活性(Augment ability)
    - 可测试性(Testability)
    - 可追溯性(Traceability)
    - 简单性 (Simplicity)
    - 自我描述性(Self Descriptiveness)
    - 系统兼容性(System Compatibility)
    - 文档质量(Document Quality)

## 软件质量模型
- 软件质量模型
    - McCall 软件质量模型 ( 1977)
        - 由 11 个指标构成,分为产品操作,产品修订和产品转移
    - Boehm 模型 (1978)
        - 基于很多特性和 19 个标准
    - ISO/IEC 9126 (1991)
        - 包括 6 个质量目标,每个质量目标有很多属性

### MCCall 质量模型
- <u>MCCall 质量模型</u>[](marginnote3app://note/4BAD0182-9E4A-464B-A35B-FE3ACAB32ADC)
- 早期的软件质量模型是 1977 年 McCall 和他的同事建立的, 提出了影响质量因素的分类
- 集中在软件产品的三个重要方面
    - **操作特性(产品运行)**
    - **承受可改变能力(产品修正)**
    - **新环境适应能力(产品转移)**

### Boehm 质量模型
- <u>Boehm 质量模型</u>[](marginnote3app://note/CFE96C87-9264-4091-97B1-70DD80291795)
- 1978 年 Boehm 和他的同事们提出了分层结构的软件质量模型
    - 除包含了用户的期望和需要的概念,还包括了 McCall 模型中没有的硬件特性
- Boehm 模型始于软件的整体效用,从系统交付后涉及不同类型的用户。
    - 第一种用户是**初始顾客**,系统做了顾客所期望的事情。
    - 第二种用户是**要将软件移植到其他软硬件系统下使用的客户**
    - 第三种用户是**维护系统的程序员**
- 这三种用户都希望系统是可靠有效的,因此,Boehm 模型反映了对软件质量的理解,即**软件做了用户要它做的;有效的使用系统资源; 易于学习和使用;易于维护和测试**

### ISO9126 质量模型
- <u>IS0/IEC9126 质量模型</u>[](marginnote3app://note/F14269F0-A8F1-4968-9C23-6227FBDEB7AB)
- 20 世纪 90 年代早期,软件工程组织试图将诸多的软件质量模型统一到一个模型中,并把这个模型作为度量软件质量的一个国际标准。
- 国际标准化组织 1991 年颁布了 ISO9126-1991 标准《软件产品评价-质量特性及其使用指南》
- 我国也与 1996 年颁发了同样的软件产品质量评价标准 GB/T 16260-1996。它是一个分层质量模型,有 6 个影响质量的特性。

### 质量特性
- 功能性:指软件是否满足了客户的需求
    - 合适性
        - 所提供的功能是用户所需要的,及用户所需要的功能软件系统已提供。
    - 准确性
        - 软件系统提供给用户的功能是否满足用户对该功能的精确度要求。
    - 互操作性
        - 软件系统与一个或多个周边系统进行信息交互的能力
    - 安全性
        - 指软件系统保护信息和数据的能力
    - 依从性
        - 遵循相关的标准(国际标准、国家标准、行业标准、企业内部规范等)约定或法规以及类似规定的能力

- 可靠性:指软件是否能够一直在一个稳定的状态上满足可用性
	- 成熟性
		- 软件系统防止内部错误扩散而导致失效的能力。
	- 容错性
		- 软件系统防止外部接口错误扩散而导致系统失效的能力
	- 易恢复性
		- 系统失效后重新恢复原有功能、性能的能力,包括对原有能力恢复的程度与速度。

- 可用性:衡量用户使用软件需要付出多大的努力的质量属性

- 效率:衡量软件正常运行需要耗费多少时间及物理资源

- 可维护性:衡量对已经完成的软件进行调整需要多大的努力

- 可移植性:衡量软件是否能够方便地部署到不同的运行环境中的能力

- <u>ISO/IEC 25010 中新增了软件使用质量, 其包含 5 个特征,并进一步被划分为可以被度量的多个子特征。</u>[](marginnote3app://note/BE36ABFA-6FC3-4700-BDFD-0E2DDDCD26EB)
- <u>质量模型在测试中的应用</u>[](marginnote3app://note/8EB2F469-FF3B-4478-84C0-1D3F33E539B5)

## 软件质量度量
- 质量度量贯穿于软件工程的全过程以及软件交付之后
	- 交付之前的度量主要包括程序复杂性、模块有效性和总的程序规模
	- 交付之后的度量则主要包括残存的缺陷数和系统的可维护性方面

- 评估指标的选取原则


### 软件质量定量评价

### 软件复杂性概念

## 代码质量度量
### Line复杂度

### Halstead复杂度

### McCabe复杂度

### 软件复杂性总结

