- 若采用最简单结构
    - 只有一种中间表示——抽象语法树
- 通常的现代编译器
    - 中间表示 1
    - 中间表示 2
    - 更多的翻译和中间表示
    - 最终生成汇编代码

# 中间代码的地位和作用
- ==**Q：为什么编译器要使用中间表示？**==

- **树和有向无环图（DAG）**
    - 高层表示，适用于程序源代码
- **三地址码（3-address code）**
    - 低层表示，靠近目标机器
- **控制流图（CFG Control-FLow- Graph）**
    - 更精细的三地址码，程序的图状表示
    - 适合做程序分析、程序分析等
- **静态单赋值形式（SSA）**
    - 更精细的控制流图
    - 同时编码控制流信息和数据流信息
- **连续传递风格（CPS）**
    - 函数式编程中常用 可以做到跨函数级别
    - 更一般的 SSA

# 三地址码
- 首先从抽象语法树中过来，且往往由语义分析器生成
- 在最简单的编译器结构中增加了一个三地址码中间表示

- **三地址码基本思想**
    - **给每个中间变量和计算结果命名**
        - 没有复合表达式
    - **只有最基本的控制流 即：原子操作**
        - 没有各种控制结构
        - 只有 goto，call 等
    - **所以三地址码可以看成是抽象的指令集**
        - 通用的 RISC
        - 并没有做出特定绑定

- 实例
    - ![](https://raw.githubusercontent.com/CaesarYangs/MyPictureHotel/main/BasicImg/202205241642020.png)

## 三地址码的定义
- 类似于上下文无关文法的定义方式
    - ![](https://raw.githubusercontent.com/CaesarYangs/MyPictureHotel/main/BasicImg/202205241645332.png)

## 三地址码数据结构
- 定义数据结构
    - 每个三地址码定义一个数据结构来准备表示
```cpp
  

enum instr_kind {INSTR_CONST, INSTR_MOVE};
struct Instr_t{
    enum instr_kind kind;
};

struct Instr_Add {
enum instr_kind kind;
    char *x;
    char *y;
    char *z;
};

struct Instr_Move {
    enum instr_kind kind;
    char *x;
    char *y;
};
```

## 生成三地址码
- 从 C--生成三地址码
    - ![](https://raw.githubusercontent.com/CaesarYangs/MyPictureHotel/main/BasicImg/202205241648370.png)
- 给每个非终结符写相应的递归调用函数
- **同样按照语句的类型进行递归下降算法即可**

## 给语句的代码生成

```cpp
Gen_S(S s){
    switch (e){
        case x=e:
            x1 = Gen_E(e);
            emit("x= x1");
            break;
        case printi(e);
            x1 = Gen_E(e);
            emit("printi x");
            break;
        case printb(e):
            x1 = Gen_E(e);
            emit("printb x");
            break;
    }
}
```

### If 的代码生成
- 前向生成代码

## 小结
- 三地址码优点：
    - 所有的操作都是原子的
        - 变量 没有复合结构
    - 控制流被简化了
        - 只有跳转
    - 是抽象的机器代码
        - 向后做代码生成更容易
- 三地址码的不足：
    - 程序的控制流信息是隐式的
    - 可以做进一步的控制流分析
- 从三地址码生成汇编代码更加容易

- **从三地址码生成机器指令**

# 控制流图
- *Q：为什么需要控制流图？*
    - 三地址码上的控制信息是隐式表示的
    - 给出程序的控制结构往往是有难度的

- 节点代表图的若干条语句
- 图的边代表语句之间的跳转

- 程序的控制流图表示带来很多好处
    - 控制流分析：
        - 对很多程序分析来说，程序的内部结构很重要
            - 典型的问题：“程序中是否存在循环？”
        - 可以进一步进行其他分析
            - 例如数据流分析
                - 典型的分析：“程序第 5 行的变量 x 可能的值是什么？”
- 现代编译器的早期阶段就会倾向做控制流分析
    - 方便后续阶段的分析

## 基本概念
- 基本块：是语句的一个序列,从第一条执行到 最后一条
    - 不能从中间进入
    - 不能从中间退出
        - 即跳转指令只能出现在最后
- 控制流图:控制流图是一个有向图 G = (V,  E)
    - 节点 V:是基本块
    - 边 E:是基本块之间的跳转关系

## 控制流图生成
- 可以直接从抽象语法树生成
    - 如果高层语言具有特别规整的控制流结构的话较容易
- 也可以先生成三地址码，然后继续生成控制流图
    - 对于像 C 这样的语言更合适：包含像 goto 这样的非结构化的控制流语句
    - 更加通用（阶段划分！）

- 三地址码生成控制流图算法
- 线性扫描一遍就可以将控制流图全部生成出来 O(n)
    - ![](https://raw.githubusercontent.com/CaesarYangs/MyPictureHotel/main/BasicImg/202206041531202.png)

- 控制流图的基本操作
    - 标准的图论算法都可以用在控制流图上
        - 各种遍历算法、生成树、必经节点结构等
    - 图节点的顺序有重要的应用：
        - 拓扑排序、逆拓扑、近似拓扑排序、等
    - 这里我们不打算重复算法课的内容,而是通过 研究一个具体的例子来展示基本图算法的应用：
        - 死基本块删除优化

- 死基本块删除优化
    - 死基本块：该基本块的入度为 0
    - 可以非常好的简化整个代码分析的复杂度
    - 经常会在生成中间表示的早期阶段执行，用于更好的让后续编译器阶段的性能提升

# 数据流分析
- 划分中间表示的数量和种类是要和编译器的设计密切相关的
- 数据流分析往往和程序的优化有很大的关系
- **优化一定是和程序的中间表示结合在一起的**
    - 也可以在抽象语法树和汇编代码上进行优化
    - 优化是贯穿整个程序的编译过程

## 优化的一般模式
- 程序分析
    - 控制流分析，数据流分析，依赖分析
    - 得到被优化程序的静态保守信息
        - 是对动态运行行为的相似（估计）
- 程序重写
    - 以上一步得到的信息制导对程序的重写

### 静态保守
- 实例 1
    - 到达定义分析
    - 常量传播优化
    - ![](https://raw.githubusercontent.com/CaesarYangs/MyPictureHotel/main/BasicImg/202206041548905.png)
- 实例 2
    - ![](https://raw.githubusercontent.com/CaesarYangs/MyPictureHotel/main/BasicImg/202206041550401.png)
- 让编译器的静态保守估计集合与其动态真实集合差距越来越少

- 数据流分析
    - 通过对程序代码进行静态分析，得到关于程序数据的保守信息
        - 必须要保证程序分析的结果是安全的
    - 根据优化的目标不同，需要进行的数据流分析也不同



# 代码优化基本概念
- *Q：编译优化处在的位置？*
	- 至少应该在语义分析阶段之后进行
	- 优化不局限于单一的中间表示
	- ![](https://raw.githubusercontent.com/CaesarYangs/MyPictureHotel/main/BasicImg/202206041604257.png)

- *Q：什么是代码优化？*
	- 代码优化是被优化的程序进行的一种**语义保持**的**变换或改写**
		- 语义保持：程序的可观察行为不能改变
	- 变换的目的是让程序能够比变换前：
		- 更小 更快 cache性能更好 更节能 etc.
