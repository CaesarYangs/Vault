编译器的阶段
源程序----->编译器----->目标代码

源程序 前端 IR 后端 目标代码

![](https://raw.githubusercontent.com/CaesarYangs/MyPictureHotel/main/BasicImg/202205131739313.png)

（IR 即为编译器的中间表示）

# 词法分析器的任务
^8a8c26
字符流（码）=>【词法分析器】=>记号流(token)

每一个单词被叫做一个记号
有的记号不会出现在源程序中。

==即：词法分析器的任务是**从字符流到记号流的转换**==

**字符流**
和被编译的语言密切相关：ANSII 等。

**记号流**
编译器内部定义的数据结构，对所识别出的词法单元的**编码**。

**记号 token**
> 是一个字串，是构成源代码的最小单位。从输入字符流中生成记号的过程叫作**记号化**（tokenization），在这个过程中，词法分析器还会对记号进行分类。

- 记号经常使用[正则表达式](https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F "正则表达式")进行定义，像[lex](https://zh.wikipedia.org/wiki/Lex "Lex")一类的词法分析器生成器就支持使用正则表达式。
- 语法分析器读取输入字符流、从中识别出语素、最后生成不同类型的记号。其间一旦发现无效记号，便会报错。

**记号 token 数据结构定义**
```C
enum kind (IF,LPAREN,ID,INTLIT...);
struct token{
    enum kind k;
    char *lexeme;
}
```
每一个字符的转换中，都会得到一个 token 结构体。因为所谓的记号流就是相应的 token 组成的"数据结构"

- **词法分析器 Lexical Analyzer**
    - 词法分析器一般以函数的形式存在，供[语法分析器 wiki](https://zh.wikipedia.org/wiki/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8 "语法分析器")调用。
    - 词法分析器对字符进行切分，合并关键字以及去除无意义的符号。生成相应记号流。

---
以下详细介绍：如何让每一个字符转变为记号，从而形成记号流。

# 手工构造
- *Q：在词法分析器中采用何种数据结构和算法来实现功能*
- 至少两种主流实现方案：
    - 手工编码：相对复杂，容易出错  GCC,LLVM 实现出的效率高
    - 词法分析器生成器：代码量少，可快速原形；难以控制细节。
        - 程序员仅仅需要写一些生成内容

## 转移图（状态转换图）
- 通过读第一个字符，绘制转移节点图，<u>枚举全部的路径情况</u>，返回不同的关系运算符。
- 双圆圈代表了一个词的识别结束。
- <u>词法分析器的手工实现就是利用程序员手工编码，从输入开始到输出结束，编写出完整的高效的转移图算法，实现转移图便实现了词法分析器——将字符流逐个分解，转换为了记号 token 结构体。</u>

==从左至右 逐字符转换==

```C
token nextToken(){
    c = getChar();
    switch(c1){
        case '<':c2 = getChar();
            switch(c2){
                case '=': return LE;
                case '>': return NE;
                default: rollback(); return LT;
            }
        case '=': return EQ;
        case '>': c2 = nextChar();
            switch(c2)://similar
    }
}
```

**标识符的转义符**
![](https://s3.ananas.chaoxing.com/doc/ab/45/c3/cf29fbb8ba426fae3899cc97f128f479/thumb/7.png)
- **标识符和关键字**
    - 很多语言中的标识符和关键字有交集
        - 从词法分析的角度看：**关键字是标识符的一部分**
    - 以 C 语言为例：
        - 标识符：以字幕或下划线开头，后跟 0 个或多个字母、下划线、或数字
        - 关键字 keyword：如 if,while,else ...

- **关键字表算法**
    - 对给定语言中所有的关键字，构造**关键字哈希表 H** （关键字是有限集）
    - 对所有标识符和关键字，**统一按照标识符转移图识别**。
    - 识别完毕后，查表 H 看是否是关键字
    - 整个操作通过构造完美哈希，可以实现 O(1)时间复杂度

- *Q：如何处理保留字？*
    - 1 初始化时就将各个保留字填入符号表中
    - 2 为每个关键字建立单独的状态转换图

- **基于状态转换图的词法分析器体系结构**
    - 有几种方法可以根据一组状态转换图构造出一个词法分析器。不管整体的策略是什么,每个状态总是对应于一段代码。我们可以想象有一个变量 state 保存了一个状态转换图的当前状态的编号。有一个 switch 语句根据 state 的值将我们转到对应于各个可能状态的相应代码段, 我们可以在那里找到该状态需要执行的动作。一个状态的代码本身常常也是一条 switch 语句或多路分支语句。这个语句读人并检查下一个输人字符,由此确定下一个状态。

- 将状态转换图集成到词法分析器中
    - 可以让词法分析器顺序的尝试各个词法单元的状态转换图
    - 可以“并行地”运行各个状态转换图，将下一个输入字符提供给所有的状态转换图，并使得每个状态转换图作出它应该执行的转换
        - 举例来说，该规则让我们识别出标识符 `thenext` 而不是关键字 `then`，识别出 `->` 而不是 `>`
    - 更好的方法：将所有的状态转换图合并为一个图

哈希表的作用是使查表的速度快速完成。

# 生成器构造
![](https://raw.githubusercontent.com/CaesarYangs/MyPictureHotel/main/BasicImg/202205172049521.png)

完全自动化实现。
声明式规范----->【自动生成工具】----->词法分析器

| 声明式规范 | 自动生成工具 | 词法分析器            |
| ---------- | ------------ | --------------------- |
| 正则表达式 | 算法(lex)         | 有限状态自动机（DFA） |

- 1. 此时书写整个词法分析器的工作就被转化为了书写这样一个声明式的规范——正则表达式
- 2. 如何通过规范转化成代码——数据结构与算法 自动机 表驱动算法
- *Q：词法分析器是有限状态自动机吗（DFA）？*

## RE 正则表达式——输入
==声明式规范——正则表达式==
目的在于使用这样一套表达系统，生成出一套标准化，规范化的表达式。

> 语言在产生之时已经满足了可以被规则表示的这种情况，现在只需反向将这些规则进行高层次的提炼和概括，成为声明式规范，用来表达所有一切该编程语言表达的全部内容。

- *Q：什么是正则表达式？*
正则+表达式：首先是一种表达式
字符集合+他们构成的正则表达式

**基本形式**
对给定的字符集∑ （公共，抽象）
**归纳形式定义**
- 空串是正则表达式
- 对于任意 c 属于字符集∑, c 是正则表达式
- 两个正则表达式可以构造**复合表达式**：选择 连接 闭包(Kleen)

**闭包：一个或多个**
*出现定义递归推理*
```
e -> E
    |c
    |e | e
    |e e
    |e*
```

==使用正则表达式的意义在于表达程序语言中词法的规则，从而可以用词法生成器生成。==

**关键字正则**
- *Q：C 语言关键字如何用正则表达式表达，为什么可以用正则表达式表达？*

**标识符正则**
C 语言：<u>以字母或下划线开头</u>，<u>后跟 0 个或多个字母、数字或下划线</u>。

关键：切分与利用 kleen 闭包

将标识符分成两部分：开头+后部分
开头：26 * 2+1 个 一共 53 个
后部分：26 * 2 + 1 + 10
0 个或多个：kleen 闭包符号 * 解决

**unsigned 整数正则**

**语法糖**
一种方便书写的代表

> **赋值+跳转两种运算就可以满足任意需求**

则所有的编程语言的上层实现代码都是语法糖的使用。==实际上是高级语言对最底层代码的封装。==

语法糖即对两种基本运算的封装，变成了各种高级语言，便于程序员使用。
语法糖不是必须的。是一种组合封装形式。
但应用语法糖会带来很多便利性。

`[c1-cn]==c1|c2|...cn`
`e+ 一个或多个 `
`e? 一个或零个 `
`a* 是 a *自身 不是 a 的 kleen 闭包 `

## FA 有限状态自动机——输出
词法分析器的输入是一串字符流
输出是 boolean 判断(最基本) 是否能够成为切分后记号流 （先是{yes,no} 再有后面的信息）

[[1 词法分析#转移图]]是核心——即"**有限状态**"

**有限状态自动机 FA**
输入的字符串------>FA------>{yes,no}

$$M = (\Sigma ,S,q0,F,\delta)$$

 ∑：字母表
S：状态集
q0：初始状态
F：终结状态集（不是单个状态 而是一个集合）
delta ：转移函数——跳转状态的刻画 没有遗漏 完全表示

![](https://raw.githubusercontent.com/CaesarYangs/MyPictureHotel/main/BasicImg/202205172122849.png)

- 确定的和不确定的有穷自动机能识别的语言的集合是相同的。事实上，这些语言的集合正好是能够用正则表达式描述的语言的集合。这个集合中的语言称为正则语言(regular language)

- *Q：什么样的串可被接受？*
    - 串被全部读完&&此时处于终结状态
---
- *Q：NFA 与 DFA 的最主要区别是什么？*
    - 接受状态
    - 同一条件可以同时被判断是接受态与非接受态，不确定是否能够接受
    - 实际上的接受应该是不论怎么走，最终达到接受即可

- FA 与转移图的差异
    - 同一个符号可以标记统一状态出发到达多个目标状态的多条边
    - 一条边的标号不仅可以是输入字母表中的符号，也可以是空符号串$\epsilon$

### DFA
- **确定的有限状态自动机 DFA**
    - 对任意字符，最多有**一个状态**可以转移。

> 是一个能实现状态转移的[自动机](https://zh.wikipedia.org/wiki/%E8%87%AA%E5%8A%A8%E6%9C%BA "自动机")。对于一个给定的属于该自动机的状态和一个属于该自动机字母表的字符，它都能根据事先给定的转移函数转移到下一个状态（这个状态可以是先前那个状态）。

*笛卡尔积*：即所有可能的有序对的集合。
$$S \times \Sigma => S$$
- **DFA 实现**
    - 模式化实现。

### NFA
- **非确定的有限状态自动机 NFA**
    - 对任意字符，有大于一个状态可以转移。

> 是对每个状态和输入符号对可以有多个可能的下一个状态的[有限状态自动机](https://zh.wikipedia.org/wiki/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E8%87%AA%E5%8A%A8%E6%9C%BA "有限状态自动机")。这区别于[确定有限状态自动机](https://zh.wikipedia.org/wiki/%E7%A1%AE%E5%AE%9A%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E8%87%AA%E5%8A%A8%E6%9C%BA "确定有限状态自动机")（DFA），它的下一个可能状态是唯一确定的。尽管DFA和NFA有不同的定义，在形式理论中可以证明它们是等价的；就是说，对于任何给定NFA，都可以构造一个等价的DFA，反之亦然：通过使用[幂集构造](https://zh.wikipedia.org/wiki/%E5%B9%82%E9%9B%86%E6%9E%84%E9%80%A0 "幂集构造")。

*幂集 D*
$$\delta : S \times (\Sigma \cup \varepsilon ) \rightarrow D(S)$$

- **NFA 实现**
    - 将空 e 消除

---

## RE to DFA——转换算法
正则表达式到有限状态自动机

![](https://raw.githubusercontent.com/CaesarYangs/MyPictureHotel/main/BasicImg/202205172146621.png)

### RE to NFA：Thompson 算法
***——递归嵌套***
- 基于对 RE 的结构做归纳
    - 对基本的 RE 直接构造
    - 对复合的 RE 递归构造
- 递归算法，容易实现
    - 在我们的实现中，不到 100 行 C 代码
- **Thompson 算法是基于对正则表达式的结构做归纳来实现的**
    - 类似于数学归纳法 是一种归纳的架构

==重要：物种基本情况的使用 组合 嵌套==

**第一种情况**：构造简单关系

简单关系分类：

| M   | RE            |
| --- | ------------- |
|     | e->$\epsilon$ |
|     | e->C          |
|     | e->e1 e2      |
|     | e->e1/e2      |
|     | w->e*         |

**第二种情况：** 构造复杂情况
类似：选择（并列）关系。

- 原则：不能改变原有的主要结构和构造。
- $\varepsilon$的引入是很有意义的——$\varepsilon$作为桥梁

- **本质：什么是集合**
    - 集合的使用和定义

### NFA to DFA：子集构造算法
***——推进边界 消除空集***
- *Q：为什么要做这种转换？*
    - **减小处理机计算的流程和复杂度，加快计算速度。**
    - **因为 NFA 的路径不确定，在真正的生成过程中会遇到回溯情况，效率降低**
    - 转换思想——最小子集算法

- NFA 与 DFA 等价
    - 将$\epsilon$消掉，同时又不改变每个字符的转换情况。整个的转换过程要在 DFA 上体现出来。
    - 目的是识别[[1 词法分析#词法分析器的任务|字符流]]中的字符（a，b，c etc）

- <u>每一个 n 节点，经过任何一个输入后，其生成的答案可以扩展为一个集合</u>
- 扩展成的每一个集合都是一个弧形 Boundary 每一个集合内的状态都以$\epsilon$连接，外部$\epsilon$遂

主干
$\epsilon$边界

n0----a---->n1: q1{n1, n2, n3, n4, n6, n9}
q1----b---->n5: q2{ n5,n8,n9,n3,n4,n6 }

终结状态：只要能到达最终状态的都可以为终结状态。

- **不动点算法。**
    - 算法能够被终止。
    - 单调递增且有上界
- 时间复杂度：
    - 最坏情况 O(2^N)。
    - 但在实际中不会经常发生，因为不是每个子集都会出现。

- **epsilon 闭包的计算：深度优先**
    - 基于深度优先遍历的算法
    - 不断探索的结果就构成了 epsilon 闭包
    - 也是和我们手工考虑很相似的，在一条道路上前进下去，不重不漏
```cpp
set closure = {}

void eps_closure(x){
    closure += {x} //并 任何一个节点的闭包首先包含其自身
    foreach(y:x--e-->y){  //对每一个从epsilon有向边转换的点
        if(!visited(y)){
            eps_closure(y)  //递归 深入
        }
    }
}
```

- **epsilon 闭包的计算：广度优先**
```cpp
set closure = {}
Q = []
void eps_closure(x){
    Q = [x];
    while (Q not empty){
        q <- deQueue(Q)
        closure += q
        foreach(y:q--e-->y){
            if(!visited(y)){
                enQueue(Q,y)
            }
        }
    }

}
```

- **子集构造算法：工作表算法**
    - worklist 工作表：每次将可以生成达到的状态加入进去。是整个算法驱动的判断标志。若工作表为空，则停止循环。
    - Q：保存所有经过状态的集合
    - D：即 DFA——生成的有向图
    - delta()：最重要的函数。负责寻找每个状态经过一个字符 c 输入可以达到的状态。并且为其计算$\epsilon$闭包。***——Push the boundary***
```c
    q0 <- eps_closure (n0)  //将初始点设置为q0
    Q <- {q0}  //即：一开始就存在的一种集合情况
    workList <- q0;  //赋值给工作集
    while(workList!=[]){
        remove q from workList;
        for(each character c){
            //对每个符合规则的字符转换 看对哪个字符有作用
            t <- eps_closure(delta(q,c)); //t是一个集合
            D[q,c] <- t;  //生成新的状态转移函数
            if(t\not\in Q){
                add t to Q and workList;  //在Q上增加一个节点 同时进入workList
                
            }
        }
    }

```
- 不断查看输入，状态和$\epsilon$闭包的情况，推进边界，消除空集。

### DFA 最小化：Hopcroft 算法
***——等价类代换***
- 相当于最小化代码量。能够大幅降低之后代码运算过程中会产生的大量时间负担。
    - 输入：DFA
    - 输出：DFA
    - 即对于当前 DFA 的优化策略。

- Q：*为什么能进一步化简？*
    - <u>识别的效果是完全等同的。</u>
    - 中间的效果是基本一致的，也就是目的一致，可以合并。

**Hopcroft 算法**
==基于等价类思想的算法==

- 等价类：**在寻找评判效果等同的状态的集合。**
主要实现方法：切分 split
split 实现方法：**集合切分**。根据不同的属性划分节点为几个主要的集合。
```c
split(s){ //拆分DFA上的状态集合
    foreach(character c){  //所有字母的集合 C语言一次就需要判断256次
        if(c can split S){  
            split S into T1,T2...,TK  //如果能切分 则切分到最细个数
        }
    }
}

hopcroft(){
    split all nodes into N,A  //把所有节点分为两个集合 N-非接受 A-接受状态
    while(set is still changes){
        split(S)
    }
}
```

1.  **划分出 N 与 A 两种状态 即非接受与接受状态**
2.  **按照不同的集合区分状态集：依旧保持在 N 内；可以转换为 A；属于 A 内**

- 关键是 `split(s){ //拆分 DFA 上的状态集合 ` 这个函数的使用：
    - 检查单个字符 c 是否能够分开集合上的状态，即这个字符 c 能否让状态转移的结果产生分支。如果能产生，则分解；若始终在同一个区域内，则将这个区域划分为一个大区域。（区分性 是否能收缩）
    - 看节点接受转换的字符，以及转换出去的方向和字符。

**对算法的讨论**
- 不动点算法：*算法为什么能运行终止？*
- 时间复杂度：最坏情况 O(2N)

## DFA to Code
——词法分析器代码生成
根据 DFA 生成词法分析代码

- **DFA 的代码表示**
    - 概念上讲，DFA 是一个带有边和节点的有向图
    - 点：不同的状态；边：转移函数
    - 有不同的 DFA 代码表示：转移表（类似邻接矩阵），哈希表，跳转表
    - 取决于实际表现中，对时间空间的权衡

### 数据结构
***——如何表示一张 DFA 图***
#### 转移表
即：存储 DFA 的一种方式。类似于图中的[[8 图#邻接矩阵|邻接矩阵]]。
![](https://raw.githubusercontent.com/CaesarYangs/MyPictureHotel/main/BasicImg/202205181600711.png)

| 状态\字符 | a   | b   | c   |
| --------- | --- | --- | --- |
| 0         | 1   |     |     |
| 1         |     | 1   | 1   |

**含义：在 0 号状态遇到 a 字符会转换到哪个状态**
也就是表示了状态转移函数的每种情况。
```cpp
char table[M][N]

table[0]['a'] = 1;
table[1]['b'] = 1;
table[1]['c'] = 1;
//other table entries are ERROR
```
- 在状态 `0` 时，输入字符 `a` ，行列交叉点是 `1` ，表示可以转向状态 `1`
- 在状态 `1` 时，输入字符 `a` ，行列交叉点是 `2` ，表示可以转向状态 `2`
- 在状态 `1` 时，输入字符 `b` ，行列交叉点是 `1` ，表示可以转向状态 `1`

有了以上所有的逻辑，就可以判断一个字符串是否符合一个 RE 的规定，即可将字符串拆分为一个一个的 token 。这个方法叫做“转移表法”

- *如何从**转移表**生成**词法分析驱动代码**？*——二者解耦实现自动化
- ==将转移表和词法分析代码解耦。目的是为了面对各种不同的语言和编码的情况下自动生成。==

#### 跳转表
- 跳转表就是指定每一块执行的位置，进 goto 直接执行相应内容，将每一块分开。
- 本质上并不需要所谓表的内存结构占用，只需要在设计每一段代码的过程中明确跳转 goto 位置即可
    - 这也就是为什么跳转表得意广泛应用的原因——占用空间小

### 驱动代码
***——利用上述数据结构 读入程序代码 进行词法分析***
利用上文👆🏻的转移表驱动整个程序前进还是停止。
```cpp
nextToken(){
    state = 0;
    stack = [];
    while(state != ERROR){
        c = getChar();
        if(state is ACCEPT){
            clear(stack);
        }
        push(state);  //动作未完成时将状态压入栈
        state = table[state][c];  //更新状态
    }

    //以下部分很像深度优先搜索的情况 在不断以一条深路径探索是否能到达终结状态
    while(state is not ACCEPT){
        state = pop();
        rollback();    
    }

}
```
- **很像是 DFS 的思想**：<u>以遇到终结状态为一个中间节点；以输入字符的内容为逐个判断器，如果遇到成功的一条路径识别则结束；如果遇到识别到不可接受状态则退回到第一个识别到的接受状态。</u>

- **最长匹配**
    - 一次调用 `nextToken()` 会识别一套能够识别的最长匹配字符。后续字符需要进行再次调用分析。

- <u>而这些识别出的字符就构成了一个个的 token，就意味着我们利用自动生成的 DFA，转移为一套词法分析器的代码结构，然后利用它完成了一趟词法分析的任务，并成功生成 token 记号流，传递给了下一个步骤的机构。</u>

# 小结
- 手工生成
    - 词法分析的本质
    - 生成了一种用 `switch-case` 结构表示的转移图
- 自动生成：
    - 本质是生成了一张表，或一种表示源程序的方式，形式上就是 DFA。词法分析驱动程序通过这样的数据结构，通过这个数据结构进行词法分析。
    - 自动生成的本质是自动生成一张转移图，且是已经完全利用某种数据结构编码好的转移图。
    - 是一种用数据结构存储的转移图。

# Q&A

- 词法分析的主要任务是什么？你怎么理解字符流和记号流？能否举例说明？

词法分析的主要任务就是将源程序在前端阶段从字符流到记号流的转换。从左到右逐个字符对源程序进行扫描，产生单词序列，用于后续的语法分析。

字符流：与被编译的语言密切相关。类似于我们写的各种高级语言程序的代码 cpp,java,etc.片段。这些由程序员书写出来的在编译执行前是一段段的字符流。
记号流：是编译器内部定义的一种数据结构，其具体的内容是经过识别出的词法单元。类似于我们刚刚学过的定义的 token 结构体识别出的流。
已练习，没有疑问。

（2）请大家在观看视频过程中，关注视频中例题的讲解，并重新对例题进行练习。注意：对于练习题（2），同学们自行练习后再回复区表述“已练习完毕，没有疑问”或者“已进行练习，困难如下：。。。。”。无需上传具体的练习过程。
