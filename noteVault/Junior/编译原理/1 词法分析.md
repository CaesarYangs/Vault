
编译器的阶段
源程序====>编译器   目标代码

源程序 前端 IR 后端 目标代码


# 词法分析器的任务

^8a8c26

字符流（码）=>【词法分析器】=>记号流

每一个单词被叫做一个记号
有的记号不会出现在源程序中。

==即：词法分析器的任务是**从字符流到记号流的转换**==

**字符流**
和被编译的语言密切相关：ANSII等。

**记号流**
编译器内部定义的数据结构，对所识别出的词法单元的编码。

**记号token 数据结构定义**
```C
enum kind (IF,LPAREN,ID,INTLIT...);
struct token{
	enum kind k;
	char *lexeme;
}
```
每一个字符的转换中，都会得到一个token结构体。

词法分析器对字符进行切分，合并关键字以及去除无意义的符号。生成相应记号流。

以下详细介绍：如何让每一个字符转变为记号，从而形成记号流。

# 手工构造
*在词法分析器中采用何种数据结构和算法来实现功能*
至少两种主流实现方案：
- 手工编码：相对复杂，容易出错  GCC LLVM 实现出的效率高
- 词法分析器生成器：代码量少，快速原形；难以控制细节。

## 转移图
通过读第一个字符，绘制转移节点图，枚举全部的路径情况，返回不同的关系运算符。
双圆圈代表了一个词的识别结束。

==从左至右 逐字符转换==

```C
token nextToken(){
	c = getChar();
	switch(c1){
		case '<':c2 = getChar();
			switch(c2){
				case '=': return LE;
				case '>': return NE;
				default: rollback(); return LT;
			}
		case '=': return EQ;
		case '>': c2 = nextChar();
			switch(c2)://similar
	}
}
```


**标识符的转义符**
![](https://s3.ananas.chaoxing.com/doc/ab/45/c3/cf29fbb8ba426fae3899cc97f128f479/thumb/7.png)
**标识符和关键字**
- 很多语言中标识符和关键字有交集
- **关键字是标识符的一部分**

## 关键字表算法
- 对给定语言中所有的关键字，构造**关键字哈希表H**
- 对所有标识符和关键字，**统一按照标识符转移图识别**。
- 识别完毕后，查表H看是否是关键字

哈希表的作用是使查表的速度快速完成。

# 生成器
完全自动化实现。
声明式规范===>【自动生成工具】===>词法分析器


## 正则表达式——输入
==声明式规范——正则表达式==
目的在于使用这样一套表达系统，生成出一套标准化，规范化的表达式。

> 语言在产生之时已经满足了可以被规则表示的这种情况，现在只需反向将这些规则进行高层次的提炼和概括，成为声名式规范，用来表达所有一切该编程语言表达的全部内容。

*什么是正则表达式？*
正则+表达式：首先是一种表达式
字符集合+他们构成的正则表达式

**基本形式**
对给定的字符集∑ （公共，抽象）
**归纳形式定义**
- 空串是正则表达式
- 对于任意c属于字符集∑, c是正则表达式
- 两个正则表达式可以构造**复合表达式**：选择 连接 闭包(Kleen)
**闭包：一个或多个**
*出现定义递归推理*
```
e -> E
	|c
	|e | e
	|e e
	|e*
```

==使用正则表达式的意义在于表达程序语言中词法的规则，从而可以用词法生成器生成。==

**关键字正则**
*C语言关键字如何用正则表达式表达，为什么可以用正则表达式表达？*


**标识符正则**
C语言：<u>以字母或下划线开头</u>，<u>后跟0个或多个字母、数字或下划线</u>。

关键：切分与利用kleen闭包

将标识符分成两部分：开头+后部分
开头：26 * 2+1个 一共53个
后部分：26 * 2 + 1 + 10
0个或多个：kleen闭包符号 * 解决

**unsigned整数正则**


**语法糖**
一种方便书写的代表

> **赋值+跳转两种运算就可以满足任意需求**

则所有的编程语言的上层实现代码都是语法糖的使用。==实际上是高级语言对最底层代码的封装。==

语法糖即对两种基本运算的封装，变成了各种高级语言，便于程序员使用。
语法糖不是必须的。是一种组合封装形式。
但应用语法糖会带来很多便利性。

`[c1-cn]==c1|c2|...cn`
`e+ 一个或多个`
`e? 一个或零个`
`a* 是 a*自身 不是a的kleen闭包`

## 有限状态自动机——输出
词法分析器的输入是一串字符流
输出是boolean判断(最基本) 是否能够成为切分后记号流 （先是{yes,no} 再有后面的信息）

[[1 词法分析#转移图]]是核心——即"**有限状态**"

**有限状态自动机FA**
输入的字符串------>FA------>{yes,no}

$$ M = (\Sigma ,S,q0,F,\delta)$$

 ∑：字母表
S：状态集
q0：初始状态
F：终结状态集
delta ：转移函数——跳转状态的刻画 没有遗漏 完全表示

*什么样的串可被接受？*


![](https://s3.ananas.chaoxing.com/doc/b6/7f/eb/5a2abdd042827677ce6d7ece29444221/thumb/5.png)
**确定的有限状态自动机 DFA**
对任意字符，最多有**一个状态**可以转移。
$$S \times \Sigma => S$$
*笛卡尔积*：即所有可能的有序对的集合。

**非确定的有限状态自动机 NFA**
对任意字符，有大于一个状态可以转移。
*幂集*


### DFA实现
模式化实现。

| 状态\字符 | a   | b   |
| --------- | --- | --- |
| 0         | 1   | 0   |
| 1         | 2   | 1   |
| 2         | 2   | 2   |


### NFA实现
*将空 e消除*


## RE to DFA
正则表达式到有限状态自动机

RE=>NFA=>DFA=>词法分析器算法

### RE to NFA：Thompson算法
基于对RE的结构做归纳
- 对基本的RE直接构造
- 对复合的RE递归构造

==重要：物种基本情况的使用 组合 嵌套==

**第一种情况**：构造简单的


**第二种情况：** 构造复杂情况
类似：选择（并列）关系。

原则：不能改变原有的主要结构和构造。

$\epsilon$的引入是很有意义的——$\epsilon$作为桥梁


| M   | RE            |
| --- | ------------- |
|     | e->$\epsilon$ |
|     | e->C          |
|     | e->e1 e2      |
|     | e->e1/e2      |
|     | w->e*         |

**本质：什么是集合** 集合的使用和定义


### NFA to DFA：子集构造算法
*为什么要做这种转换？*
减小处理机计算的流程和复杂度，加快计算速度。
转换思想——最小子集算法

NFA与DFA等价

将$\epsilon$消掉

目的是识别[[1 词法分析#词法分析器的任务|字符流]]中的字符（a，b，c etc）
<u>每一个n节点，经过任何一个输入后，其生成的答案可以扩展为一个集合</u>

扩展成的每一个集合都是一个弧形Boundary 每一个集合内的状态都以$\epsilon$连接，外部$\epsilon$遂





# Q&A

- 词法分析的主要任务是什么？你怎么理解字符流和记号流？能否举例说明？ 

词法分析的主要任务就是将源程序在前端阶段从字符流到记号流的转换。从左到右逐个字符对源程序进行扫描，产生单词序列，用于后续的语法分析。

字符流：与被编译的语言密切相关。类似于我们写的各种高级语言程序的代码cpp,java,etc.片段。这些由程序员书写出来的在编译执行前是一段段的字符流。
记号流：是编译器内部定义的一种数据结构，其具体的内容是经过识别出的词法单元。类似于我们刚刚学过的定义的token结构体识别出的流。
已练习，没有疑问。





（2）请大家在观看视频过程中，关注视频中例题的讲解，并重新对例题进行练习。注意：对于练习题（2），同学们自行练习后再回复区表述“已练习完毕，没有疑问”或者“已进行练习，困难如下：。。。。”。无需上传具体的练习过程。