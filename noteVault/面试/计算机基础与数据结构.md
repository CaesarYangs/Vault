

## 数据库
- mysql 有那些存储引擎，有哪些区别
	InnoDB、MyISAM、Memory、Merge、Archive、CSV、BLACKHOLE
	InnoDB-具备外键支持功能的事务处理引擎

	1. InnoDB 支持事务，MyISAM 不支持事务。这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；

	2. InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败；

	1. InnoDB 是聚集索引，MyISAM 是非聚集索引。

- mysql索引模型
	B+Tree的磁盘读写代价更低：由于非叶子节点只存放索引不存放数据，所以每个节点可以存放更多的索引，一次读取查找的关键字更多，树的高度更低
	B+Tree的查询效率更加稳定，因为只有叶子节点存在数据，所以每次查询的路径长度都是相同的
	B+Tree更适合范围查询，因为B-Tree的非叶子节点存放数据，所以需要使用中序遍历来查询，而B+Tree只有叶子节点有数据，叶子节点之间使用链表连接，所以只要顺序扫描进行，更加方便

-mysql 主从同步
	Mysql内建的复制功能是构建大型高性能应用程序的基础, 将Mysql数据分布到多个系统上，这种分布机制是通过将Mysql某一台主机数据复制到其它主机（slaves）上，并重新执行一遍来实现的。复制过程中一个服务器充当主服务器，而一个或多个其它服务器充当从服务器。主服务器将更新写入二进制日志文件，并维护文件的一个索引以跟踪日志循环。这些日志可以记录发送到从服务器的更新。当一个从服务器连接主服务器时，它通知主服务器从服务器在日志中读取的最后一次成功更新的位置。从服务器接收从那时起发生的任何更新，然后封锁并等待主服务器通知新的更新。
	
- redis
	-   Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。
	-   Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。
	-   Redis支持数据的备份，即master-slave模式的数据备份。


- -   纯内存操作
-   核心是基于非阻塞的 IO 多路复用机制
-   单线程反而避免了多线程的频繁上下文切换问题

	**(一) String**  
	这个其实没啥好说的，最常规的set/get操作，value可以是String也可以是数字。一般做一些复杂的计数功能的缓存。

	**(二) hash**  
	这里value存放的是结构化的对象，比较方便的就是操作其中的某个字段。博主在做单点登录的时候，就是用这种数据结构存储用户信息，以cookieId作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。

	**(三) list**  
	使用List的数据结构，可以做简单的消息队列的功能。另外还有一个就是，可以利用lrange命令，做基于redis的分页功能，性能极佳，用户体验好。本人还用一个场景，很合适—取行情信息。就也是个生产者和消费者的场景。LIST可以很好的完成排队，先进先出的原则。

	**(四) set**  
	因为set堆放的是一堆不重复值的集合。所以可以做全局去重的功能。为什么不用JVM自带的Set进行去重？因为我们的系统一般都是集群部署，使用JVM自带的Set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。

	另外，就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。

	**(五) sorted set**  
	sorted set多了一个权重参数score,集合中的元素能够按score进行排列。可以做排行榜应用，取TOP N操作。
	
	redis采用的是定期删除+惰性删除策略
	
	
- MongoDB
	**MongoDB的先天缺陷**
	-   不支持事务（4.0之前的版本不支持事务，4.0开始支持在副本集上的事务，官方宣称会在4.2版本，支持在分片集上实现事务）
	-   写入性能差，2.4开始的版本，默认是安全写入，确保不丢失数据，之前版本写入处理方式同redis（当然自从有了SSD，大家懂的）
	-   磁盘、内存消耗较大
	-   部署副本集，至少需要三个节点，其必须有个裁判节点
	-   使用分片时，单个分片必须有副本集，否则一旦分片损坏，会引起数据丢失
	-   国内生态不佳，熟悉者较少，大牛更少

## 语言特性
- Python装饰器
	- 是修改其他函数的功能的函数。
	- 基于装饰器授权 日志等

- GO 协程

## 后端框架
- Django路由
	解析请求的url,匹配找到对应的view函数来处理。
	
	URLPattern
	当是一个正常的可调用的view函数的时候，就会当成URLPattern处理；但是如果是一个list或者tuple，则会当成URLResolver继续处理。那么继续看下URLPattern和URLResolver
	
- Django部署
	nginx uWSGI
	uWSGI一方面通过WSGI与Python代码进行通信，另一方面通过socket（套接字）与Nginx通信
	
	WSGI 的全称是_Web Server Gateway Interface_ ,翻译过来就是Web服务器网关接口。具体来说，

	**WSGI是一个规范，定义了Web服务器如何与Python程序进行交互，使得使用Python写的Web应用程序可以和Web服务器对接起来。**

	WSGI 相当于是Web服务器和Python应用程序之间的桥梁。其存在的目的有两个
	


## 数据结构
- 哈希表
- 哈希表扩容

## 计网
- GET和POST
	- **请求参数**：GET请求参数是通过URL传递的，多个参数以&连接，POST请求放在request body中。  
	**请求缓存**：GET请求会被缓存，而POST请求不会，除非手动设置。  
	**收藏为书签**：GET请求支持，POST请求不支持。  
	**安全性**：POST比GET安全，GET请求在浏览器回退时是无害的，而POST会再次请求。  
	**历史记录**：GET请求参数会被完整保留在浏览历史记录里，而POST中的参数不会被保留。  
	**编码方式**：GET请求只能进行url编码，而POST支持多种编码方式。  
	**对参数的数据类型**：GET只接受ASCII字符，而POST没有限制。
	

- Https的安全性
	**二、Http与Https的区别**

	1、https协议需要到CA申请证书，一般免费证书较少，因而需要一定费用。(网易官网是http，而网易邮箱是https。)

	2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。

	3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。（找工作时这个答案一定要说）

	4、http的连接很简单，是无状态的。Https协议是由SSL+Http协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。(无状态的意思是其数据包的发送、传输和接受都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)
- OSI参考模型

## 操作系统
- 进程和线程
	区别
	1.  **一个线程只能属于一个进程，而一个进程可以有多个线程**，但至少有一个线程。线程依赖于进程而存在。
	2.  **进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存**。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。）
	3.  **进程是资源分配的最小单位，线程是CPU调度的最小单位**；
	4.  系统开销： 由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／o设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，**进程切换的开销也远大于线程切换的开销**。
	5.  通信：由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。**进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性**。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预
	6.  **进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂**。
	7.  **进程间不会相互影响 ；线程一个线程挂掉将导致整个进程挂掉**

- 进程的三种状态：就绪状态 执行状态 阻塞状态

- 调度算法：
-   先来先服务调度算法
-   最短作业优先调度算法
-   高响应比优先调度算法
-   时间片轮转调度算法
-   最高优先级调度算法
-   多级反馈队列调度算法

- 并发控制
- 进程切换，或叫任务切换、上下文切换。
- 时间片
- 多道程序系统


- 为什么要并发控制
	丢失更新
	脏读
	
- 进程上下文切换
- **进程是由内核来管理和调度的，进程的切换只能发生在内核态**
- 就是先把前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。
- 




- 进程间通信的方式：管道 IPC（消息队列）
