      

[**计算机网络** **(****第****5****版** **扫描版****)**](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67)

  

[页 22:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=35)

为了降低网络设计的复杂性，绝大多数网络都组织成一个层次栈(a stack of layer)或

  

[页 23:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=36)

分级栈(a stack of level)，每一层都建立在其下一层的基础之上

  

[页 23:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=36)

在每一对相邻层次之间的是接口(interface)

  

[页 24:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=37)

除了尽可能地减少层与层之间必须要传递的信 息量外，层与层之间清晰的接口使得同层协议的替换更加容易，即某一层的当前协议或实 现替换成另一个完全不同的协议或者实现

  

[页 24:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=37)

层和协议的集合称为网络体系结构(network architecture)

  

[页 27:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=40)

面向连接的服务(connection-oriented service)是按照电话系统建模的

  

[页 27:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=40)

与面向连接服务相对应的是无连接服务(conncetionless service)，这是按照邮政系统建 模的。每个报文(信件)都携带了完整的目标地址，每个报文都由系统中的中间节点路由

  

[页 28:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=41)

而且路由独立于后续报文。报文(message)在不同的上下文中有不同的称呼;数据包/包 packet)是网络层的报文

  

[页 28:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=41)

不可靠(意味着没有被确认)的无连接服务通常称为数据报服务(datagram service)，它与 电报服务非常类似，一般不会给发送方反馈任何确认消息。尽管它是不可靠的，但在大多 数网络中这是一种占主导地位的传输形式，至于个中的原因我们马上就会明白

  

[页 28:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=41)

有确认的数据报服务(acknowledged datagram service)就是为这些应用 提供的一类服务。这就像在寄挂号信时要求一个回执一样。当发送方收到回执时可绝对相 信这封信已经被送到对方手中，肯定没有在投递的途中丢失。手机上的文本消息就是一个 实例

  

[页 29:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=42)

还有另外一种服务是请求-应答服务(request-reply service)。在这种服务中，发送方传 输一个包含了某个请求的数据报;接受方以一个包含了请求结果的应答数据报作为反馈 请求-应答服务通常用在客户机-服务器模型中:客户机发出一个请求，然后服务器对此做 出响应。例如

  

[页 29:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=42)

使用不可靠连接的概念刚开始可能会令人感到疑惑不解。毕竟，为什么会有人愿意舍 弃可靠通信而选择不可靠的通信呢

  

[页 29:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=42)

首先，在给定的层次并不是总能使用可靠通信(可靠 通信的含义是指有确认)。例如，以太网并没有提供可靠通信。有些数据包可能偶尔会在传 输过程中被损坏，上层协议必须处理这个问题。尤其是，许多可靠服务是建立在不可靠数 据报服务之上的。其次，为了提供可靠服务而引入的固有延迟可能令人不可接受，特别在 诸如多媒体的实时应用中，更是无法忍受额外的延迟。由于这些原因，可靠通信和不可靠 通信将并存在任何一个网络中

  

[页 31:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=44)

服务和协议是两个截然不同的概念，它们之间的区别非常重要，我们有必要在这里再 次强调。服务是指某一层向它上一层提供的一组原语(操作)。服务定义了该层准备代表其 用户执行哪些操作，但是它并不涉及如何实现这些操作。服务与两层之间的接口有关，低 层是服务提供者，而上层是服务用户

  

[页 31:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=44)

与此不同的是，协议是一组规则，规定了同一层上对等实体之间所交换的数据包或者 报文的格式和含义。对等实体利用协议来实现它们的服务定义，它们可以自由地改变协议 只要不改变呈现给它们用户的服务即可

  

[页 31:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=44)

按照这种方式，服务和协议是完全相分离的，这 是任何一个网络设计者应该很好理解的关键概念

  

[页 32:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=45)

虽然与 OSI 模型相关的协议没 有被任何人所用，但实际上，该模型本身具有相当普遍意义，并仍然有效;它对讨论网络 体系结构中每一层的功能还是很重要。TCP/IP 协议模型则具有相反的特性:模型本身没有 多大用处，但它的协议却已经广为流传

  

[页 33:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=46)

物理层 物理层(physical layer)关注在一条通信信道上传输原始比特

  

[页 33:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=46)

设计问题必须确保当一 方发送了比特 1 时，另一方收到的也是比特 1，而不是比特 0。这

  

[页 33:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=46)

数据链路层 数据链路层(data link layer)的主要任务是将一个原始的传输设施转变成一条没有漏 检传输错误的线路

  

[页 33:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=46)

数据链路层完成这项任务的做法是将真实的错误掩盖起来，使得网络 层看不到。为此，发送方将输入的数据拆分成数据帧(data frame)，然后顺序发送这些数 据帧。一个数据帧通常为几百个或者几千个字节长。如果服务是可靠的，则接收方必须确 认正确收到的每一帧，即给发送方发回一个确认帧(acknowledgement frame)

  

[页 33:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=46)

数据链路层(和大多数高层都存在)的另一个问题是如何避免一个快速发送方用数据 淹没”一个慢速接收方。所以，往往需要一种流量调节机制，以便让发送方知道接收方何 时可以接收更多的数据

  

[页 33:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=46)

广播式网络的数据链路层还有另一个问题:如何控制对共享信道的访问。数据链路层 的一个特殊子层，即介质访问控制子层，就是专门处理这个问题的

  

[页 33:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=46)

网络层 网络层(network layer)的主要功能是控制子网的运行

  

[页 33:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=46)

一个关键的设计问题是如何将 数据包从源端路由到接收方

  

[页 34:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=47)

如果有太多的数据包同时出现在一个子网中，那么这些数据包彼此之间会相互阻碍 从而形成传输瓶颈。处理拥塞也是网络层的责任，一般要和高层协议结合起来综合处理拥 塞才有效，高层协议必须适应它们注入网络中的负载。更普遍的是网络所提供的服务质量 延迟、传输时间、抖动等)也是网络层的问题

  

[页 34:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=47)

在广播式网络中，路由问题比较简单，所以网络层往往比较单薄，甚至根本不存在

  

[页 34:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=47)

传输层 传输层(transport layer)的基本功能是接收来自上一层的数据，在必要的时候把这些 数据分割成较小的单元，然后把这些数据单元传递给网络层，并且确保这些数据单元正确 地到达另一端。而

  

[页 34:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=47)

而且，所有这些工作都必须高效率同时以一种上下隔离的方式完成，即随 着时间的推移导致底层硬件技术不可避免地发生改变时，对上面各层是透明的

  

[页 34:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=47)

传输层是真正的端-端的层，它自始自终将数据从源端携带到接收方。换句话说，源机 器上的一个程序利用报文头和控制信息与目标机器上的一个类似程序进行会话

  

[页 34:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=47)

会话层 会话层(session layer)允许不同机器上的用户建立会话

  

[页 34:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=47)

会话通常提供各种服务，包 括对话控制(dialog control)(记录该由谁来传递数据)、令牌管理(token management)(禁 止双方同时执行同一个关键操作)，以及同步功能(synchronization)(在一个长传输过程中 设置一些断点，以便在系统崩溃之后还能恢复到崩溃前的状态继续运行)

  

[页 34:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=47)

表示层 表示层以下的各层最关注的是如何传递数据位，而表示层(presentation layer)关注的 是所传递信息的语法和语义

  

[页 35:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=48)

应用层 应用层(application layer)包含了用户通常需要的各种各样的协议

  

[页 35:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=48)

用的应用协议是超文本传输协议(HTTP，HyperText Transfer Protocol)，它是万维网(WWW World Wide Web)的基础。当浏览器需要一个 Web 页面时，它通过 HTTP 将所要页面的名 字发送给服务器，然后服务器将页面发回给浏览器。其他一些应用协议可用于文件传输 电子邮件以及网络新闻等

  

[页 35:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=48)

链路层 所有这些要求导致本参考模型选择了数据包交换网络，它以一个可运行在不同网络之 上的无连接网络层为基础。模型中的最低层是链路层(link layer)，该层描述了链路必须完 成什么功能才能满足无连接的互联网络层的需求，比如串行线和经典以太网链路。这不是 真正意义上的一个层，而是主机与传输线路之间的一个接口。TCP/IP 模型的早期文档很少 提到这点

  

[页 35:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=48)

互联网层 互联网层(internet layer)是将整个网络体系结构贯穿在一起的关键层

  

[页 36:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=49)

该层的任务是允许主机将数据包注入到任何网络，并且让 这些数据包独立地到达接收方(接收方可能在不同的网络上)。甚至数据包的到达顺序与它 们被发送的顺序不同，在这种情况下，如果需要按序递交数据，那么重新排列这些数据包 的任务由高层来负责完成

  

[页 36:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=49)

互联网层定义了官方的数据包格式和协议，该协议称为因特网协议(IP Internet Protocol)，与之相伴的还有一个辅助协议，称为因特网控制报文协议(ICMP，Internet Control Message Protocol)。互联网层的任务是将 IP 分组投递到它们该去的地方

  

[页 36:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=49)

在TCP/IP模型中位于互联网层之上的那一层现在通常称为传输层(transport layer) 传输层

  

[页 36:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=49)

它的设计目标是允许源主机和目标主机上的对等实体进行对话，犹如 OSI 的传输层一样 这里定义了两个端-端的传输协议。第一个是传输控制协议(TCP，Transport Control Protocol)，它是一个可靠的、面向连接的协议，允许从一台机器发出的字节流正确无误地 交付到互联网上的另一台机器。它把输入的字节流分割成离散的报文，并把每个报文传递 给互联网层。在目标机器，接收 TCP 进程把收到的报文重新装配到输出流中。TCP 还负责 处理流量控制，以便确保一个快速的发送方不会因发送太多的报文而淹没掉一个处理能力 跟不上的慢速接收方

  

[页 36:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=49)

传输层的第二个协议是用户数据报协议(UDP，User Datagram Protocol)，它是一个不 可靠的、无连接协议，适用于那些不想要 TCP 的有序性或流量控制功能，而宁可自己提供 这些功能的应用程序

  

[页 37:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=50)

应用层 TCP/IP 模型并没有会话层和表示层，因为当时感觉并不需要这两层。相反，应用层简 单包含了所需的任何会话和表示功能。来自 OSI 模型的经验已经证明这种观点是正确的 对于大多数应用来说这两层并没有多大用处

  

[页 37:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=50)

如前所述，OSI 参考模型的实力在于模型本身(去掉表示层和会话层)，它已被证明对 于讨论计算机网络特别有益;相反，TCP/IP 参考模型的实力 体现在协议，这些协议已被广泛使用多年

  

[页 37:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=50)

这个模型有 5 层，从物理层往上穿过链路层、网络层和 传输层到应用层

  

[页 37:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=50)

物理层规定了如何在不同的介质上以电气 或其他模拟)信号传输比特。链路层关注的是如何在两台 直接相连的计算机之间发送有限长度的消息，并具有指定级别的可靠性。以太网和 802.11 是链路层协议的例子

  

[页 37:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=50)

网络层主要处理如何把多条链路结合到网络中，以及如何把网络与网络联结成互联网 络，以便使我们可以在两个相隔遥远的计算机之间发送数据包。网络层的任务包括找到传 递数据包所走的路径 IP 是我们将要学习的网络层主要协议案例。传输层增强了网络层的 传递保证，通常具有更高的可靠性，而且提供了数据交付的抽象，比如满足不同应用需求 的可靠字节流。TCP 是传输层协议的一个重要实例

  

[页 38:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=51)

最后，应用层包含了使用网络的应用程序

  

[页 38:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=51)

OSI 和 TCP/IP 参考模型有很多共同点。两者都以协议栈概念为基础，并且协议栈中的 协议彼此相互独立。除此之外，两个模型中各个层的功能也大致相似。例如，在两个模型 中，传输层以及传输层以上各层都为希望通信的进程提供了一种端-端的独立于网络的传输 服务。这些层组成了传输服务提供者。而且，在这两个模型中，传输层之上的各层都是传 输服务的用户，并且是面向应用的

  

[页 38:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=51)

OSI 模型的核心是如下 3 个概念 1)服务 2)接口 3)协议

  

[页 38:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=51)

或许 OSI 模型的最大贡献在于明确区分了这 3 个概念。每一层都为它的上一层执行某 些服务。服务定义说明了该层是做什么的，而不是上一层实体如何访问这一层，或这一层 是如何工作的。它定义了这一层的语义 每一层的接口告诉它上面的进程如何访问本层。它规定了有哪些参数，以及结果是什 么。但它没有说明本层内部是如何工作

  

[页 38:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=51)

这些思想与现代面向对象的程序设计思想非常吻合。一个对象就如同一个层一样，它 有一组方法(或者称为操作)供对象之外的过程调用。这些方法的语义定义了该对象所提 供的服务集合。方法的参数和结果构成了对象的接口。对象的内部代码是它的协议，对于 外部而言是不可见的，也不需要被外界关心

  

[页 39:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=52)

OSI 参考模型在协议发明之前就已经产生了。这种顺序关系意味着 OSI 模型不会偏向 于任何一组特定的协议，这个事实使得 OSI 模型更具有通用性

  

[页 39:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=52)

例如，数据链路层最初只处理点-点网络。当广播式网络出现后，必须在模型中嵌入一 个新的子层。而且，当人们使用 OSI 模型和已有协议来构建实际网络时，才发现这些网络 并不能很好地满足所需的服务规范，因此不得不在模型中加入一些汇聚子层，以便提供足 够的空间来弥补这些差异。最

  

[页 39:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=52)

而 TCP/IP 却正好相反:先有协议，TCP/IP 模型只是已有协议的一个描述而已。所以 毫无疑问，协议与模型高度吻合，而且两者结合得非常完美。唯一的问题在于，TCP/IP 模 型并不适合任何其他协议栈。因此，要想描述其他非 TCP/IP 网络，该模型并不很有用

  

[页 39:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=52)

另一个区别在于无连接和面向连接的通信领域有所不同。OSI 模型的网络层同时支持 无连接和面向连接的通信，但是传输层只支持面向连接的通信，这是由该层的特点所决定 的(因为传输服务对于用户是可见的)。TCP/IP 模型在网络层只支持一种模式(无连接) 但是在传输层同时支持两种通信模式，这样可以给用户一个选择的机会。这种选择机会对 于简单的“请求-应答”协议特别重要

  

[页 66:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=79)

网络软件由网络协议组成，而协议是进程通信必须遵守的规则。大多数网络支持协议 的层次结构，每一层向它的上一层提供服务，同时屏蔽掉较低层使用的协议细节。协议栈 通常基于 OSI 模型或者 TCP/IP 模型。这两个模型都有链路层、网络层、传输层和应用层

  

[页 103:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=116)

2.5.3 频分复用

  

[页 103:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=116)

因此，人们研究出复用模式使多个信号共享传 输线路。

  

[页 104:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=117)

频分复用 CFDM, Frequency Division Multiplexing)利用通带传输的优势使多个用户共 享一个信道。它将频谱分成儿个频段，每个用户完全拥有其中的一个频段来发送自己的信 号。

  

[页 104:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=117)

比语音通信所需多出来的那部分频带称为保护带(guard band)，它使信道之间完全隔离。采用频分多路复用时，首先，每个语音信道的频率得到不 同程度的提升:然后，把它们合并在一起。

  

[页 105:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=118)

2.5.4 时分复用

  

[页 105:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=118)

相对频分复用的另一种复用方法是时分多路复用(TDM, TimeDivisionMultiplexing)。 在这种方式下，用户以循环的方式轮流工作。

  

[页 105:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=118)

间槽( time slot)取出并输出到混合流。

  

[页 105:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=118)

方式要求输入流在时间上必须同步。类似于频率保护带，为了适应时钟的微小变化可能要 增加保护时间( guardtime )间隔。

  

[页 106:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=119)

2.5.5 码分复用

  

[页 106:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=119)

码分复用( CDM, Code Division Multiplexing)是扩展频谱( spread spectrum)通信的一种形式，它把一个窄 带信号扩展到一个很宽的频带上。这种方法更能容忍干扰，而且允许来自不同用户的多个 信号共享相同的频带。由于码分复用技术最常用于第 二个目的，因此它称为码分多址

  

[页 127:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=140)

包交换 替代电路交换的一个方案是包交换，如图 2-43 (b)所示，第 1 章对此已经有所描述。 有了这项技术，数据包尽可能快地被发出，这里无须像电路交换那样要事先设立一条专门 的路径。

  

[页 127:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=140)

而在数据包交换中， 没有固定的路径，不同的数据包可以走不同的路径，路经的选择取决于它们被传输时的网 络状况，所以它们到达接收端的秩序可能出现混配。

  

[页 127:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=140)

因为在数据包交换中没有为传输数据预留 带宽，数据包可能不得不等待一段时间才能被转发。这样就引入了排队延迟( queuing delay)，如果许多包要在同一时间被发送出去还会引入拥塞。

  

[页 151:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=164)

数据链路层使用物理层提供的服务在通信信道上发送和接收比特。它

  

[页 151:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=164)

Cl)向网络层提供一个定义良好的服务接口。 (2)处理传输错误。 (3)调节数据流，确保慢速的接收方不会被快速的发送方淹没。

  

[页 151:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=164)

帧的管理构成了数据链路层工作的核心。

  

[页 151:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=164)

为了实现这些目标，数据链路层从网络层获得数据包，然后将这些数据包封装成帧 (企ame)以便传输。每个帧包含一个帧头、一个有效载荷(用于存放数据包〉以及一个帧 尾，如图 3-1 所示。

  

[页 152:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=165)

数据链路层的功能是为网络层提供服务。最主要的服务是将数据从源机器的网络层传 输到目标机器的网络层。

  

[页 152:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=165)

数据链路层可以设计成向上提供各种不同的服务。实际提供的服务因具体协议的不同 而有所差异。一般情况下，数据链路层通常会提供以下 3 种可能的服务: Cl )无确认的无连接服务。 (2)有确认的无连接服务。 (3)有确认的有连接服务。

  

[页 152:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=165)

无确认的无连接服务是指源机器向目标机器发送独立的帧，目标机器并不对这些帧进 行确认。以太网就是一个提供此类服务的数据链路层极好实例。采用这种服务，事先不需 要建立逻辑连接，事后也不用释放逻辑连接。

  

[页 152:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=165)

这类服务合适 两种场合，第一种是错误率很低的场合，此时差错恢复过程可以留给上层来完成:第二种

  

[页 153:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=166)

是实时通信，比如语音传输，因为在实时通信中数据迟到比数据受损更糟糕。

  

[页 153:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=166)

迈向可靠性的下一步是有确认的无连接服务。当向网络层提供这种服务时，数据链路 层仍然没有使用逻辑连接，但其发送的每一帧都需要单独确认

  

[页 153:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=166)

比如无线系统。 802.11 CWiFi)就是 此类服务的一个很好例子。

  

[页 153:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=166)

数据链路层向网络层提供的最复杂服务是面向连接的 服务。采用这种服务，源机器和目标机器在传输任何数据之前要建立一个连接。连接上发 送的每一帧都被编号，数据链路层确保发出的每个帧都会真正被接收方收到。它还保证每 个帧只被接收一次，并且所有的帧都将按正确的顺序被接收。因此，面向连接的服务相当 于为网络层进程提供了一个可靠的比特流。它适用于长距离且不可靠的链路，比如卫星信 道或者长途电话电路。如果采用有确认的无连接服务，可以想象丢失了确认可能导致一个 帧被收发多次，因而将浪费带宽。

  

[页 153:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=166)

对于数据链路层来说，通常的做法是将比特流拆分成多个离散的帧，为每个帧计算一 个称为校验和的短令牌(本章后面将讨论校验和算法)，并将该校验和放在帧中一起传输。

  

[页 154:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=167)

拆分比特流的实际工作比初看上去的要复杂得多。 一个好的设计方案必须使接收方很 容易发现一个新帧的开始，间时所使用的信道带宽要少。我们将考察下列 4种方法: (1 )字节计数法. (2)字节填充的标志字节法。 (3)比特填充的标志比特法。 (4)物理层编码违禁法。

  

[页 154:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=167)

种成帧方法利用头部中的一个字段来标识该帧中的字符数。当接收方的数据链路 层看到字符计数值时，它就知道后面跟着多少个字节 ， 因此也就知道了该帧在哪里结束。

  

[页 154:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=167)

第二种成帧方法考虑到了出错之后的重新同步问题，它让每个帧用 一些特殊的字节作 为开始和结束.这些特殊字节通常都相同 ， 称为标志字节( flag byte)，作为帧的起始和结 束分界符，如图 3-4 (a)中的 FLAG所示。

  

[页 154:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=167)

因此，如果接收方丢失了同步，它只需搜索两个标志字节就能找到当前帧的结 束和下一帧的开始位置.

  

[页 154:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=167)

有一种方法可以解决这个问 题，发送方的数据链路层在数据中“偶尔”出现的每个标志字节的前面插入一个特殊的转 义字节( ESC)。因此，只要看它数据中标志字节的前面有没有转义字节，就可以把作为帧 分界符的标志字节与数据中出现的标志字节区分开来。接收方的数据链路层在将数据传递

  

[页 155:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=168)

给网络层之前必须删除转义字节。这种技术就称为字节填充( byte stuffing)。

  

[页 155:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=168)

3-4 中描述的字节填充方案是 PPP 协议( Point-to-PointProtocol) 使用的略微简化形 式，该协议通常用在通信链路上传送数据包。我们将在本章后面讨论 PPP 协议。

  

[页 155:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=168)

第三种区分比特流边界的方法考虑了字节填充的缺点，即只能使用 8 比特的字节。 帧的划分可以在比特级完成，因而帧可以包含由任意大小单元(而不是只能以 8 比特为 单元)组成的二进制比特数。

  

[页 156:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=169)

解决了如何标识每一帧的起始和结束位置之后，我们现在来看下一个问题:如何确 保所有的帧最终都被传递给目标机器的网络层，并且保持正确的顺序

  

[页 157:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=170)

很显然，必须要采取某种措施来阻止这种情况发生。常用的办法有两种。第一种方法 是基于反憬的流量控制(feedback-basedflow control)，接收方给发送方返回信息，允许它 发送更多的数据，或者至少告诉发送方自己的情况怎么样。第二种方法是基于速率的流量 控制 Crate-based flow control)，使用这种方法的协议有一种内置的机制，它能限制发送方 传输数据的速率，而无须利用接收方的反馈信息。

  

[页 168:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=181)

在涉及数据链路层时，通过接口从网络层传递到数据链路层的数据包是纯粹的数据， 它的每一位都将被递交到目标机器的网络层。

  

[页 168:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=181)

当数据链路层接收到一个数据包，它就在数据包前后增加一个数据链路层头和尾，由 此把数据包封装到一个帧中(见图 3-1)。因此，一个帧由一个内嵌的数据包、一些控制信息 (在头中)和一个校验和(在尾部)组成。然后，帧被传输到另一台机器上的数据链路层。

  

[页 169:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=182)

为什么网络层永远得不到任何帧头的信息，理由非常简单，那就是要保持网络层和数 据链路层的完全分离。只要网络层对数据链路协议和帧格式一无所知，那么当数据链路协 议和帧格式发生变化时，网络层软件可以不作任何改变

  

[页 171:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=184)

3.3.1 一个乌托邦式的单工协议 作为第一个例子，我们来考虑一个简单得不能再简单的协议，它不需要考虑任何出错 的情况。

  

[页 171:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=184)

在这个协议中，数据只能单向传输。发送方和接收方的网络层总是处于准备就绪 状态。

  

[页 171:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=184)

协议由两个单独的过程组成 z 一个发送过程和一个接收过程。发送过程运行在源机器 的数据链路层上:接收过程运行在目标机器的数据链路层上。

  

[页 172:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=185)

乌托邦协议是不现实的，因为它不处理任何流量控制或纠错工作。其处理过程接近于 无确认的无连接服务，必须依赖更高层次来解决上述这些问题，即使无确认的无连接的服 务也要做一些差错检测的工作。

  

[页 172:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=185)

无错信道上的单工停.等式协议 现在我们将处理这样的问题:发送方以高于接收方能处理到达帧的速度发送帧，导致 接收方被淹没。这种情形实际上很容易出现，因此协议是否能够防止它非常重要。

  

[页 172:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=185)

这个问题的更一般化解决方案是让接收方给发送方提供反馈信息。接收方将数据包传 递给网络层之后给发送方返回一个小的哑帧，实际上这一帧的作用是给发送方一个许可， 允许它发送下一帧。发送方在发出一帧之后，根据协议要求，它必须等待一段时间直到短 哑帧(即确认〉到达。这种延缓就是流量控制协议的 一个简单例子。

  

[页 173:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=186)

3.3.3 有错信道上的单工停-等式协议 现在让我们来考虑比较常规的情形，即通信信道可能会出错。帧可能会被损坏，也可 能完全被丢失。然而，我们假设，如果一帧在传输过程中被损坏，则接收方硬件在计算校 验和时能检测出来。

  

[页 175:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=188)

协议 3 与其前任协议的不同之处在于，当发送方和接收方的数据链路层处于等待状态 时，两者都用一个变量记录下了有关的值。发送方在 next 企ame to send 中记录了下一个 要发送的帧的序号:接收方则在企ame_expected 中记录了下一个期望接收的序号。每个协 议在进入无限循环之前都有一个简短的初始化阶段。

  

[页 176:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=189)

3.4 滑动窗口协议

还需要再看看其他的讲解 不太明白

# 再复习

  

[页 177:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=190)

接下去的 3 个协议都是双向协议，它们同属于一类称为滑动窗口 Csliding window)的 协议。这 3 个协议在效率、复杂性和缓冲区需求等各个方面有所不同，本节后面将会逐个 讨论。

  

[页 177:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=190)

所有滑动窗口协议的本质是在任何时刻发送方总是维持着一组序号，分别对应于允许 它发送的帧。我们称这些帧落在发送窗口( sendingwindow)内。

  

[页 177:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=190)

发送方窗口内的序号代表了那些可以被发送的帧，或者那些已经被发送但还没有被确 认的帧。任何时候当有新的数据包从网络层到来时，它被赋予窗口中的下一个最高序号， 并且窗口的上边界前移一格。当收到一个确认时，窗口的下边界也前移一格。按照这种方 法发送窗口持续地维持了一系列未被确认的帧。

  

[页 178:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=191)

接收方数据链路层的窗口对应于它可以接受的帧。

  

[页 178:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=191)

在讨论一般情形以前，我们先来考察一个窗口尺寸为 1 的滑动窗口协议。由于发送方 在发出一帧以后，.必须等待前一帧的确认到来才能发送下一帧，所以这样的协议使用了停. 等式办法。

  

[页 180:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=193)

到现在为止，我们一直有这样的默契假设，即一个帧到达接收方所需要的传输时间加 上确认帧回来的传输时间可以忽略不计。有时候，这种假设明显是不正确的。在这些情形 下，过长的往返时间对于带宽的利用效率有严重的影响

  

[页 180:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=193)

很显 然，站在效率的角度，长发送时间、高带宽和短帧这三者组合在一起就是一种灾难。

  

[页 180:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=193)

这里描述的问题可以看作是这种规则的必然结果，即发送方在发送下一帧之前必须等 待前一帧的确认。

  

[页 181:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=194)

保持多个帧同时在传送的技术是管道化( pipelining)的一个例子。在一个不可靠的通 信信道上像管道一样传送帧会引起一些严重的问题。

  

[页 181:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=194)

一种选择办法称为回退 n (go-back-n)，接收方只需简单丢弃所有到达的后续帧，而且

  

[页 182:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=195)

针对这些丢弃的帧不返回确认。

  

[页 182:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=195)

针对管道化发送帧发生的错误，另一种通用的处理策略称为选择重传( selective rep阅t)。使用这种策略，接收方将收到的坏帧丢弃，但接受并缓存坏帧后面的所有好帧。 当发送方超时，它只重传那个最早的未被确认的帧。

  

[页 185:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=198)

3.4.3 选择重传协议

  

[页 185:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=198)

如果错误很少发生，则回退 n 协议可以工作得很好:但是，如果线路质量很差，那么 重传的帧要浪费大量带宽。另一种处理错误的策略是选择重传协议，允许接收方接受并缓 存坏帧或者丢失帧后面的所有帧。

  

[页 185:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=198)

在这个协议中，发送方和接收方各自维持一个窗口，该窗口分别包含可发送或己发送 但未被确认的和可接受的序号。发送方的窗口大小从 0 开始，以后可以增大到某一个预设 的最大值。相反，接收方的窗口总是固定不变，其大小等于预先设定的最大值。

  

[页 194:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=207)

数据链路层的任务是将物理层提供的原始比特流转换成由网络层使用的帧流。链路层 为这样的帧流提供不同程度的可靠性，范围从无连接无确认的服务到可靠的面向连接服务 不等。

  

[页 194:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=207)

链路层采用的成帧方法各种各样，包括字节计数、字节填充和比特填充。数据链路协 议提供了差错控制机制来检测或纠正传输受损的帧，以及重新传输丢失的帧。为了防止快 速发送方淹没慢速接收方，数据链路协议还提供了流量控制机制。滑动窗口机制被广泛用 来以一种简单方式集成差错控制和流量控制两大机制。当窗口大小为 1 个数据包时，则协 议是停·等式的。

  

[页 195:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=208)

Internet使用 PPP 作为点到点线路上的主要数据链路协议。 PPP 协议提供了无连接的无 确认服务，使用标志字节区分帧的边界，

  

[页 199:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=212)

网络链路可以分成两大类 z 使用点到点连接和使用广播信道。我们在第 2 章学习了点 到点链路，本章将讨论广播网络和相应的协议。

  

[页 199:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=212)

用来确定多路访问信道下一个使用者的协议属于数据链路层的一个子层，该层称为介 质访问控制( MAC, Medium Access Control)子层。在 LAN 中， MAC 子层显得尤为重要， 特别是在无线局域网中，因为无线本质上就是广播信道。

  

[页 199:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=212)

4.1.1 静态信道分配

  

[页 199:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=212)

在多个竞争用户之间分配单个信道的传统做法是把信道容量拆开分给多个用户使用，

  

[页 201:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=214)

既然所有的传统静态信道分配方法都不适应突发性的流量，我们现在就来研究动态的 信道分配方法。

  

[页 201:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=214)

1 )流量独立( independent traffic )。该模型是由 N 个独立的站(比如计算机、电话) 组成的，每个站都有一个程序或者用户产生要传输的帧。在长度为 Lit 的间隔内，期望产生 的帧数是 λLit，这里 λ 为常数(新帧的到达率)。一旦生成出一帧，则站就被阻塞，直到该 帧被成功地发送出去。

  

[页 201:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=214)

2)单信道 CSingle Channel)。所有的通信都用这一个信道。所有的站可以在该信道 上传输数据，也可以从该信道接收数据。所有站的能力都相同，尽管协议可能为站分配不 同的角色(比如，优先级)。

  

[页 201:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=214)

(3)冲突可观察 CobservableCollision)。如果两帧同时传输，则它们在时间上就重叠， 由此产生的信号是混乱的，这种情况称为冲突( collision)。所有的站都能够检测到冲突事 件的发生。冲突的帧必须在以后再次被发送。除了因冲突而产生错误外，不会再有其他的 错误。

  

[页 201:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=214)

4)时间连续或分槽( Continuous or slo time)。时间可以假设是连续的，即在任何 时刻都可以开始传输帧。另一种选择是把时间分槽或者分成离散的间隔(称为时间槽)。帧 的传输只能从某个时间槽的起始点开始。一个时间槽可能包含 0、 l 或者多个帧，分别对应 于空闲的时间槽、一次成功发送，或者一次冲突。

  

[页 201:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=214)

5)载波侦昕或不昕( Carrier Sense or no carrier sense)。有了载波侦昕的假设，一个站 在试图用信道之前就能知道该信道当前是否正被使用。如果信道侦昕结果是忙，则没有一 个站会再去试图使用该信道。如果没有载波侦昕，站就无法在使用信道之前侦昕信道，它 们只能盲目地传输，以后再判断这次传输是否成功。

  

[页 203:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=216)

:LI! ALOHA ALOHA 系统的基本思想非常简单:当用户有数据需要发送时就传输。当然，这样做 可能会产生冲突，冲突的帧将被损坏。

  

[页 203:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=216)

如果帧被损坏了，则发送方要等待一段随机时间，然后再次发送该帧。等待的时间必 须是随机的，否则同样的帧会一次又一次地冲突，因为冲突帧被重发的节奏完全一致。如 果系统中多个用户共享同一个信道的方法会导致冲突，则这样的系统称为竞争( contention) 系统。

  

[页 203:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=216)

我们使所有的帧具有同样的长度， 因为对于 ALOHA 系统，采用统一长度的帧比长度可变的帧更能达到最大的吞吐量。

  

[页 204:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=217)

分槽 ALOHA ALOHA 出现不久， Roberts 发表了一种能将 ALOHA 系统的容量增加一倍的方法 (Robe邸， 1972)。他的建议是将时间分成离散的间隔，这种时间间隔称为时间槽( slot), 每个时间槽对应于一帧。这种方法要求用户遵守统一的时间槽边界。取得同步时间的一种 办法是由一个特殊的站在每个间隔起始时发出一个脉冲信号，就好像一个时钟一样。

  

[页 206:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=219)

利用分槽 ALOHA，可以达到的最佳信道利用率是 1尬。这么低的结果并不令人惊奇， 因为每个站都可以随意地发送数据，它并不知道其他站是否也在发送数据。所以，频繁地 发生冲突是难免的。然而，在局域网中，站是完全有可能检测到其他站当前在做什么，然 后再根据情况调整自己的行为。这些网络可以获得比 lie好得多的利用率。在这一小节中， 我们将讨论一些提高性能的协议。

  

[页 206:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=219)

坚持和非坚持 CSMA 我们将要学习的第一个载波侦昕协议称为 1-坚持载波检测多路访问 CCSMA, Carrier Sense Multiple Access)。这是最简单的 CSMA 方案。当一个站有数据要发送时，它首先侦 昕信道，确定当时是否有其他站正在传输数据:如果信道空闲，它就发送数据。否则，如 果信道忙，该站等待直至信道变成空闲:然后，站发送一帧。如果发生冲突，该站等待一 段随机的时间，然后再从头开始上述过程。这样的协议之所以称为 1-坚持，是因为当站发 现信道空闲时，它传输数据的概率为 lo

  

[页 206:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=219)

第二个载波侦昕协议是非坚持 CSMA (nonpersistent CSMA)。在这个协议中，站在试 图发送数据之前要理智得多，不像前一个协议那样贪婪。和前一个协议一样，站在发送数 据之前要先侦昕信道。如果没有其他站在发送数据，则该站自己开始发送数据。然而，如 果信道当前正在使用中，则该站并不持续对信道进行监听，以便传输结束后立即抓住机会 发送数据。相反，它会等待一段随机时间，然后重复上述算法。因此，该算法将会导致更

  

[页 207:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=220)

好的信道利用率，但是比起 1一坚持 CSMA，也带来了更大的延迟。

  

[页 207:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=220)

带冲突检测的 CSMA

  

[页 207:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=220)

这种协议称为带冲突检测的 CSMA CCSMA/CD, CSMA with Collision Detection)。它 是经典以太局域网的基础，

  

[页 207:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=220)

如同许多其他LAN协议一样， CSMA/CD也使用了图4-5所示的概念模型。在标记为 句点，一个站己经完成了帧的传送，其他需要发送帧的站现在可以试图发送了。如果有两 个或者多个站同时进行传送，冲突就会发生。如果一个站检测到冲突，它立即中止自己的 传送，等待一段随机时间，然后再重新尝试传送(假定在此期间没有其他站己经开始传送〉。

  

[页 208:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=221)

因此，我们的 CSMA/CD 模型将由交替出现的竞争期、传输期，以及当所有站都育事止的 闲期〈比如没有传输任务〉组成。

  

[页 208:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=221)

有了这种认识，我们可以把 CSMA/CD 竞争看成是一个分槽 ALOHA 系统，时间槽宽 度为2τ。在1千米长的同轴电缆上， 微秒。 CSMA/CD和分槽ALOHA的区别在于， 只有一个站能用来传输的时间槽(即信道被抓住了)后面紧跟的那些时间槽被用来传输该 帧的其余部分。如果帧时相比传播时间长很多，这种差异将能大大提高协议的性能。

  

[页 210:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=223)

完成同样事情的另一种方 法是通过传递一个称为令牌( token)的短消息，该令牌同样也是以预定义的顺序从一个站 传到下一个站。令牌代表了发送权限。如果站有个等待传输的帧队列，当它接收到令牌就 可以发送帧，然后再把令牌传递到下一站。如果它没有排队的帧要传，则它只是简单地把 令牌传递下去。

  

[页 210:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=223)

在令牌环 Ctoken ring)协议中，网络的拓扑结构被用来定义站的发送顺序。所有站连 接成一个单环结构，一个站依次连接到下一个站。因 此令牌传递到下一站只是单纯地从一个方向上接收 令牌和在另一个方向上发送令牌，如图 4-7所示。帧 也按令牌方向传输。

  

[页 214:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=227)

4.2.5 无线局域网协议

  

[页 215:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=228)

我们需要一个 MAC 协议，它能防止这种冲突的发生，因为冲 突将导致带宽的浪费。由于竞争者离得太远而导致站无法检测到潜在的竞争者，这个问题 称为隐藏终端问题( hidden station problem)。

  

[页 215:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=228)

我们需要一个 MAC 协议， 它能防止此类延迟传输的发生。这个问题称为暴露终端问题( exposed station problem)。

  

[页 215:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=228)

MACA 的基本思想是 发送方剌激接收方输出一个短帧，以便其附近的站能检测到该次传输，从而避免在接下去 进行的(较大)数据帧传输中也发送数据。这项技术被用来替代载波侦听。

  

[页 215:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=228)

要反复看看这个模型

  

[页 216:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=229)

我们将开始研究太网网实际系统，这可能是现实世界中最普遍的一种计算机网络。 以太网有两类:第一类是经典以太网( classicEhemet)，它使用我们在本章己学过的技术 解决了多路访问问题:第二类是交换式以太网( switchedEthernet)，使用了一种称为交换 机的设备连接不同的计算机。

  

[页 219:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=232)

为了更加容易地区分有效帧和垃圾数据， 以太网要求有效帧必须至少 64字节长，从目标地址算起直到校验和，包括这两个字段本身 在内。如果帧的数据部分少于 46 个字节，则使用填充( Pad)字段来填充该帧，使其达到 最小长度要求。

  

[页 219:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=232)

限制最小帧长的另一个(也是更重要的〉理由是避免出现这样的情况:当一个短帧还 没有到达电缆远端的发送方，该帧的传送就已经结束:而在电缆的远端，该帧可能与另一 帧发生冲突。

  

[页 223:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=236)

幸运的是，还有另一条出路可以处理不断增长的负载:即交换式以太网。这种系统的 核心是一个交换机( switch)，它包含一块连接所有端口的高速背板，如图 4-17 (b)所示。 从外面看，交换机很像集线器。它们都是一个盒子，通常拥有 48 个端口，每个端口都 有一个标准的 RJ-45 连接器用来连接双绞线电缆。

  

[页 223:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=236)

在这点上，交换机再一 次体现了与集线器的不同。在集线器中，所有站都位于同一个冲突域 Ccollision domain), 它们必须使用 CSMNCD 算法来调度各自的传输。在交换机中，每个端口有自己独立的冲 突域。通常情况下，电缆是全双工的，站和端口可以同时往电缆上发送帧，根本无须担心 其他站或者端口。现在冲突不可能发生，因而 CSMNCD 也就不需要了。然后，如果电缆 是半双工的，则站和端口必须以通常的 CSMNCD方式竞争传输。

  

[页 231:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=244)

另一种模式，如图 4-23 (b)所示，是一种自组织网络( ad hoc network)。这种模式下 的网络由一组相互关联的计算机组成，它们相互之间可以直接向对方发送帧。这里没有接 入点。

  

[页 232:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=245)

在 802.11 中，介质访 控制( MAC, Medium Access Control) 子层决定如何分配信道，也就是说下一个谁可以 送。在它上方的是逻辑链路控制( LLC, Logical Link Control) 子层，它的工作是隐藏 802 系列协议之间的差异，使它们在网络层看来并无差别。

  

[页 232:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=245)

基于正交频分复用( OFDM, Orthogonal Frequency Division Multiplexing)编码方案的新传输技术分别在 1999 年和 2003 年被引入进 来，我们在 2.5.3节介绍过 OFDM。首先是 802.lla，它使用了 SGHz这个不同的频段:第 802.llg，它坚守在 2.4 GHz，并保持兼容性。两者都提供高达 54Mbps 的数据率。

  

[页 234:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=247)

802.11 MAC 子层协议

  

[页 234:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=247)

相反， 802.11 试图避免冲突，采用的协议称为带有冲突避免的 CSMA CCSMA/CA, CSMA with Collision Avoidance)

  

[页 234:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=247)

在 OFDM 物理层 情况下，后退选择的时间槽数范围在 15 之间。该站将等待，直到信道处于闲置状态。 具体做法是 z 通过侦昕确定在一个很短的时间内(这段时间称为 DIFS，我们在下面解释) 没有信号:然后倒计数空闲时间槽，当有帧在发送时暂停该计数器:当计数器递减到 o, 该站就发送自己的帧。如果帧发送成功，目标站立即发送一个短确认。如果没有收到确认， 则可推断出传输发生了错误，无论是冲突或是其他什么错。在这种情况下，发送方要加倍 后退选择的时间槽数，再重新试图发送。如此反复，连续像以太网那样以指数后退，直到 成功发送帧或达到重传的最大次数。

  

[页 256:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=269)

4.8 数据链路层交换

  

[页 256:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=269)

当我们采用称为网桥( bridge)的设备来连 接这些局域网就可以做到这一点。我们在 4.3.4节描述的以太网交换机是网桥的现代名称: 它们提供的功能超越了传统的以太网和以太网集线器，可以很容易地把多个局域网加入到 一个更大更快的网络上。我们将交替着使用术语“网桥”和“交换机飞

  

[页 270:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=283)

许多动态信道分配算法被设计了出来。 ALOHA 协议，包括分槽的与不分槽的，被用 在许多实际系统的衍生物中，例如线缆调制解调器和盯ID。当可以侦听信道状态后，作为 一种改进，站在其他站传输时可避免启动自己的传输。这种技术，即载波侦听，导致了局 域网和城域网的 CSMA 各种协议。它是典型以太网和 802.11 网络的基础。

  

[页 270:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=283)

无线局域网提出了新的问题，就是很难侦听到传输冲突，而且站所覆盖的区域可能有 所不同。在主宰无线局域网的 IEEE 802.11 中，站使用 CSMA/CA，通过留有很小的时间间 隔来避免冲突，从而减轻第一个问题。站还可以使用 RTS/CTS 协议来对抗由于第二个问题 引起的隐藏终端。

  

[页 274:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=287)

网络层关注的是如何将源端数据包一路送到接收方.

  

[页 274:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=287)

为了将数据包送到接收方，可能 沿途要经过许多跳( hop)中间路由器。这种功能显然与数据链路层的功能不同，数据链路 层的目标没那么宏伟，只是将帧从线路一边传送到另 一边。因此 ， 网络层是处理端到端数 据传输的最底层。

  

[页 274:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=287)

为了实现这个目标 ， 网络层必须知道网络拓扑结构〈即所有路由器和链路的集合〉，并 从中选择出适当的路径，即使是大型网络也要选出 一条好路经。同时，网络层还必须仔细 选择路由器，避免某些通信线路和路由器负载过重，而其他线路和路由器空闲。

  

[页 274:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=287)

5.1.1 存储转发数据包交换

  

[页 275:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=288)

在该数据包到达路由器，并且路由器的链路层完成了对它校验和的验证之后，它先 被存储在路由器上:然后沿着路径被转发到下一个路由器，直至到达目标主机，这里就是 数据包的目的地。这种机制即为存储.转发数据包交换，正如在前面几章已经看到的那样。

  

[页 276:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=289)

。如果使用了面向连接的服务，那么，在 发送数据包之前，必须首先建立起一条从源路由器到目标路由器之间的路径。这个连接称 为虚电路 eve, virtual circuit)，它类似于电话系统中建立的物理电路，对应的网络称为虚 电路网络( virtual-circuitnetwork) .

  

[页 277:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=290)

IP 协议( Internet Protocol)是整个 Internet 的基础，它是无连接网络服务的重要范例。 每个数据包携带一个目标 IP地址，路由器使用该地址来单独转发每一个数据包。

  

[页 277:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=290)

藏在虚电路背后的思想是避免为每个要发送的数据包选择一条新路径(

  

[页 277:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=290)

所有需要在这个连接上通过的流量，都 使用这条路径，这与电话系统的工作方式完全一致。当连接被释放之后，虚电路也随之消 失。在面向连接的服务中，每个数据包包含一个标识符，指明了它属于哪一条虚电路。

  

[页 277:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=290)

现在我们来考虑如果 H3 也希望与 H2 建立连接则情形会怎么样。 H3 选择连接标识符 1 (因为是它发起连接，而且这是它唯一的连接)，并且告诉网络要建立虚电路

  

[页 278:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=291)

在有些上下文中，这个过程称为标签交换( label switching)。一种面向连接的网络服务 例子是多协议标签交换( MPLS, MultiProtocol Label Switching)，它主要被用在 Internet ISP网络， IP数据包被一个有20位连接标识或标签的MPLS头包裹着。

  

[页 278:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=291)

5.1.5 虚电路与数据报网络的比较

还要再详细看

  

[页 278:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=291)

从保证服务质量以及避免网络拥塞的角度来看，虚电路有一定的优势，因为在建立连

  

[页 279:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=292)

接时，资源可以提前预留(比如缓冲区空间、带宽和 CPU 周期〉。一旦数据包开始到来， 所需要的带宽和路由器容量都已经准备就绪。而对于数据报网络，避免拥塞更困难些。

  

[页 279:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=292)

路由算法 Crouting algorithm)是网络层软件的一部分，它负责确定一个入境数据包应 该被发送到哪一条输出线路上。如果网络内部使用了数据报，那么路由器必须针对每一个 到达的数据包重新选择路径

  

[页 279:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=292)

有的时候对路由和转发这两个功能进行区分是非常有用的，路由即对使用哪一条路径 做出决策，而转发则是当一个数据包到达时该采取什么动作。可以把路由器想象成内部有 两个进程。其中一个进程在每个数据包到达的时候对它进行处理，它在路由表中查找该数 据包所对应的出境线路。这个进程即为转发 Cforwarding)进程:另一个进程负责生成和更 新路由表，这正是路由算法发挥作用的地方。

  

[页 280:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=293)

自适应算法( adaptive algorithm)则会改变它们的路由决策以便反映出拓扑 结构的变化，通常也会反映出流量的变化情况。这些动态路由( dynamicron出g)

  

[页 280:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=293)

非自适应算法( nonadaptive algorithm)不会根据当前测量或者估计的流量和拓扑结构，来调整它们的路由决策。相反， (对所有的 J) 所使用的路由选择是预先在离线情况下计算好，并在网络启动· 时被下载到路由器中的。这个过程有时候也称为静态、路由(static routing)

  

[页 281:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=294)

作为最优化原则的一个直接结果，从所有的源到一个指定目标的最优路径的集合构成 了一棵以目标节点为根的树

  

[页 281:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=294)

所有路由算法的目标是为所有路由器找到这样的汇集树，并根据汇集 树来转发数据包。

  

[页 281:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=294)

5.2.2 最短路径算法

  

[页 282:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=295)

一般情况下，边上面的标记可以作为距离、带宽、平均流量、通信成本、平均延迟等 其他因素的一个函数，通过计算得出。通过改变函数的权重，路由算法就可以根据任何一 种标准或者多种标准的组合来计算“最短”路径。

  

[页 284:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=297)

5.2.3 泛洪算法 在实现路由算法时，每个路由器必须根据本地知识而不是网络的全貌做决策。一个简 单的本地技术是泛洪( flooding)，这种技术将每一个入境数据包发送到除了该数据包到达 的那条线路以外的每条出境线路。

  

[页 285:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=298)

5.2.4 距离矢量算法

  

[页 285:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=298)

计算机网络通常使用动态路由算法。

  

[页 285:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=298)

距离矢量路由( distance vector routing)算法是这样工作的 z 每个路由器维护一张表(即 一个矢量〉，表中列出了当前己知的到每个目标的最佳距离，以及所使用的链路。这些表通过 邻居之间相互交换信息而不断被更新，最终每个路由器都了解到达每个目的地的最佳链路。

  

[页 285:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=298)

在距离矢量路由算法中，每个路由器维护一张路由表，它以网络每个路由器为索引， 并且每个路由器对应一个表项。该表项包含两部分:到达该目标路由器的首选出境线路， 以及到达该目标路由器的距离估计值。距离的度量可能是跳数，或者其他因素，正如我们 在计算最短路径时讨论的那样。

  

[页 285:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=298)

假定路由器知道它到每一个邻居的“距离”。如果所用的度量是跳数，那么该距离就是 跳。如果度量值为传播延迟，则路由器很容易测量出链路的传播延迟。它只要直接发送 一个特殊的 ECHO 数据包给邻居，邻居收到后盖上时间戳，尽可能快地发回来即可。

  

[页 286:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=299)

无穷计算问题 整个网络最佳路径的寻找过程称为收敛( convergence)。距离矢量路由算法作为 一 项简 单技术很有用，因为路由器可以在所有路径中有选择地计算出一条最短路径。但实际 有一个严重的缺陷:虽然它总是能够收敛到正确的答案，但速度可能非常慢。

  

[页 288:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=301)

5.2.5 链路状态路由

  

[页 288:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=301)

链路状态路由算法的设计思想非常简单，可以用五个部分加以描述。每一个路由器必 须完成以下的事情，算法才能正常工作: Cl)发现它的邻居节点，并了解其网络地址。 (2)设置到每个邻居节点的距离或者成本度量值。 (3)构造一个包含所有刚刚获知的链路信息包。 (4)将这个包发送给所有其他的路由器，并接收来自所有其他路由器的信息包。 (5)计算出到每个其他路由器的最短路径。

  

[页 288:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=301)

1979 年以前 ARPANET 一直使用距离矢量路由算法，而在此之后则改为使用链路状态 路由算法。导致距离适量算法退位的主要问题在于，当网络拓扑结构发生变化后距离矢量 路由算法需要太长时间才能收敛到稳定状态(由于无穷计数问题)。因此，距离矢量路由算 法被一个全新的算法所替代，该算法称为链路状态路由算法( link state routing)。

  

[页 288:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=301)

实际上，算法将完整的拓扑结构分发给了每一个路由器。然后每个路由器运行 Dijkstra 算法就可以找出从本地到每一个其他路由器的最短路径。下面我们详细地考虑上述每一个 步骤。

  

[页 288:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=301)

发现邻居 当一个路由器启动时，它的第一个任务是找出哪些路由器是它的邻居。为了实现这个 目标，它只需在每一条点到点线路上发送一个特殊的 HELLO 数据包。线路另一端的路由 器应该返回一个应答说明自己是谁。这些名字必须是全局唯一的，

  

[页 289:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=302)

设置链路成本 为了寻找最短路径，链路状态路由算法需要每条链路以距离或成本度量。

  

[页 289:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=302)

构造链路状态包 一旦收集到了所需要的交换信息，每个路由器的下一步工作是构建一个包含所有这些 信息的数据包。该数据包的内容首先是发送方的标识符，接着是一个序号( Seq)和年龄 (Age，后面再介绍)，以及一个邻居列表。

  

[页 289:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=302)

分发链路状态包 链路状态路由算法最技巧的部分在于分发链路状态数据包。所有路由器必须快速并可 靠地获得全部的链路状态数据包

  

[页 289:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=302)

如果不同的路由器使用了不同版本的拓扑结构，那么它 们计算出来的路由可能会不一致，例如出现环路、目标机器不可达以及其他的问题。

  

[页 290:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=303)

发送标志表明该数据包必须在所指示的线路上发送。确认标志 表明它必须在这条线路上得到确认。

  

[页 291:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=304)

计算新路由 一旦路由器己经积累了全部的链路状态数据包之后，它就可以构造出完整的网络图， 因为每条链路都己经被表示出来了。事实上，每条链路被表示了两次，每个方向各表示一 次。不同方向的链路可能有不同的成本。最短路径计算可找到从 与从 不同 的路径。

  

[页 291:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=304)

现在可以在路由器本地运行 Dijkstra 算法，以便构建出从本地出发到所有可能目标的 最短路径。这个算法的运行结果告诉路由器到达每个目的地能够走哪条链路。这个信息被 安装在路由表中，而且恢复正常操作。

  

[页 291:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=304)

相比距离矢量算法，链路状态路由算法需要更多的内存和计算。对于一个具有 n 个路 由器的网络，每个路由器有 k个邻居，那么，用于存储输入数据所要求的内存与 h 成正比， 这至少与列出全部目的地的路由表一样大。而且，计算时间的增长快过 h ，即使采用最有 效的数据结构，在大型网络中运行这个算法依然是个问题。不过，在许多实际场合，链路 状态路由算法工作得很好，因为它没有慢收敛问题。

  

[页 292:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=305)

5.2.6 层次路由

  

[页 292:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=305)

在采用了分层路由之后，路由器被划分成区域( region)。每个路由器知道如何将数据 包路由到自己所在区域内的目标地址，但是对于其他区域的内部结构毫不知情。当不同的 网络被相互连接在一起，很自然地就会将每个网络当作一个独立的区域，一个网络中的路 由器不必知道其他网络的拓扑结构。

  

[页 302:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=315)

5.3 拥塞控制算法

  

[页 302:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=315)

传输层共同努力协同工作。 数据包。然而，控制拥塞的最有效方法是减少传输层注入网络的负载。这就需要网络层和 拥塞发生在网络内，正是网络层直接经历着拥塞，而且必须由它最终确定如何处理过载的 能，这种情况称为拥塞( congestion)。网络层和传输层共同承担着处理拥塞的责任。由于 (一部分)网络中存在太多的数据包导致数据包被延迟延迟和丢失，从而降低了传输’性

  

[页 302:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=315)

。网络层和传输层共同承担着处理拥塞的责任

计网考点

  

[页 302:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=315)

然而，控制拥塞的最有效方法是减少传输层注入网络的负载。这就需要网络层和 传输层共同努力协同工作。

  

[页 304:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=317)

拥塞的出现意味着负载(暂时)大于资源(在网络的一部分〉可以处理的能力。很自 然人们能想到两个解决方案:增加资源或减少负载。

  

[页 304:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=317)

这称为流量感知的路由(traffic-aware routing)。把流量拆分到多个路径也是有 用的。

  

[页 304:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=317)

然而，有的时候不可能增加容量。那么对抗拥塞的唯一 的办法就是降低负载。在 虚电路网络中，如果新的连接将导致网络变得拥挤不堪，那么就应该拒绝这种新连接的建 立。这种控制称为准入控制( admissioncontrol)

  

[页 308:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=321)

显式拥塞通知 除了生成额外的包发出拥塞警告外，路由器可以在它转发的任何数据包上打上标记(设 置数据包头的某一个标志位)发出信号，表明它正在经历着拥塞。当网络传递数据包时， 接收方可以注意到有个拥塞己经发生，在它发送应答包时顺便告知发送方。然后发送方可 以像以前那样紧急刹车降低传输速率。

  

[页 330:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=343)

5.5.3 隧道

  

[页 332:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=345)

5.5.5 数据包分段

  

[页 333:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=346)

将分段重新组成原始的数据包，可以采用两种对立的策略。第一种策略，由“小数据 包”网络引起的分段过程对于沿途后续的网络都是透明的，也就是说，从该网络一直到最 终的目标途中的每个网络都感觉不到曾经发生过分段，

  

[页 335:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=348)

5.6 Internet 的网络层

  

[页 337:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=350)

5.6.1 1Pv4 协议

  

[页 340:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=353)

5.6.2 IP地址

  

[页 340:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=353)

前缀 与以太网地址不同的是 IP 地址具有层次性。每个 32 位地址由高位的可变长网络和低 位的主机两部分数据组成。

  

[页 340:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=353)

地址的书写方式是点分十进制表示法。按此格式， 4 个字节中的每个写成十进制， 取值范围从 255c.

  

[页 341:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=354)

子网 为了避免冲突，网络地址的管理由一个称为 Internet 域名和地址分配机构 CICANN, Internet Corporation for Assigned Names and Number)的非营利性公司负责。 ICANN 一次把 部分地址空间授权给各区域机构，这些机构再把 IP 地址发放给 ISP 和其他公司。这就是一 家公司获得一块田地址的过程。

  

[页 341:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=354)

问题的解决方案是，在内部将一个网络块分成几个部分供多个内部网络使用，但对外 部世界仍然像单个网络一样。这就是所谓的子网划分( subnetting)，分割一个大型网络得 到的一系列结果网络(比如以太网〉称为子网( subnet)。正如我们在第 1 章中提到的那样， 你应该意识到这个词的新用法和旧的用法有冲突，子网的以前含义是指网络中的所有路由 器和通信线路的集合。

  

[页 342:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=355)

当数据包到达时，路由器会查看该数据包的目标地址，井检查它属于哪个子网。具体 做法是:路由器把数据包的目标地址与每个子网的掩码进行 AND 操作，看结果是否对应 于某个前缀。

  

[页 361:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=374)

我们观察到出现在每个网络上的帧的以太网地址发生 了改变，而 IP地址保持不变(因为它们表示所有互联网络的端点)。

  

[页 365:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=378)

Cin位adomain routing) 部，一个组织可以使用自己的内部路由算法，或者更流行的名称叫域内路由算法 System)构成，并由不同的组织运营，这些组织通常是公司、大学或 ISP。在自己网络内 正如我们前面提到的， Internet 由大量的独立网络或自治系统( AS, Autonomous

  

[页 369:](x-devonthink-item://FB62D424-1B13-4740-A33F-51B1C18AEF67?page=382)

在一个 AS 内部，推荐使用的路由协议是 OSPF 和 IS-IS。在 AS 之间，则可以使用另 一个协议，称为边界网关协议( BGP, Border Gateway Protocol)。