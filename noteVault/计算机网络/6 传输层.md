传输层与网络层一起构成了网络层次协议的核心

传输层架构在网络层提供的服务之上,把数据传递服务从两台计算机之间扩展到了两台计算机上的进程之间,并且服务所需的可靠性程度独立于当前使用的物理网络。传输层为应用层使用网络提供了抽象的模式。如果没有传输层, 分层协议的整个概念将毫无意义。

# 传输服务
> 传输层的最终目标是向它的用户提供高效地、可靠的和成本有效的数据传输服务。
> 它的用户通常是应用层的进程。

为了实现这个目标，传输层需要充分利用网络层提供给他的服务。在传输层内，完成这项工作的硬件或软件称为传输实体（Transport entity）。
传输实体可以实现在主机的不同位置，可在kernel或者以链接库的形式绑定到网络应用中，或是以一个独立的用户进程运行。

传输层也同样和网络层一样提供面向连接与无连接的服务。

于是,一个很显然的问题出现了:
*既然传输层服务与网络层服务如此相似,为什么还要设立两个独立的层?为什么一层不够?*
问题的答案有点微妙,但非常关键。
传输层的代码完全运行在用户的机器上,但是网络层代码主要运行在由运营商操作的路由器上(至少对于广域网是如此)。
*如果网络层提供的服务不够用,怎么办?如果它频繁地丢失数据包该怎么办?如果路由器时常崩溃又该怎么办?*
用户对于网络层没有真正的控制权。唯一的可能是在网络层之上叠加一层，由该层来提高网络的服务质量。
如果在一个无连接网络中,数据包被丢失或者发生错位,则传输实体可以检测到问题所在,并通过重传来弥补这种错误。
如果在一个面向连接网络中,传输实体在执行一个漫长传输任务期间,突然接到通知说它的网络层连接己经被意外终止,而且也不知道当前正在传输的那些数据到底怎么样,那么,该传输实体可以与远程的传输实体建立一条新的网络层连接。利用新建立的连接,它可以向对等实体询问哪些数据己经到达,哪些数据还没有到达,然后从中断的地方开始继续向对方发送数据。

**本质上,由于传输层的存在,使得传输服务有可能比网络服务更加可靠**。
而且,传输服务原语可以通过调用库程序来实现,从而使得这些原语独立于网络服务原语。
正是有了传输层，开发者才可以按照一组标准的原语来编写代码。并且程序可以运行在各种各样的网络上。
**显示世界中，传输层承担了把上层与技术、设计和各种缺陷隔离的关键作用。**

### 传输服务原语
为了允许用户访问传输服务，传输层必须为应用程序提供一些操作，提供一个传输服务接口。

传输服务类似于网络服务,但是两者之间有一些重要的区别。最主要的区别在于网络服务毫不掩盖地按照实际网络提供的服务来建立模型。实际网络可能会丢失数据包,所以网络服务一般来说是不可靠的。与此相反,面向连接的传输服务是可靠的。当然,实际网络并非没有错误,但是,这恰好是==传输层的目标一一在不可靠的网络之上提供可靠的服务。==

**嵌套关系**
段(传输层之间交换的单元)被包裹在数据包(网络层之间交换的单元)中,而数据包则被包含在帧(数据链路层之间交换的单元)中。

当一帧到达时,数据链路层对帧头进行处理,如果帧目标地址与本地传递地址匹配,则把帧的有效载荷宇段中的内容传递给网络实体。网络实体对数据包头进行类似处理,然后把数据包的有效载荷宇段内容向上传递给传输实体。

### Berkeley套接字（socket）
TCP使用的套接字原语。是一种应用程序接口（API），用于网络套接字（ socket）与Unix域套接字，包括了一个用C语言写成的应用程序开发库，主要用于实现进程间通讯。

**Berkeley套接字接口**，一个应用程序接口（API），使用一个Internet套接字的概念，使主机间或者一台计算机上的进程间可以通讯。 它可以在很多不同的输入/输出设备和驱动之上运行，尽管这有赖于操作系统的具体实现。 接口实现用于TCP/IP协议，因此它是维持Internet的基本技术之一。

![](https://lv-neo.gitbooks.io/java/content/network/socket.jpeg)



# 协议传输的要素
传输服务由传输协议实现,两个传输实体之间的通信必须使用传输协议。传输协议在有些方面类似于我们在第3章中学习过的数据链路协议。
这两种协议都要处理错误控制、顺序性和流量控制以及其他一些问题。

## 寻址
当一个应用(比如一个用户)进程希望与另一个远程应用进程建立连接时,它必须指定要连接到哪个应用进程上(无连接的传输也有同样的问题:消息发送给谁?)。
通常使用的方法是为那些能够监昕连接请求的进程定义相应的传输地址。
在Internet中,这些端点称为端口(port)。
我们将使用通用术语传输服务访问点（TSAP, Transport Service Access Point）来表示传输层的一个特殊端点。
网络层上的类似端点(即网络层地址)毫不奇怪地称为网络服务访问点（N S A P .Network Service Access PPoint ) 。IP地址是NSAP的实例。

## 连接建立
**三次握手**
1. 主机1选择一个序号x，并且发送一个包含x的CONNRCTION REQUEST段给主机2
2. 主机2回应一个ACK段作为对x的确认，并且宣告它自己的初始序号y。
3. 最后，主机1在发送它的第一个数据段DATA中，对主机2选择的初始序号进行确认。[[3 数据链路层#^d80273|稍待确认机制的应用]]

TCP使用三次握手机制来建立连接。
在连接期间,时间戳被用来辅助扩展3 2 位序号,以便它在最大数据包生存期间不会回绕,甚至对于每秒千兆位的连接也一样。当TCP被用在越来越快的链路上时,这种机制是对TCP的必要修复。该机制称为防止序号回绕PAWS。

## 连接释放
释放一个连接要比建立一个连接容易得多。然而,这其中也存在着许多让人意想不到的陷阱。
正如我们前面提到过的,终止连接的方式有两种:非对称释放和对称释放。非对称释放连接是电话系统的工作方式:当一方挂机后,连接就被中断了。对称释放连接是把连接看成两个独立的单向连接,要求单独释放每一个单向连接。

很显然,我们需要一个更加复杂的释放协议来避免数据丢失。
一种方法是使用对称释放方式,每个方向被单独释放,两个方向的连接释放相互独立。因而,即使当主机发送了DISCONNECT段以后,它仍然可以接收数据。

由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。

**四次挥手**

## 差错控制和流量控制
这两个问题我们在数据链路层已经考查过。传输层采用的解决方案与我们在[[3 数据链路层#差错检测和纠正]]学过的一样。这里再简单回顾一下：
1. 帧中携带一个检错码（比如，CRC 或者校验和）用于检测信息是否被正确接收。
2. 帧中携带的序号用于标识本帧，发送方在收到接收方成功接收后返回的确认之前，必须重发帧。这种机制称为自动重复请求 (ARQ, Automatic Repeat reQuest )。
3. 任何时候允许发送方发送一定数量的帧，如果接收方没有及时返回确认，则发送方必须哲停。如果只允许发送一帧，则协议称为停等式（stop-and-wait）协议。较大的窗口可使得发送管道化，因而提高距离长且速度快的链路性能。
4. 滑动窗口 (sliding window）协议结合了这些功能，还能被用于支持数据的双向传送。

# 拥塞控制
如果许多机器上的传输实体以太快的速度发送太多的数据包,就会使得网络不堪重负而变得拥塞,继而数据包被延迟和丢失,从而导致网络性能严重下降。
避免这个问题的拥塞控制是网络层和传输层的共同责任。拥塞发生在路由器上,因此在网络层检测拥塞。然而,拥塞究竟还是由传输层注入到网络中的流量引起的,因此**控制拥塞的唯一途径是传输层放缓往网络中发送数据包的速度。**

Internet拥塞控制严重依赖于传输层。

## 理想的带宽分配
拥塞控制算法的目标是更加易于避免拥塞，即为使用网络的传输层找到一种好的带宽分配方法。

**最大最小公平性**
公平的形式是最大-最小公平，通常表示理想的网络使用情况。

最大-最小公平分配指的是,如果分配给一个流的带宽在不减少分配给另一个流带宽的前提下无法得到进一步增长,那么就不给这个流更多带宽。
**也就是说,增加一个流的带宽只会让不太富裕的那些流的情况变得更糟。**

## 调整发送速率
**显示拥塞控制**

**AIMD加法递增乘法递减**
该法则是达到有效和公平操作点的适当流量规则。兼顾效率和公平。

- 最优点
- 公平线
- 效率线

AIMD是TCP采用的拥塞控制法则,它基于这个观点和另一个稳定性观点（即驱使网络拥堵非常容易而从中恢复却很难,所以递增政策应轻柔,而递减政策应积极）。
但这个法则不是那么的公平,因为TCP连接根据每次的往返时间测量值来调整窗口的大小,而不同的连接有不同的往返时间。
这导致在所有其他条件都相同的情况下,接近主机的连接比远离主机的连接获得的带宽更多。

# UDP
Internet的传输层有两个主要协议,无连接和面向连接各一个,两个协议互为补充。

无连接协议是UDP,它除了给应用程序提供发送数据包功能并允许它们在所需的层次之上架构自己的协议之外,几乎没有做什么特别的事情。面向连接的协议是TCP ,该协议几乎做了所有的事情。

它建立连接,并通过重传机制增加了可靠性,同时还进行流量控制和拥塞控制,代表使用它的应用程序做了所有的一切。

## UDP概述
称为用户数据报协议。UDP为应用程序提供了一种无需建立连接就可以发送封装的IP数据报的方法。

**UDP头格式：**32位长

| 源端口  | 目标端口  |
| ------- | --------- |
| UDP长度 | UDP校验和 |

实际上 ,采用UDP而不是原始IP的最主要价值在于增加了源端口和目标端口。
如果没有端口字段,传输层将无从知道如何处理每个入境数据包:而有了端口字段之后,它就能把内嵌的段递交给正确的应用程序处理。

## 远程过程调用RPC
在某种意义上,向一台远程主机发送一个消息并获得一个应答,就如同在编程语言中执行一个函数调用一样。
在这两种情形下,启动时都需要提供一个或者多个参数,然后获得一个结果。这种观察导致人们试图将网络上的请求-应答交互过程安排成像过程调用那样。这样的安排使得网络应用更加易于编程也更为人们所熟悉。
例如,请想象一个名为xxx的过程,它的工作方式是向DNS服务器发送一个UDP数据包,然后等待应答:如果应答返回的速度不够快,则超时并重试。通过这种方式,向程序员隐藏了网络的所有细节。


## 实时传输协议RTP
RTP的基本功能是将几个实时数据流复用到一个UDP数据包流中。
这个UDP流可以被发送给一台目标主机(单播传输模式),也可以被发送给多台目标主机(组播传输模式)。
因为RTP仅仅使用了常规的UDP ,所以路由器不会对它的数据包有任何特殊的对待,除非开通了某些通常的IP服务质量特性。特别地,这里没有任何保障传递可靠性的措施,数据包可能会丢失、延迟或者损坏等。


# TCP
## TCP概述
传输控制协议TCP，是为了在不可靠的互联网上提供可靠的、端到端字节流而专门设计的一个传输协议。

**TCP段的头**

TCP中的流量控制是通过一个可变大小的滑动窗口来处理的。
窗口大小字段指定了从被确认的字节算起可以发送多少个字节。
窗口大小字段为0是合法的,说明到现在为止己经接收到了多达确认号-1 个字节,但是接收端没有更多的机会来消耗数据,希望别再发数据。以后,接收端可以通过发送一个具有同样确认号但是非零窗口大小字段的段来通知发送端继续发送段。

## TCP服务模型
T C P服务由发送端和接收端创建一种称为套接字(socket)的端点来获得。
每个套接字有一个套接字编号(地址),该编号由主机的IP地址以及一个本地主机的16位数值组成的。
这个16位数值称为端口(port),端口是TCP的TSAP名字。
为了获得TCP服务,必须显式地在一台机器的套接字和另一台机器的套接字之间建立一个连接。
一个套接字有可能同时被用于多个连接。换句话说,两个或者多个连接可能终止于同一个套接字。
每个连接可以用两端的套接字标识符来标识。TCP不使用虚电路号或者其他的标识符。


## TCP协议
TCP实体使用的基本协议是具有动态窗口大小的滑动窗口协议。
当发送端传送一段时,它启动一个计时器。当该段到达接收方时,接收端的TCP实体返回一个携带了确认号和剩余窗口大小的段(如果有数据要发送的话,则包含数据,否则就不包含数据〉,并且确认号的值等于接收端期望接收的下一个序号。如果发送端的计时器在确认段到达之前超时,则发送端再次发送原来的段。

## TCP连接建立
**三次握手建立机制**


## TCP连接释放
**四次挥手释放机制**

## TCP连接管理模型

## TCP滑动窗口


## TCP计时器管理

## TCP拥塞控制

# 小结