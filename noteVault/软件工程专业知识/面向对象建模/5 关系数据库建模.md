# 5 关系数据库建模

## [引入数据库建模-和面向对象建模对比](x-devonthink-item://C213396A-5F00-4308-9A95-723CD4A45B41?page=2)

^b85c98

[[Extract#^cec9a5|面向对象建模和关系数据库建模的对立]]
-   ==面向对象致力于解决计算机逻辑问题，关系模型致力于解决数据的高效存取问题，它们具有对立的一面==
    
-   Ø==动态与静态的对立==
    
-   Ø==封装与开放的对立==
    
-   面向对象试图为动态世界建模
    
-   关系模型为静态世界建模
    
-   面向对象试图封装自己。
    
-   关系模型则倡导开放

 [实际上，在面向对象的数据库建模过程，实际上是二者互相妥协的过程](x-devonthink-item://C213396A-5F00-4308-9A95-723CD4A45B41?page=3)

### [1. 数据库建模导入](x-devonthink-item://C213396A-5F00-4308-9A95-723CD4A45B41?page=4)

-   在面向对象方法中，数据库建模，最佳实践应当是
    
-   1. 首先采用面向对象的方法分析和设计系统，用纯对象模型实现业务需求，*在这个过程中几 乎无须考虑数据库设计*
    
-   2. 在业务需求实现后，**定义那些需要持久化的对象(通常是实体对象 ，并为之建立数据模 型）**数据库设计 ，==并描述对象模型到关系模型的映射关系(OR-Mapping)==
    
-   3. 根据非功能性需求当中针对数据存取的性能要求(如数据量、吞吐量、并发程度等)来改 进那些需要特殊数据库设计的部分
    
-   4. 最后，针对功能性需求(高并发、大吞吐 ，或者特殊业务需求(海量数据查询、统计 进行特殊的数据库设计


### [2.关系数据模型](x-devonthink-item://C213396A-5F00-4308-9A95-723CD4A45B41?page=6)

- PK和FK
-   表和列:一个关系表示是一个或多个列的集合，每个列在表结构中有一个 唯一名称，并且定义一个特定基本数据类型，如数字、文本、二元数据
    
-   行为:以表相关联的行为通常是基于所应用实体的业务或逻辑规则
    
-   关系和识别:表的主键为识别提供一个特定值，一个表可以包含映射到另 一个表主键的“列
    
-   表间关系定义了一个外键，说明了这两个表之间的 结构关系或关联
    
### [3. UML数据模型](x-devonthink-item://C213396A-5F00-4308-9A95-723CD4A45B41?page=7)

[对上例进行增加，我们现在可以定义附加行为，如:触发器，约束，存储 过程](x-devonthink-item://C213396A-5F00-4308-9A95-723CD4A45B41?page=8)

[UML数据建模定义了两个表间任意一种依赖关系。它表示为一构造 型的关联并包括一组主键和外键](x-devonthink-item://C213396A-5F00-4308-9A95-723CD4A45B41?page=9)

### [4. UML数据模型与关系模型映射](x-devonthink-item://C213396A-5F00-4308-9A95-723CD4A45B41?page=10)

-   从类模型与关系模型的映射
	-   第一种情况:建立类模型，根据类模型优化数据关系模型
	-   第二种情况:在原有数据模型上，对类模型进行分层设计

1. 建立类模型 
2. 标识持久对象
3. *假设每一个持久类映射到一个关系表*

#### **[泛化关系映射](x-devonthink-item://C213396A-5F00-4308-9A95-723CD4A45B41?page=11)**

^786d6b

Q：[[Extract#^b58fae|对象之间的泛化关系映射到数据库表的几种策略]]

-   泛化(继承)可能是从面向对象模型转换到关系模型过程中最容易出现问题的关系和逻辑结 构。以下给出三种映射方法      

1. 一对一==每一个类层次结构有一个单独对应的表，这个表包含所有元素的继承属性。因此，这个表是该 层次结构中每个类的联合==。例如，人，父母，孩子和孙子可能形成一个单独的类层次结构，并且每个类中的元素都会出现在相同的关系表中。
2. ==类层次结构中的每一个类有一个对应的表，该表有仅能被该类访问的属性(包括继承属性)。 ==例如，如果“孩子”仅仅从“人”继承而来，表将仅包含“人”和“孩子”的元素
3. ==类层次结构中的每个类的自有属性对应一个表。==例如，“孩子”将映射到一个仅带孩子属性的 单个表


[1. 一对一（主外键关系）](x-devonthink-item://C213396A-5F00-4308-9A95-723CD4A45B41?page=12)
对于对象来说，一对一或一对多关联表示某个对象类型定义了另一个对象类型的实例变量(一 对一)或实例变量数组(一对多);==对于关系模型来说一对一关联表示某个实体的主键是另一个实 体的外键。==下图中两个一对一对象分别映射到两张表里，并且建立它们的主-外键关系。

[一对一（主外键）关系的不合理性详细解释](x-devonthink-item://C213396A-5F00-4308-9A95-723CD4A45B41?page=13)

[2. 多对多](x-devonthink-item://C213396A-5F00-4308-9A95-723CD4A45B41?page=14)
在数据库建模中多对多关联采用关联表的形式，在关联表里通过外键保存的方法，这时对象与数据表之间不再是一一对应的关系。

==[泛化关系映射](x-devonthink-item://C213396A-5F00-4308-9A95-723CD4A45B41?page=16)==

-   在关系数据库中，并没有泛化关系的定义，不能够直接映射
-   可以有两种映射策略

1. [第一种策略](x-devonthink-item://C213396A-5F00-4308-9A95-723CD4A45B41?page=16)：可以借用数据库一对一关系。当创建一个子对象时 ，OR-Mapping需要做的实际上是把一对一的父子表连接起来，同 时读取父表和子表的数据值，使得看上去子表“继承”了父表的 属性。
缺点:
- ==破坏封装性，子类也能看到父类全部内容==导致破坏了对象的封装性。因为我们无法在数据库里定义父表的某 一列是私有的，不能被子表看到。
- ==会将父对象属性值一并继承（静态属性处理）==对象的继承中，是继承对象的属性定义，但并未继承父对象的 属性值，除非这个属性是静态的(static)。上述做法实际上 把父对象的属性值也一并“继承”了。我们无法判断

2. [第二种策略](x-devonthink-item://C213396A-5F00-4308-9A95-723CD4A45B41?page=17)：把子对象映射为另一张表，这两张表毫 无关系，只不过子对象所对应的数据表冗余存储了父 对象所有的非私有属性。这样一来，实例化子类的时 候 OR-Mapping需要做的仅仅是读取子对象对应的数 据。这样，我们可以冗余父对象的私有属性，也可以 在子对象数据表里重新定义属性而实现所谓的重载

缺点:
- ==两个独立的表 父对象静态值改变时，子对象表无法改变==
- ==同样无法处理父对象静态属性的问题==
子对象继承的静态属性值，当父对象静态值改变时，子对象也应当同时改变。由于两张表毫无关系，子对象数据不可能知道父对象数据表里的静态属性值的改变。一种显而易见的办法，把静态属性保存在父表中。我们又遇到了第一种策略的老问题，无法判断哪些表里的哪些列是静态的，可以被子表读取，哪些不能。

[各种对象间关系的映射策略](x-devonthink-item://C213396A-5F00-4308-9A95-723CD4A45B41?page=18)

-   实现关系映射策略
    
-   聚合关系和组合关系的映射策略
    
-   依赖关系映射策略

### [5. 映射性能及实践原则](x-devonthink-item://C213396A-5F00-4308-9A95-723CD4A45B41?page=10)
1. 第一种办法，将上述四张表直接映射成课程对象，由OR-Mapping工具一次性生成课程表对象
2. 第二种办法，将上述四张表分别映射成课程表对象、课程对象、学生对象和老师对象
3. 第三种办法，将课程表对象直接映射到数据库里的课程表

[Page 21](x-devonthink-item://C213396A-5F00-4308-9A95-723CD4A45B41?page=20)

-   若业务数据没有强烈的关联共享需求
    
-   若某些数据有性能要求
    
-   若某个数据库存取具有极高的性能需求
    
-   若业务数据有强烈的关联共享需求

### [6. 数据库建模与类建模](x-devonthink-item://C213396A-5F00-4308-9A95-723CD4A45B41?page=21)
[数据库建模整体过程](x-devonthink-item://C213396A-5F00-4308-9A95-723CD4A45B41?page=23)

-   l数据库是一种最常用的数据留存的手 段，因此对于一个软件系统而言，要 保存的信息主要是实体类
    
-   l数据库的概念模型和软件的概念模型 是同时开发的，从某种意义上甚至可 以认为它们是同一个模型
    
-   l右图从类的概念模型到逻辑模型的演 化

[数据库物理建模](x-devonthink-item://C213396A-5F00-4308-9A95-723CD4A45B41?page=25) ^cc1633


[数据库建模(设计)有多重要](x-devonthink-item://C213396A-5F00-4308-9A95-723CD4A45B41?page=26)

