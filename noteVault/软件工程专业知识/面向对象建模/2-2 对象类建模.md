# [第5章-面向对象系统分析与对象类建模](x-devonthink-item://BECB1664-54C4-4497-B8EB-835928C1F571)


## [Review](x-devonthink-item://BECB1664-54C4-4497-B8EB-835928C1F571?page=1)
-   用例图组成三要素，参与者(Actor ，用例(User Case), 关系(Relationship
    
-   用例建模的步骤(系统边界、确定参与者、用例及之 间的关系、约束、注释、文档说明


## [Overview](x-devonthink-item://BECB1664-54C4-4497-B8EB-835928C1F571?page=3)

-   类图用于对系统的静态结构建模
    -   分析时用例模型作为输入，对用例模型进行分析，把系统 分解为相互协作的分析类，通过类图、对象图来描述对象 、对象的属性和对象之间的关系
    -   ==从用例图输入=>类图描述对象和属性间的关系==
    
-   面向对象分析产生分析模型
    
 [类图与其他图的关系](x-devonthink-item://BECB1664-54C4-4497-B8EB-835928C1F571?page=4)

## 类图
### [图符](x-devonthink-item://BECB1664-54C4-4497-B8EB-835928C1F571?page=6)

-   1.类的表示方法
    
-   有相同属性、操作、关系和语义对象的描述 类是任何面向对象系统中最重要的构造块，类是对一组具
    
-   一个类可以实现一个或多个接口
    
-   类可以是作为问题域一部分的抽象
    
-   也可以是构成实现的 类

[类的定义](x-devonthink-item://BECB1664-54C4-4497-B8EB-835928C1F571?page=7)

-   UML类图元素中类通常包含三个组成部分:类名、属性和服务(操作 (1) 类的定义

[类的范围](x-devonthink-item://BECB1664-54C4-4497-B8EB-835928C1F571?page=14)
-   特征的范围指的是类目的每一个实例都有自己独特的特征值，还是类 的所有实例都共同拥有单独一个特征值
    
-   ==类的实例范围==是指对于一个特征，类目的每个实例均有它自己的值。这是默 认的，不需要附加符号
    
-   ==类的静态范围==是指对于类目的所有特征，特征的值是唯一的，也把它称作类 范围，通过对特性串加下划线来表示。静态范围的特征大多用于私有属 性，它们必须为一个类的所有实例所共有

[类的分类——根据用户对类的定义方式不同区分](x-devonthink-item://BECB1664-54C4-4497-B8EB-835928C1F571?page=15)

-   具体类
-   抽象类
-   模板类

 [多重性——关联关系](x-devonthink-item://BECB1664-54C4-4497-B8EB-835928C1F571?page=16)

-   关联关系中还有一个重要的概念——多重性，指的是在关联关系中 一个类的多个实例与另一个类实例相关
[[2-1 UML语言与静态建模#^8e39fa|LINK-UML静态建模中的概念-约束]]

[对模板类的建模](x-devonthink-item://BECB1664-54C4-4497-B8EB-835928C1F571?page=18)

-   v 二是显式的 v 一是隐式的，即声明一个在其名称中提供了绑定的类 可以用两种方法对模板类的实例化进行建模
    
-   参数对目标模板进行实例化 即用一个被衍型化的bind的依赖，标明源端用实际参数对目标模板进行实例化

[在UML中对模板类建模>主动&非主动类](x-devonthink-item://BECB1664-54C4-4497-B8EB-835928C1F571?page=19)

-   ==主动类是指主动发起动作的类，是行为的发起者==
-    ==非主动类只是被动的被触发或者调用==，如线程的封装类就是一个主动类

[接口](x-devonthink-item://BECB1664-54C4-4497-B8EB-835928C1F571?page=20)

-   (6) 接口 u UML类图元素中接口是一系列操作的集合
    
-   它指定了一个类所提供的服务
    
-   接口既可用图标来表示，也可由附加了`<<interface>>`的一个标准类来 表示，它==直接对应于Java中的一个接口类型==

[版型](x-devonthink-item://BECB1664-54C4-4497-B8EB-835928C1F571?page=23)
[[2-1 UML语言与静态建模#^9b94f7|LINK-UML静态建模中的概念-版型]]
- 实体类
- 控制类
- 边界类

[边界类](x-devonthink-item://BECB1664-54C4-4497-B8EB-835928C1F571?page=24)

-   实体类通过事件流和交互图发现，采用目标领域术语命名
    
-   实体类与数据库中的表不一定是一一对应关系 通常实体类对应数据库中的表，其属性对应表的字段，但

[控制类](x-devonthink-item://BECB1664-54C4-4497-B8EB-835928C1F571?page=25)

-   控制类是负责管理或控制其他类工作的类
    
-   每个用例通常有一个控制类，控制用例中的事件顺序，控 制类也可以在多个用例间共用
    
-   控制较少接收消息，发出较多消息

[实体类](x-devonthink-item://BECB1664-54C4-4497-B8EB-835928C1F571?page=24)
- 实体类通过事任流和交互图发现，采用目标领域术语命名

- 通常实体类对应数据库中的表，其属性对应表的字段，但实体类与数据库中的表不一定是
一一对应关系


 [类图的抽象层次](x-devonthink-item://BECB1664-54C4-4497-B8EB-835928C1F571?page=26)

-   概念层
-   说明层
-   实现层

-   整个的类图的抽象层次是一个根据类内定义的完整程度==逐层递进的结构==

==**[对象的表示方法](x-devonthink-item://BECB1664-54C4-4497-B8EB-835928C1F571?page=27)**==

### 对象/类的关系

^acdbe9

**关联+依赖+泛化+实现**

#### [1. 关联关系](x-devonthink-item://BECB1664-54C4-4497-B8EB-835928C1F571?page=29)

-   1.关联关系
    
-   关联关系是实例之间的结构关系，分为一般关联、聚合 关联与组合关联

[聚合关系](x-devonthink-item://BECB1664-54C4-4497-B8EB-835928C1F571?page=37)

-   聚合关系是关联的一种形式，是强的关联关系。代表两个 类之间的整体/局部关系，如汽车类与引挚类、轮胎类之 间的关系就是整体与个体的关系
    
-   聚合关系描述了“has a”的关系，即整体对象拥有部分对 象，是一种不稳定的包含关系
    
-   较强于一般关联，有整体与局部的关系，并且没有了整体 ，局部也可单独存在

[组合关系](x-devonthink-item://BECB1664-54C4-4497-B8EB-835928C1F571?page=39)

-   组合关系是聚合关系中的一种特殊情况，是更强形式的聚合，又被称 为强聚合
    
-   组合表示contains-a的关系，是一种强烈的包含关系
    
-   组合类负责被组合类的生命周期，是一种更强的聚合关系，部分不能 脱离整体存在
    
-   组合关系是强聚合 部分脱离整体后无法单独存在

#### [2. 依赖关系](x-devonthink-item://BECB1664-54C4-4497-B8EB-835928C1F571?page=41)

^3bb99c
[发生依赖关系的情况](x-devonthink-item://BECB1664-54C4-4497-B8EB-835928C1F571?page=42)

-   依赖(Dependency)关系是对象之间最弱的一种关联方式，是临 时性的关联。代码中一般指由局部变量、函数参数、返回值建立的对 于其他对象的调用关系。一个类调用被依赖类中的某些方法得以完成 这个类的一些职责

[关联和依赖的区别](x-devonthink-item://BECB1664-54C4-4497-B8EB-835928C1F571?page=43)
- **关联更加静态 依赖更为动态**
-   v关联关系用一个直线表示，它在一定时间内将多个类的实例连接在一 起，关联关系是一种静态关系，通常与运行状态无关
    
-   v通常与运行状态无关，而是由常识、规则、法律等因素决定的，所以 关联关系是一种“强关联”的关系
    
-   v依赖关系表达的是对象间临时的、动态的关系。运行场景不同，依赖 关系也可能发生变化

#### [3.泛化关系](x-devonthink-item://BECB1664-54C4-4497-B8EB-835928C1F571?page=44)

^fd0083

-   泛化(Generalization)把==一般类连接到较为特殊的类==表示is a的关系，表示一个更泛化的元素和一个更具体的 元素之间的关系，==也称为继承关系==
    
-   泛化是对象之间耦合度最大的一种关系，子类继承父类的 所有细节，直接使用语言中的继承表达
    
-   泛化使用带空心三角箭头的实线段表示，箭头从子类指向 父类
-   **泛化后继承并还拥有自己扩展了的特征**

#### [4. 实现关系](x-devonthink-item://BECB1664-54C4-4497-B8EB-835928C1F571?page=46)
-   实现(Realization)关系在类图中就是接口和实现的关系

### [类图的构建](x-devonthink-item://BECB1664-54C4-4497-B8EB-835928C1F571?page=49)
确定系统类
-   常用的类识别方法有名词识别法、系统实体识别法、从用 例中识别类;用分解与抽象技术识别类和CRC卡分析方法
 
[组织类并确定关系](x-devonthink-item://BECB1664-54C4-4497-B8EB-835928C1F571?page=55)

-   关联关系表示不同类的对象之间的结构关系，它在一段时 间内将多个类的实例连接在一起
    
-   关联描述的是类的对象之间逻辑上的关系，这些对象可以 是同类的，也可以不是，关联的两端称为角色，如客户和 订单就存在一种关联

## [OO设计原则](x-devonthink-item://BECB1664-54C4-4497-B8EB-835928C1F571?page=59)

### [设计过程中注意的问题](x-devonthink-item://BECB1664-54C4-4497-B8EB-835928C1F571?page=68)
-   尽量减少消息模式的数目. 只要可能,使消息具有一致的模式, 以利于理解.
    
-   设计简单的类. 类的职责要明确, 不要在类中提供太多的服务, 应该从类名可以比较容易推断出用途.
    
-   泛化结构的深度要适当.
    
-   定义简单的方法. 一个方法内不要包含过多的功能.

---

## [对象图](x-devonthink-item://BECB1664-54C4-4497-B8EB-835928C1F571?page=77)
-   u对象图(Object Diagram)是表示在某一时刻一组对象以 及它们之间的关系的图，由结点以及连接这些结点之间的 连线组成
    
-   ==把类图实例化后得到对象图，对象图是包含在类图中的事 物的实例建模，是类图的一个特例，其表示方法也类似于 类图==
    
-   **它们的不同点在于对象图显示类的多个对象实例，而不是 实际的类**
    
-   *由于对象存在生命周期，因此对象图只能在系统某一时间 段存在*

### [对象图和类图的区别](x-devonthink-item://BECB1664-54C4-4497-B8EB-835928C1F571?page=81)

--- 

## [小结](x-devonthink-item://BECB1664-54C4-4497-B8EB-835928C1F571?page=82)

-   u类图的构建
    
-   u对象图的构建
    
-   u类是实体，但是类不是Actor，而是Actor使用系统时所调 用的实体，是处在系统边界之内的实体
    
-   在领域分析阶段 ，实体的属性并不重要，重要的是找出实体的操作
    
-   u实现类图和领域类图不一样，它描述的是真正系统的静态 结构，是和最后的代码完全一致的


---
基本概念  
用例图（Use Case Diagram）:用例图显示谁是相关的用户，用户希望系统提供什么服务（用例），以及用例之间的关系图。用例图主要的作用是获取需求、指导测试。

用例图的4个基本组件：参与者(Actor)、用例(Use Case)、关系(Relationship)和系统。

泛化(generalization)：泛化关系是一种继承关系，子用例将继承基用例的所有行为，关系和通信关系，也就是说在任何使用基用例的地方都可以用子用例来代替。泛化关系在用例图中使用空心的箭头表示，箭头方向从子用例指向基用例。

扩展(extend)： extend关系是对基用例的扩展，基用例是一个完整的用例，即使没有子用例的参与，也可以完成一个完整的功能。

extend的基用例中将存在一个扩展点，只有当扩展点被激活时，子用例才会被执行。 extend关系在用例图中使用带箭头的虚线表示(在线上标注<<extend>>)，箭头从子用例指向基用例。

包含(include)： include为包含关系，当两个或多个用例中共用一组相同的动作，这时可以将这组相同的动作抽出来作为一个独立的子用例，供多个基用例所共享。因为子用例被抽出，基用例并非一个完整的用例，所以include关系中的基用例必须和子用例一起使用才够完整，子用例也必然被执行。include关系在用例图中使用带箭头的虚线表示(在线上标注`<<include>>`)，箭头从基用例指向子用例。