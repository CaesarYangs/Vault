是一类特殊的搜索问题
由一组变量和变量之间的约束关系来定义

地图着色 考试安排 数独

## 地图着色问题
相邻州的颜色不一样
用约束图的情况来描述问题

### 约束的多样性
- 硬约束
软约束
### 回溯搜索
- 一次给一个变量赋值
- 当前进的时候检测约束
- 是一种深度优先搜索算法

变量和取值顺序
- 度启发式
- 最小约束值启发式


# 约束满足问题
- 是一类特殊的搜索问题
- 由一组变量和变量之间的约束关系来定义
- 地图着色
- 考试安排
- 数独

## 约束图
画约束图的目的：使问题具象化
- 二值CSP:每个约束关联至多两个变量 
- 二值约束图：节点是变量，弧表示约束
- 一般目的的CSP算法使用图结构来加速搜索

- 约束种类
一元约束：仅包含一个变量的约束
二元约束：包含两个变量的约束
- 约束的多样性
硬约束（强制条件）
偏好约束（软性的语句条件）
## 回溯搜索 Back tracking Search
解决CSP问题的重要解法
- CSP作为搜索问题 #搜索问题要点 
1. 初始状态：空的赋值 没有变量
2. 动作：添加一个赋值
3. 转移模型：如何给一个变量赋值且和前面的赋值不冲突
4. 目标测试：检测是否所有变量都被赋值以及所有约束都满足
5. 路径代价函数：路径有相同的代价

- 回溯搜索是用于解CSP问题的基本的无信息算法
- 一次给一个变量赋值，若n个变量，深度为n
- 当前进的时候检测约束
- #深度优先搜索 

## 提升搜索 Improving Backtracking

### Ordering 顺序
接下来该指定哪个变量？
以什么顺序来试它的值？ 

- 最简单：按照列表顺序{X1，X2，...，}选择未赋值变量，这种静态的变量排序很少能使得搜索高效
#### 最小保留值启发式 MRV
	即：选择有最少域的变量
	- MRV启发式对地图着色问题在初始时变量的选择没有帮助。
	先选择那些剩余选择域少的节点进行遍历
	- 优先选择在约束图中排除邻接变量的可选值最少的。这样能给剩下的变 量赋值留下最大的灵活性
#### 度启发式
	- 度启发式：选择涉及对其他末赋值变量的约束数最大的变量,来降低未来选择的分支因子。
	- 度:变量对其他未赋值变量的约束数

### Filtering 过滤-减小搜索空间
过滤：我们能否在更早期就监测到失败？
在变量取值前就发现矛盾，减少变量值的选择；也即减小搜索空间

- 主要方法：
减小搜索空间
在变量取值前就发现矛盾，减少变量值的选择；也即减小搜索空间
#### 前向检测
- 跟踪域中未分配的变量并删除和已有选择不相容的选项 
- 前向检测传播信息从指定变量到未指定变量，但是并不提供对所有失败的早期的检测
#### 约束传播
一个简单形式的传播就能确保所有的弧都是相容的
- 约束传播：将一个变量的约束传播到另一个变量
- 节点相容
	- 当在一个变量的值域中的所有的值都满足变量的一元约束时，我们称为节点相容
- 弧相容——最常用
	- 当在一个变量的值域中的所有的值都满足变量的一元约束时，我们称为节点相容
	- 检查两个节点之间的相容关系 针对前向和反向进行两次检查 确保一定的相容性
- k相容 #应该再详细复看 
	- 更强的相容检验
	- k越大则计算开销也大
	- 基本无需再进行回溯 开销很大
#### 智能回溯
-  倒退回导致失败的变量集合（冲突集）中的一个变量
- 变量X的冲突集是通过约束和X相连接的先前 已赋值变量的集合
- 不是回溯到时间上最近的变量去修改 而是直接回溯到真正导致它失败的根源节点
- 冲突集

### Structure 结构
结构：我们能否利用问题的结构？

#### 极端情况：独立子问题
#### 树形结构CSP
- 其中任何两个节点之间都只有一条路径可以到达 
- 树状结构的CSP问题可以在变量个数的线性时间内求解 
- 定理：如果约束图没有环，则CSP能在O(n d2) 次时间内被求解（n为变量数，d为
值域的大小）
**针对树结构问题的解法**
1.  顺序：选择一个根变量，并排序变量使得孩子节点都排在父节点之后
 2.  从后向前：应用弧相容性检测，移除不相容值 
 3.  从后向前赋值
 - 推论1：在每个回溯过程，所有的由根到叶的弧都是相容的
	 证明：每个X->Y 在某点是相容的并且Y的域不能再减少了（因为Y的孩子在Y之前处理）
 - 推论2：如果根到叶的弧是相容的，前向的赋值无需回溯 
#### 近似树形结构CSP
- 调整：初始化一个变量，删除它的邻域变量中不相容的值
-  割集调整：从CSP选择子集S，S称为环割集，初始化一些子集S变量的集合，以使得剩下的约束图成为一棵树
- 即：先处理那些使得成环的节点 处理后再去分别看后续其余是树形结构的节点
- 原问题分解成两部分求解：割集求解和剩下的树求解。先求解到割集的解，再删除剩下变量的矛盾 值，若剩下变量还有值可取，就形成树进行求解。两部分的值合在一起得到原问题的解。

#### 树分解
分割成几个部分的小问题
- （将问题分解为相关联的子问题；每个子问题独立求解，再把得到的结果合起来）
- 子问题之间的约束要求共享变量取一样的值
 