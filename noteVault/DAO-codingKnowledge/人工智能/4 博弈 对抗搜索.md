# 5 对抗搜索问题
--- 
#重新整理和回顾#
## 博弈
讨论的是竞争环境
我们在本章研究有完整信息的，确定性的，轮流行动的零和博弈。
即：
> 零和博弈
> 同样的棋局实例的情况下，所有棋手的总收益都一样的情况

- 搜索问题描述：
一个状态空间 一个开始状态 一个后继函数 一个目标状态测试 耗散函数 #搜索问题要点

- 博弈环境下的组成部分：
初始状态 转移模型 终止测试 效用函数

概念解释：
- 剪枝：允许在搜索树中忽略不影响最后决定的部分 
- 评估函数：允许在不进行完全搜索的情况下估计某状态的真实效用值

### 博弈树
**博弈树就是一棵与或树**

MAX：OR或结点：表示在当前状态下，MAX可能的走棋招数
MIN：AND与结点：表示MIN可能的走棋招数
利用极小极大算法为MAX一方提供最大走棋招数
- 初始状态，actions函数和results函数定义了游戏的博弈树

### 优化策略
什么是优化策略？
即：最优解达到目标状态的一系列行动。终止状态即为获胜。
- 给定一棵博弈树，最优策略可以通过检查每个节点的极小极大值来决定
- 节点的极大极小值就是对应状态的效用值

## 极小极大算法
#应该再详细复看
- 极小极大值：最优策略在每一个节点的检查值
注：极小极大值指的是一种表示，根据目标状态的情况决定。有可能是小的，也有可能是大的。

![博弈树](http://blogstorage.cyang.site/AI_Class/c7/game_tree-1)
深度为1步的博弈树。包括两个单方招数，每个单方招数为1层。
- 给定一棵博弈树，最优策略可以通过检查每个结点的极小极大值来决定，记为MINMAX(n)
- 假设两个游戏者始终按照最有策略行棋，则结点的极小极大值就是对应状态的效用值
- 对给定的选择，MAX喜欢移动到有极大值的状态，而MIN喜欢移动到有极小值的状态。

**算法的主要理论**
- 极小极大算法就是对博弈树进行极小极大寻找。
选取每个节点下一个目标的最好状态。如：max选择极大值
使用简单的递归算法计算每个后继的极小极大值。
递归算法自上而下一直前进到树的叶节点，随着递归回溯通过搜索树把极小极大值回传

- 为了找到当前的最优行动方案,需要对各个方案的后果进行比较.具体地说就是要考虑每一种方案实施后对方可能采取的所有行动,并计算可能的得分
- 为了计算得分,需要根据问题的特征信息定义一个**估价函数**,用来估算当前博弈树端节点的得分。

**算法的主要实施方案**
- **极小极大方法在端节点的估值计算出来后,再推出父节点的得分.**推算方法是:
	- 对MAX（或）节点选其子节点中一个最大的得分作为父节点的得分,即从自己可供选择的方案中选择对自己最有利的一个
	- 对MIN（与）节点选其子节点中最小的一个的得分作为父节点的得分,即立足于最坏的情况.
这样计算出来的父节点的得分称为倒推值
- **如果一个行动方案能获得较大的倒推值,则它就是当前最好的行动方案(这里启发式函数计算的是得分而不是代价)**
- 极小极大算法对博弈树进行完整的深度优先搜索。

*多人博弈的极小极大算法*
- 即：用向量值替换每个结点上的单一效用值

### 极小极大算法的性质
- 极小极大算法表现为博弈树的深度优先搜索 #深度优先搜索 
- 时间复杂度
- 空间复杂度
- 若树的最大深度为m，每个结点的合法行棋有b个

**极小极大搜索的问题**
- 随着树的深度增加，博弈状态的数量呈指数级增加
- 我们无法消除这种指数，但是我们能有效的将它剪掉一半=>引出剪枝算法

## Alpha Beta剪枝
- a-b剪枝搜索是极大极小方法的改进,剪掉那些不影响决策的分支，是一种提高博弈树搜索效率的方法
- a-b剪枝搜索是一种边生成节点,边计算估值和倒推值的方法,从而剪去某些分枝.

![剪枝图](http://blogstorage.cyang.site/AI_Class/c7/ab_prunning-1)

以极小极大算法的形式遍历博弈树。最坏情况等于极小极大算法。

### 实际算法步骤
- 对于一个“与”节点(MIN节点),它取当前子节点中的最小的倒推值作为它的倒推值的上界,称此值为b值.也就是说b值可以等于其后继节点当前最小的最终倒推值.“与”节点的b值是永远不会增加的
- 对于一个“或”节点（MAX节点）,它取当前子节点中得最大的倒推值作为它的倒推值的下界,称此值为a值.也就是说a值可以等于其后继节点当前最大的最终倒推值.“或”节点的a值是永远不会减少的.

**剪枝规律**：
- 任何“或”节点x的a值如果不能降低其父节点的b值,则对节点x其余的分枝可以停止搜索,并使x的倒推值为a.这种技术称为b剪枝
- 任何“与”节点x的b值如果不能升高其父节点的a值,则对节点x其余的分枝可以停止搜索,并使x的倒推值为b.这种技术称为a剪枝
> 要进行a-b剪枝,至少必须使某一部分的搜索树生长到最大深度.因为a和b值必须以某个端节点的静态估值为依据.因此采用a-b过程都要使用某种深度优先的搜索方法.

### 算法性质
- Alpha-Beta  prunning  可用于任意深度的树，并且常常可以剪去整个子树而不仅仅是叶节点
- 剪枝并不影响最后的结果
- 好的孩子节点序列可以改进剪枝的效率
- 时间复杂度：

### 
- **Alpha Beta剪枝**是一种对极小极大算法的深度优化策略。能有效地将搜索空间减半。
是极大极小方法的改进,剪掉那些不影响决策的分支，是一种提高博弈树搜索效率的方法
是一种边生成节点,边计算估值和倒推值的方法,从而剪去某些分枝.
**通过减少搜索空间提高效率**
> 当算法评估出某策略的后续走法比之前策略的还差时，就会停止计算该策略的后续发展。该算法和极小化极大算法所得结论相同，但剪去了不影响最终决定的分枝。

- 用另一种理解来表示：
> 对手发现可以给我们一个比我们当前可获得最大收益值更小的值时，触发剪枝。
> 我们发现可以获得一个比我们当前获得最小收益值更大的值时，触发剪枝。

**由于极小极大算法是深度优先的，所以任何时候都只需考虑树中某条单一路径上的节点**

## 评价函数（估值函数）
- 博弈程序严重依赖于估值函数
- 不准确的估值函数可能会导致Agent走向失败
- 估值函数对终止状态的排序应该和真正的效用函数一样：赢的估值一定要好于平局的估值，而平局的估值应好于输的估值。
- 估值函数计算不应太长时间
- 对于非终止状态，估值函数应该和取胜几率密切相关
**设计思想：考虑状态不同的参数特征**

- 评价函数在有限深度搜索时评分非终止结点
- 理想的函数: 返回该位置实际的 minimax 值
- 在实际中: typically典型的采用特征的线性加权和

引入期望概念进行情况估计。

## 随机博弈
最坏的情况和平均情况：不确定的结果由随机控制，而非由对手控制

- 引入**期望**的概念
一个随机变量的期望值函数是基于概率分布对所有可能结果的加权平均
- 引入**机会节点**概念，考虑平均概率更高的情况。
> 意味着在随机博弈的情况下，另一方无法知道我们在棋局中的标准博弈树

所以要引入期望概念
计算棋局的期望值来进行计算和估计。

## 蒙特卡洛搜索算法 MCTS
alphaGO的核心部件包括：蒙特卡洛树搜索 残差网络 强化学习
- 蒙特卡洛算法是一大类概率算法，它返回的是一系列解的近似。
- 根据模拟的结果来构造博弈搜索树
- MCTS模拟游戏很多次，并基于模拟结果来预测最好的移动

### 单一状态蒙特卡洛规划：多臂赌博机(multi-armed bandits)
- 是一种序列决策问题，需要在探索（exploration）和利用(exploitation)之间找到一种平衡
- 探索exploration  ：寄希望在未来能获得更大回报
- 利用exploitation  ：在过去决策中获得的最佳回报
**置信度上界（upper confidence bound，UCB）**
UCB算法是在探索和利用之间寻找平衡
### 蒙特卡洛树搜索（Monte-carlo tree search）
- 将限置信上界（UCB）算法应用于博弈树的搜索中，即为蒙特卡洛树搜索算法
- 包含四个步骤：选择（selection），扩展（expansion）,       模拟（simulation），反向传播（Back-propagation）
- 具体来说，通常用UCB(upper confidence bound)选择最具潜力的节点


> **蒙特卡罗方法**（英语：Monte Carlo method），也称**统计模拟方法**，是1940年代中期由于科学技术的发展和[电子计算机](https://zh.wikipedia.org/wiki/%E7%94%B5%E5%AD%90%E8%AE%A1%E7%AE%97%E6%9C%BA "电子计算机")的发明，而提出的一种以概率统计理论为指导的数值计算方法。是指使用[随机数](https://zh.wikipedia.org/wiki/%E9%9A%8F%E6%9C%BA%E6%95%B0 "随机数")（或更常见的[伪随机数](https://zh.wikipedia.org/wiki/%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0 "伪随机数")）来解决很多计算问题的方法。

- 置信度上界

- 将置信上界算法应用于博弈树的搜索中，即为蒙特卡洛搜索算法
- 选择 扩展 模拟 反向传播