## outline
- 问题求解Agent：
基于目标的Agent的一种[[1 Agent#Agent程序类别]]
- 当问题求解不能通过一个单个行动完成时,Agent如何找到一组行动序列达到目标。
> 搜索即是指从问题出发寻找解的过程

## 求解步骤
### 任务环境
[[1 Agent#任务环境的性质]]
- 完全可观察
- 单Agent 
- 确定的
- 延续式的
- 静态的
- 离散的
- 已知的
### 问题求解 Problem Solving
- 表示(Problem formulation)
	- 无信息搜索(Uninformed Search)
		- Depth-First Search (深度优先搜索)
		- Breadth-First Search(广度优先搜索)
		- Uniform-Cost Search(均匀造价搜索)
- 搜索(Searching)
	- 有信息搜索(Informed Search)
		- A算法
		- A*算法
---

## 搜索问题的表示：状态空间表示法
- 状态
environment(agent和它的环境的一个配置)
- 状态空间
actions(从初始状态开始通过一系列的操作可以到达的所有状态的集合,称为状态空间)
- 可由状态空间图来表示,状态空间图是一个有向图

状态空间表示：
1. initial state(初始状态)：Agent开始时所在的状态
2. actions (行为)：在某个状态下agent可采取的行动 返回agent能在状态s的可执行行动的集合
3. transition model(转移模型)：对于在任意一个状态下采取了某个可行的行动后，会转移到的结果状态的描述
4. goal test(目标测试)：确定某个给定状态是否是目标状态
5. path cost function(路径耗散函数)：同一个给定路径相关联的代价（耗散）值

使用完整的状态空间表示法表示一个具体要解决的问题 #考点-人工智能
形式化相应的问题 画出对应的状态空间图 #考点-人工智能 
e.g. 传教士和野人问题 #考点-人工智能 

## 搜索 概念
- 搜索算法输入的是问题,输出的是问题的解
- 以行动序列的形式返回问题的解
- 一旦找到解,所建议的行动就付诸实施,即“执行阶段”
- 问题解决Agent的设计:形式化、搜索、执行

### 搜索树
- 搜索树是由初始状态和后继函数共同产生的,同时也定义了状态空间。
- 一般来说,当同一个状态可以从多条路径到达时,我们会得到一个搜索图而非搜索树。



# 无信息搜索
> 除了问题定义中提供的状态信息外，不使用和问题有关的具体知识的搜索策略

- 特点：           
搜索过程中不使用与问题有关的经验信息                    
搜索效率低                    
不适合大空间的实际问题求解

## 树/图搜索方法

## 深度优先搜索
- 总是先扩展frontier表中最深的节点
- frontier是一个栈结构

性能：
- 沿着一支跟踪下去
- 防止搜索过程沿着无益的路径扩展下去，往往给出一个节点扩展的最大深度——深度界限。
- 算法的空间复杂度要优于时间复杂度
- 与广度优先搜索算法最根本的不同在于：将扩展的后继节点放在frontier表的前端
- 不一定能找到解？


## 广度优先搜索
- 总是先扩展frontier表中最浅的节点
- frontier是一个队列结构

性能：
- 一种高代价搜索，但若有解存在，则必能找到它。

## 搜索算法的性能
- 完备性：
当问题有解时，算法是否保证找到一个解
- 最优性：
算法是否能找到一个最优解（路径代价函数最小的路径）
- 时间复杂性：
找到一个解需要花多少时间
- 空间复杂性：
在搜索过程中需要占用多少内存

### DFS
- 完备性：否；除非搜索空间是有限的，并且不出现循环
- 时间复杂性：1 + b + b2 + …. bm = O(b^m)
- 空间复杂度：O(bm)，线性空间
- 最优性：否

### BFS
- 完备性：是 如果解存在，s必须是有限的
- 最优性：如果每步扩展的代价相同，则找到的解为最优
- 时间复杂度：搜索时间O(b^s)
- 空间复杂度：O(b^s)

## 改进算法
### 有界深度优先搜索
预先设置一个深度界限l,也即深度为l的节点 认为没有后继节点
### 迭代加深的深度优先搜索
- 对空间进行一种深度界限为1的深度优先搜索
- 如果不能找到目标，它便进行另一个深度界限为2的深度优先搜索
- 这样进行下去，每次迭代把深度界限加1 
- 在每次迭代中，算法执行一次当前深度界限范围内的完全深度优先搜索
- 在两次迭代之间不保存任何状态空间信息

## 一致代价搜索
> BFS  总是扩展最浅的结点，认为路径耗散值都相等.它并不寻找最小代价路径.   下面这个算法和BFS相似，寻找最小代价路径。

- 策略: 首先扩展一个cheapest node
- Frontier表是一个优先级队列 (priority: 累积代价)

- 优点: 
UCS是完备和最优的
- 缺点:
探索在所有“方向” 展开
对于目标的定位没有任何先验信息


# 有信息搜索
> 使用和具体问题相关的知识来更加高效的寻找解决方案的搜索策略
> 知道一个状态是否比其他状态“更有希望”接近目标的策略称为有信息搜索

- 算法的核心是一个“启发函数” 
- 引入估价函数来估计节点位于解路径上的“希望”，函数值越小“希望”越大
- 搜索过程按照估价函数的大小对OPEN表进行排序，每次选择估价函数值最小的节点作为下一步考察的节点
- 统一到“最佳优先搜索”框架下，也称有序搜索

## 贪婪最佳优先搜索
> 搜索算法首先扩展最接近目标的节点，通过一个启发函数h(n)来预测节点是否接近目标

- 贪婪最佳优先搜索启发函数：
先扩展那些看起来距离目标最近的节点

- 策略：
扩展一个你认为最接近目标状态的节点
- 启发：
对每个状态预测到最近目标的距离
- 通常情况：
找到的解不一定是最优解
有时可能会找不到解
- 最坏情况：
类似于一个最差引导的深度优先搜索


## A*搜索
> 综合了一致代价搜索和贪婪搜索

**估计代价**
**f(n) = g(n) + h(n)**
其中f(n)是节点n的估价函数，g(n)实在状态空间中从初始节点到n节点的实际代价，h(n)是从n到目标节点最佳路径的估计代价。

- 可采纳性条件
如果一个估价函数可以找出最短的路径，我们称之为可采纳性。A* 算法是一个可采纳的最好优先算法。
可以找出最短路径=可采纳
- 一致性条件
从节点n到达目标的估计代价，不大于从节点n到后继节点n’的代价和n’到目标的代价之和。

**其实广度优先算法就是A* 算法的特例。即最坏情况的广度优先算法**

## 启发函数
