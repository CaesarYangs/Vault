# Intro
#第一遍阅读
CPU 是计算机系统中十分重要的资源。

但在早期的计算机系统中，对它的管理是十分简单的。因为那时它和其他系统资源一样，为一个作业所独占，不存在处理机分配和调度问题。

随着多道程序设计技术和各种不同类型的操作系统的出现，各种不同的 CPU 管理方法得到启用。不同的 CPU 管理方法将为用户提供不同性能的操作系统。例如，在多道批处理系统中，为了提高处理机的效率和增加作业吞吐率，当调度一批作业组织多道运行时， 要尽可能使作业搭配合理，充分利用系统中的各种资源。在分时系统中，由于用户使用交互式会话的工作方式，系统必须要有较快的响应时间，使得每个用户都感到如同只有自己一人在使用这台计算机。

因此，系统在调度作业执行时，首先考虑的是每个用户作业得到处理机的均等性。在实时系统中，首先要考虑的是处理机的响应时间。由此可见，操作系统的要求不同，处理机管理的策略是不同的。

常见的几个衡量调度策略的指标：
- 周转时间
一个作业提交给计算机系统后到该作业的结果返回给用户需要的时间。
- 吞吐率
给定的时间内，一个计算机系统完成的总工作量。
- 响应时间
用户向计算机发出一个命令到计算机把相应的结果返回给用户所需的时间。
- 设备利用率
输入输出设备的使用情况。

==以 CPU 管理为核心，管理和控制用户进程的方法==

**Outline**
- 作业与进程的关系
- 作业调度算法
- 进程调度算法
- 几种调度算法的评价

# 分级调度
## 作业状态及转换
[[2 操作系统用户界面#作业|第 2 章]]介绍了作业的概念。作业是用户要求计算机所做的关于一次业务处理的全部工作，它包括作业的提交、执行和输出等过程。
**一个作业从用户提交开始到占有处理机被执行，要由系统经过多级调度才能实现**（在有些系统，例如分时系统中，也可以由单级调度实现）。

![](https://inotgo.com/imagesLocal/202112/28/202112280435103637_6.jpg)

4 个状态：
- 提交
处于提交状态的作业，因其信息尚未全部进人系统，所以不能被调度程序选取。
- 收容（后备）
收容状态也称为后备状态。输入管理系统不断地将作业输入到[[2 操作系统用户界面#spooling 系统|外存中的对应部分（或称输入井，即专门用来存放待处理作业信息的一组外存分区)]]。若一个作业的全部信息已全部被输入进输入井，那么，在它还未被调度去执行之前，该作业处于收容状态。
- 执行
作业调度程序从后备作业中选取若干个作业到内存投入运行。它为被选中作业建立进程并分配必要的资源，这时，这些被选中的作业处于执行状态。从宏观上看，这些作业正处在执行过程中；但从微观上看，在某一时刻，由于处理机总数少于并发执行的进程数，因此， 不是所有被选中作业都占有处理机，其中的大部分处于等待资源或就绪状态中。那么，**究竟哪个作业的哪个进程能获得处理机而真正在执行，要依靠进程调度来决定。**
- 完成
当作业运行完毕，但它所占用的资源尚未全部被系统回收时，该作业处于完成状态。在这种状态下，系统需做诸如打印结果、回收资源等善后处理工作。

## 调度层次
处理机调度问题实际上是处理机分配问题。
*哪些作业的哪些进程可以参加竞争处理机？*
- 本质： 处于就绪状态的处理机
    - **内存就绪状态**
        - 即参与竞争处理机所必须的资源都已经得到了满足的进程。
        - 在进程有资格竞争处理机之前，作业调度程序必须先调用存储管理和外设管理程序，并按一定的选择顺序和策略从输入井中选择出几个处于后备状态的作业，为它们分配内存等资源和创建进程，使它们获得竞争处理机的资格。
    - **外存就绪状态**
        - 由于处于执行状态下的作业一般包含多个进程，而在单机系统中，每一时刻只能有一个进程占有处理机。那么，其他进程就只能处于准备抢占处理机的就绪状态或等待得到某种新资源的等待状态。为了提高资源的利用率，在有些操作系统中把一部分在内存中处于就绪状态或等待状态而在短时期内又得不到执行的进程、作业换出内存，以让其他作业的进程竞争处理机。这样，在外存中，除了处于后备状态的作业外，还存在处于就绪状态而等待得到内存的作业。这就需要有一定的方法和策略为这部分作业分配空间。
        - 涉及到交换调度的部分

**调度层次：**
- **作业调度**
    - 主要针对批处理系统，[[1 计算机系统概述#分时操作系统|分时系统]]没有作业的概念。
    - 又称宏观调度或高级调度。其主要任务是按一定的原则对**外存输入井上的大量后备作业进行选择**，给选出的作业分配内存和输入输出设备等必要的资源，并建立相应的根进程，以使该作业的进程获得竞争处理机的权利。
    - 当该作业执行完毕时，还负责回收系统资源。

- **交换调度**
    - 又称中级调度。其主要任务是按照给定的原则和策略，**将处于外存交换区中的就绪状态或等待状态的进程调入内存**，或把处于**内存就绪状态或内存等待状态的进程交换到外存交换区**。
    - 交换调度主要涉及内存管理与扩充，因此，在有些书中也把它归入内存管理部分。

- **进程调度**
    - 又称微观调度或低级调度。其主要任务是按照某种策略和方法**选取一个处于就绪状态的进程占用处理机。**
    - 在确定了占用处理机的进程之后，系统必须进行**进程上下文切换**以建立与占用处理机进程相适应的执行环境。

- **线程调度**
    - 略

在多道批处理系统中，存在着作业调度和进程调度。但是，<u>在分时系统和实时系统中， 一般不存在作业调度，而只有进程调度、交换调度和线程调度。</u>

*为什么分时系统没有作业调度？*
这是因为在分时系统和实时系统中，为了缩短响应时间或为了满足用户需求的截止时间，**作业不是建立在外存，而是直接建立在内存中**。在这些系统中，一旦用户和系统的交互开始，用户马上要进行控制。因而，这些系统中没有作业提交状态和后备状态。它们的输入信息经过终端缓冲区为系统所接收，或者立即处理，或者经交换调度暂存于外存中。

<u>即：分时系统中的“作业”直接建立在内存中，不需要通过作业调度这个过程进行；仅在执行过程中通过交换调度将不需要占用处理机的进程换出内存。</u>

## 作业与进程的关系
作业可被看作是用户向计算机提交任务的**任务实体**，例如一次计算和一个控制过程等。
进程则是计算机为了完成用户任务而设置的**执行实体**，是系统分配资源的基本单位。

显然，计算机要完成一个任务实体，必须要有一个以上的执行实体。==也就是说，一个作业总是由一个以上的进程组成。==

*作业怎样分解为进程？*
系统创建根进程，根据任务要求，系统或根进程为其创建相应子进程；最后为各个子进程分配资源和调度子进程执行以完成作业要求的任务。

# 作业调度
其完成的是作业从后备状态到执行状态的转变，以及从执行状态到完成状态的转变。

**作业调度的本质：是对除 CPU 之外的所有系统硬件资源的分配。**
## 作业调度功能
- **记录系统中各作业的状况，包括执行阶段的有关状况。**
    - 为每个作业建立 JCB
    - 确定当前作业的执行状态
- **从后备队列中挑选出一部分作业投入执行。**
    - 系统中处于后备状态的进程很多，取决于外存输入井的大小。
    - 作业调度程序根据相应的作业调度算法选择相应的作业投入执行。
- **为被选中作业做好执行前准备工作。**
    - 为选中的作业建立相应的进程；并为这些进程分配相应的系统资源如内存，外存和外设。
- **在作业执行结束后做好善后工作。**
    - 输出作业管理信息
    - 回收作业占有的系统资源，撤销进程和作业的控制块

## 作业调度目标
*怎样从后备队列挑选一批作业进入执行状态呢？*
**作业调度的主要目标：**
1.  对所有作业公平合理
2.  应使设备有高的利用率
3.  每天执行尽可能多的作业
4.  有快的响应时间

## 作业调度性能衡量
**周转时间**
$$ T_i = 作业完成时间 - 作业提交时间$$
$$ T_i = T_w + T_r$$
即等待时间+执行时间

**平均周转时间**

**带权周转时间**
为了进一步反应调度性能，引入了带权周转时间的概念。
带权周转时间是作业周转时间与作业执行时间之比。
$$ W = T_i \ / \  T_r$$
**平均带权周转时间**

对于分时系统，除了要保证系统吞吐量大、资源利用率高之外，还应保证有用户能够容忍的响应时间。因此，在分时系统中，仅仅用周转时间或带权周转时间来衡量调度性能是不够的。

# 进程调度
无论是在批处理系统、分时系统还是实时系统中，<u>用户进程数一般都多于处理机数</u>，这将导致用户进程互相争夺处理机。另外，系统进程也同样需要使用处理机。<u>这就要求进程调度程序按一定的策略，动态地把处理机分配给处于就绪队列中的某一个进程，以使之执行。</u>

==进程调度本质——选择一个合适的进程占据处理机==
## 进程调度功能
- **记录系统中所有进程的执行情况**——通过 PCB
    - 将系统中各进程的执行情况和特征记录在 PCB 中；并将其进行动态队列转接。
    - 进程调度模块通过 PCB 掌握进程状态信息从而做出选择占据处理机的进程。
- **选择占有处理机的进程**——利用进程调度算法
    - 进程调度的主要功能便是按照一定的策略选择一个处于就绪状态的进程，使其获得处理机并执行。
    - 根据不同的系统设计目的，有不同的调度算法或策略可供选择：静态优先级调度法；Round Robin；多级反馈轮转法等。这些选择策略决定了调度算法的性能。
- **进行进程上下文切换**
    - 检查是否可以进行上下文切换
    - 保存信息
    - 选择一个处于就绪状态的进程进行装配。

## 进程调度时机
*何时进行进程调度？*
与引起进程调度的原因与其调度方式有关。

> (1)正在执行的进程执行完毕。这时，如果不选择新的就绪进程执行，将浪费处理机资源。
> (2)执行中进程自己调用阻塞原语将自己阻塞起来进入睡眠等待状态。
> (3)执行中进程调用了 P 原语操作，从而因资源不足而被阻塞；或调用了 V 原语操作激活了等待资源的进程队列。
> (4)执行中进程提出 I/O 请求后被阻塞。
> (5)在分时系统中时间片已经用完。
> (6)在执行完系统调用，在系统程序返回用户进程时，可认为系统进程执行完毕，从而可调度选择一个新的用户进程执行。
> 以上都是在 CPU 执行不可剥夺方式下所引起进程调度的原因。在 CPU 执行方式是可剥夺时，还有以下的原因：
>  (7)就绪队列中的某进程的优先级变得高于当前执行进程的优先级，从而也将引发进程调度。

- 可剥夺式：就绪队列中一旦有优先级高于当前执行进程的优先级，立即发生进程调度。
- 不可剥夺式：即使在就绪队列中存在优先级更高的进程，当前进程仍继续占有处理机直到进程自己因种种原因发生调度让出处理机。

**OS 中以下五种情况会发生进程调度：**
- 当前进程自己调用 sleep 和 wait 进入睡眠状态时
- 但前进从系统调用执行结束后返回用户态时，其优先级低于其他就绪状态进程
- 当前进程完成中断和陷阱处理后返回用户态时，其优先级低于其他就绪状态进程
- 时间片用完，且当前进程优先级低于其他就绪进程
- 当前进程调用 exit 自我终止时

# 调度算法
讨论各种进程调度算法及作业调度算法
## FCFS
先来先服务

将用户作业和就绪进程按提交顺序或变为就绪状态的先后排成队列，并按照先来先服务(First Come First Serve,FCFS)的方式进行调度处理，是一种最普遍和最简单的方法。

在没有特殊理由要优先调度某类作业或进程时，从处理的角度来看，FCFS 方式是一种最合适的方法，因为无论是追加还是取出一个队列元素在操作上都是最简单的。

直观看，该算法在一般意义下是公平的。即每个作业或进程都按照它们在队列中等待的时间长短来决定它们是否优先享受服务。不过对于那些执行时间较短的作业或进程来说，如果它们在某些执行时间很长的作业或进程之后到达，则它们将等待很长的时间。

在实际的操作系统中，尽管很少单独使用 FCFS 算法，但和其他一些算法配合起来， FCFS 算法还是使用得相当多的。例如，基于优先级的调度算法就是对具有同样优先级的作业或进程采用的 FCFS 方式。
## Round Robin
轮转法的基本思路是***让每个进程在就绪队列中的等待时间与享受服务的时间成比例。***

<u>轮转法最重要的要点是利用了分时操作系统中的时间片思想</u>

- **时间片思想**
    - 轮转法的基本概念是将 CPU 的处理时间分成固定大小的时间片。
    - 如果一个进程在被调度选中之后用完了系统规定的时间片，但未完成要求的任务，则它自行释放自己所占有的 CPU 而排到就绪队列的末尾，等待下一次调度。同时，进程调度程序又去调度当前就绪队列中的第一个进程或作业。

轮转法只能用来调度分配那些可以抢占的资源。将他们随时剥夺再分配给别的进程。CPU 属于可抢占的一种；打印机便属于不可抢占的资源。

> **作业调度的本质：是对除 CPU 之外的所有系统硬件资源的分配。**
——而作业调度中包含了对不可抢占资源的分配。所以作业调度不适用轮转法。

- **轮转法时间片的选择**
    - 时间片长度的选择会直接影响系统开销和响应时间。
    - 如果时间片长度过短，则调度程序剥夺处理机的次数增多，这将使进程上下文切换次数也大大增加，从而加重系统开销。
    - 反过来，如果时间片长度选择过长，比方说一个时间片能保证就绪队列中所需执行时间最长的进程能执行完毕，则轮转法退化为了 FCFS。

## Round Robin with Multiple Feedback
利用不同的到达时间和所需服务时长分为不同的就绪队列，每个队列按照 FCFS 方式排列；各队列间享有不同的优先级。同一队列内优先级相同。

当一个仅执行完其时间片，或被唤醒以及被创建后，将进入不同的就绪队列。

- **轮转法加入就绪队列的三种情况**
    - 分给进程的时间片用完，但进程还未完成，回到就绪队列的末尾等待下次调度继续执行。
    - 分给该进程的时间片未用完，只是因为请求 I/O 或由于进程的互斥与同步关系而被阻塞。当阻塞解除之后再回到就绪队列。
    - 新创建进程进入就绪队列。

- 算法细节
    - 设置多级就绪队列，各队列优先级从高到低，时间片从小到大。
    - 新进程到达时先进入第 1 级队列，按照 FCFS 原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经在最下级的队列，则重新放回该队列队尾。
    - 只有第 K 级队列为空时，才会为 K+1 级对头的进程分配时间片

![](https://img-blog.csdnimg.cn/0fb88e027ced440d84a3cf53fc350230.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4oCNb09vT29Pb29PTw==,size_20,color_FFFFFF,t_70,g_se,x_16)

- **根据就绪原因给予不同优先级改善效率**
    - 将就绪队列按照进程到达就绪队列的类型和进程被阻塞时的阻塞原因分成不同的就绪队列
    - 每个队列按 FCFS 原则排列，各队列之间的进程享有不同的优先级，但同一队列内优先级相同
    - 当一个进程在执行完它的时间片之后，或从睡眠中被唤醒以及被创建之后，将进入不同的就绪队列。

- 多级反馈轮转法与优先级法的区别：
    - 一个进程在执行结束前，可能需要反复多次通过反馈循环执行。
    - 而不是优先级法中的一次执行。

## 优先级法
系统或用户按某种原则为作业或进程指定优先级作为调度优先权。

**算法的核心是确定进程或作业的优先级**

### 基本优先级算法
**静态优先级**
- 由用户自己根据作业的紧急程度输入的适当优先级
- 由系统或操作员根据作业类型指定优先级
- 系统根据作业要求资源情况确定优先级

**动态优先级**
- 系统根据进程占有 CPU 时间长度决定
- 根据就绪进程等待 CPU 的时间长度决定

### SRR 线性优先级调度策略
SRR 结构上是对于轮转法 Round Robin 的一种改进

*轮转法进程调度时的不公平问题是什么？*
新创建的进程也放入就绪队列末尾享受平等的处理机时间片。这对于执行时间长的进程来说是有点不公平的，因为它们需要多个时间片才能完成。

因此，线性优先级调度策略采用如下方式，即新创建的进程按 FCFS 方式排成就绪队列，而其他已得到过时间片服务的进程也按 FCFS 方式排成另一个就绪队列或称享受服务队列。

*解决方法？*
- 利用两个队列：
    - 新创建进程队列：线性优先级调度策略将新创建进程按 FCFS 方式排成就绪队列
    - 旧进程也就是享受过时间片的进程队列：其他已得到过时间片服务的进程也按 FCFS 方式排成另一个就绪队列或称享受服务队列

![](https://img2018.cnblogs.com/blog/1734701/201911/1734701-20191119182041284-1764999297.png)

**两个队列的优先级**
1.  设新创建进程队列中进程的优先级以速率 a (a>0)增加。
2.  设享受服务队列中进程的优先级以速率 b (a>b>0 )增加

*新创建进程等待多长时间之后进入享受服务队列？*
![](https://img2018.cnblogs.com/blog/1734701/201911/1734701-20191119182912718-645284221.png)
1.  当新创建进程就绪队列中的头一个进程的优先级与与享受服务队列中最后一个就绪进程的优先级相等时，新创建进程队列中的头一个进程可以转入享受服务进程队列。也就是两个函数相交的时候，即 P(t)=a*(t-t2)=a× (t1′-t1)+b× (t-t1′)
2.  当享受服务进程队列为空时，新创建进程队列的头一个进程也将移入享受服务进程队列

*为什么享受队列中的进程优先级增加速率 b 要比新创建进程优先级增长率 a 低?*
- b>a>0 时，两个不同队列中的就绪态进程的优先级将永远不会相等，从而享受服务进程队列中永远只有一个进程。线性优先级调度策略退化为 FCFS 方式
- a>b=0，线性优先级调度策略即轮转法调度方式。

==SRR 本质是介于 FCFS 与轮转法之间的一种利用两种不同队列的调度算法。==

## SJF
直观上来说，采用最短作业优先的调度算法，可使得系统在同一时间内处理的作业个数最多，从而吞吐量也就大于其他调度方式。但是，对于一个不断有作业进入的批处理系统来说，最短作业优先法有可能使得那些长作业永远得不到调度执行的机会。

**SJF 调度算法的吞吐量是最大的。**
但 SJF 有可能使那些长作业永远不会得到调度执行的机会。

## HRN
**最高响应比优先法是对 FCFS 方式和 SJF 方式的一种综合平衡。**
FCFS 方式只考虑每个作业的等待时间而未考虑执行时间的长短，而 SJF 方式只考虑执行时间而未考虑等待时间的长短，因此，这两种调度算法在某些极端情况下会带来某些不便。HRN 调度策略同时考虑每个作业的等待时间长短和估计需要的执行时间长短，从中选出响应比最高的作业投入执行。

响应比 R 定义：
$$ R = (W + T)/ T = 1 + W/T$$
- T 为该作业估计要执行的时间
- W 为作业在后备队列中的等待时间

每当要进行作业调度时，系统计算每个作业的响应比，选择其中 R 最大者投入执行。

这样，即使是长作业，随着它等待时间的增加，W/T 也就随着增加，也就有机会获得调度执行。==这种算法是介于 FCFS 和 SJF 之间的一种折中算法。==

由于长作业也有机会投入运行， 在同一时间内处理的作业数显然要少于 SJF 法，从而采用 HRN 方式时其吞吐量将小于采用 SJF 法时的吞吐量。另外，由于每次调度前要计算响应比，系统开销也要相应增加。

# 算法评价

1.轮转法在响应时间上优于 FCFS 调度方式
2.对于需要服务时间短的顾客，轮转法响应时间<线性优先法响应时间<FCFS 响应时间
3.对于需要服务时间长的顾客，FCFS 响应时间<线性优先法响应时间<轮转法响应时间

# 实时调度系统方法
## 实时系统特点
随着移动通信和网络计算技术的发展，实时系统正变得越来越重要。操作系统是实时系统中最重要的部分之一，它负责在用户要求的时限内进行事件处理和控制。

实时系统与其他系统最大的区别在于：
**其处理和控制的正确性不仅仅取决于计算的逻辑结果，而且取决于计算和处理结果产生的时间。**
因此，实时系统的调度与工业生产中的生产过程调度有许多相同之处，即把给定的任务按所要求的时限调配到相应的设备上去处理完成。

- **根据时限要求分类**
    - **硬实时任务**
        - 要求系统必须完全满足任务的时限要求。
    - **软实时任务**
        - 允许系统对任务的时限要求有一定的延迟。

- **根据外部任务分类**：
    - 周期性
    - 非周期性

实时系统具有以下特点：
- **有限等待时间（决定性特性）**
- 有限相应时间
- 用户控制
- 可靠性高
- 系统出错处理能力强

<u>分时系统中并发执行的进程具有不确定性，其执行顺序与执行环境有关。实时系统则不然，它要求所有的进程在处理事件时都必须在有限时间内开始，这一特性又被称为实时系统的决定性特性。</u>

特点解析：
- 在分时的非实时系统中，用户不能参与对进程调度的控制。在实时系统中，用户可以控制进程的优先级并选择相应的调度算法，从而达到对进程执行先后顺序的控制。
- 实时系统要求很高的可靠性。在分时系统的非实时系统中，用户可以用重新启动计算机等措施来处理系统出错。但是，实时系统主要是对外部事件进行处理和控制，例如导弹系统的控制，这样的系统不允许出现控制错误。
- 当系统发生错误时，实时系统不能像非实时系统那样，先停止当前处理的用户程序，转去执行出错处理或使系统自动退出。实时系统要求系统在出错时，既能够处理所发生的错误，又不影响当前正在执行的用户应用。

**上述特性要求实时系统具有以下能力：**
1.  **很快的进程或线程切换速度**：实时系统中调度算法设计原则是满足所有硬实时任务并尽可能多地满足软实时任务处理时限。
2.  快速的外部中断相应能力
3.  **基于优先级的随时抢先式调度策略**

## 时限调度算法的分类
**静态表格驱动类**
静态表格驱动类的实时调度算法，对可能的调度条件和参数进行静态分析，并将分析结果作为实际调度结果。这类调度算法多用于调度处理周期性任务，其主要分析参数为周期， 执行时间、周期执行结束时限和任务优先级等。最早时限优先法是比较典型的静态表格驱动算法。这里，最早时限优先法是优先调度时限最早的任务获得处理机的调度算法。

**静态优先级驱动抢先式调度算法类**
该类算法也进行静态分析，不过，它们的静态分析不直接产生调度结果，而只用来指定任务的优先级。*频率单调调度算法就是一种静态优先级驱动的抢先式调度算法。*

**动态计划调度算法类**
动态计划调度算法在调度任务执行之前排出调度计划，并分析计划的调度结果是否使得任务所要求的处理时限得到满足。如果能够满足，则按调度计划执行，否则修改调度计划。

**尽力而为调度算法类**
这一类算法不进行可能性分析，只对到达的事件和相关任务指定相应的优先级，并进行调度。尽力而为调度方式开销较小，实现容易。但是，该算法不一定满足用户要求的处理时限。

### 时限调度算法
**时限调度算法是一种以满足用户要求的时限为调度原则的算法。**
在实时系统中的用户要求时限有两种，即处理开始时限(starting deadline)和处理结束时限(ending deadline)。时限调度算法可以使用任一种时限。

时限调度算法可用于周期性调度与非周期性调度两种。

**时限调度算法相关输入信息：**
| 任务就绪时间或事件到达时间 | 开始时限 | 完成时限 | 处理时间 | 资源需求 | 优先级 |
| -------------------------- | -------- | -------- | -------- | -------- | ------ |

==时限调度是抢先式的。==抢先式时限调度算法必须把新到达任务的时限要求和当前正在执行任务的时限要求进行比较，如果新到达任务的时限要求更近，则应执行新到达的任务。

*使用时限调度算法的充分条件与必要条件*
**充分条件：**
$$\frac{C1}{T1} + \frac{C2}{T2} + \ ... \ +\frac{Ci}{Ti} + \ ... + \frac{Cn}{Tn} \le n(2^\frac{1}{n}-1)$$
如果进程执行时间与周期比之和大于$n(2^\frac{1}{n}-1)$，则用户要求的时限无法保证。

**必要条件：**
$$C \le t$$
### 频率单调调度算法

# 小结
作业调度
因为处理机调度程序不可能选择全部驻留在外存的进程，因此，在调度一个进程占有处理机之前，系统必须按某种策略把外存中处于后备状态的作业选择出来，并创建进程和分配内存，为进程执行准备必需的资源。这一步称为作业调度或高级调度。作业调度的目标是尽量做到公平合理，能执行尽可能多的作业、尽可能快的响应时间以及高的设备利用率等。

作业和进程调度算法
任一调度算法要同时满足这些调度目标是不可能的。大多数操作系统都是根据用户需要而采用兼顾某些目标的方法。比较常用的作业调度算法有 FCFS 方法、SJF(最短作业优先)法和 HRN(最高响应比)法等。这几种方法各有特点。其中 FCFS 法系统开销小，且对每个作业来说按其到达顺序被依次调度。FCFS 法不利于短作业。SJF 法可得到最大系统吞吐率，即每天处理的作业个数最多。但是 SJF 法有可能使长作业永远没有机会执行。HRN 法是介于 FCFS 法和 SJF 法之间的一种方法。

中级调度
在有的系统中，把那些处于等待状态或就绪状态的进程换出内存，而把那些等待事件已经发生或已经在外存交换区等待了较长时间的进程换入内存。
