#第一遍阅读 
# Intro 
> 现代操作系统的重要特点是在保证安全的前提下，程序并发执行，以及系统所拥有的资源被共享和系统的用户随机地使用。这3个特点是互相联系和互相依赖的，它们是互相独立的用户如何使用有限的计算机系统资源的反映。

**操作系统的重要任务之一是使用户充分、有效地利用系统资源。**

*采用一个什么样的概念来描述计算机程序的执行过程和作为资源分配的基本单位，才能充分反映操作系统的执行并发、资源共享及用户随机的特点呢？*
即：进程

# 进程的概念
## 程序并发执行
**程序**
程序(program)描述计算机所要完成的具有独立功能的，并在时间上按严格次序前后相继的计算机操作序列集合，是一个静态的概念。
它体现了编程人员要求计算机完成相应功能时所应该采取的**顺序步骤**。

**程序顺序执行**
计算机的CPU是通过时序脉冲来控制顺序执行指令的。
程序的顺序性与计算机硬件的顺序性一致。
将一个具有独立功能的程序**独占处理机直至最终结束的过程**称为程序的顺序执行。

**顺序执行的特点**
1. 顺序性
2. 封闭性
3. 可再现性

**多道程序系统中执行环境的变化**
1. 独立性：每道程序逻辑上独立
2. 随机性：要求在短时间内对随机的输入作出反应
3. 资源共享性
（单CPU系统中，多到环境下执行程序的道数总是要超过计算机系统中CPU的个数）


**程序并发执行 concurrent**  
为了**增强计算机系统的处理能力**和**提高资源利用率**所采取的一种同时操作技术。
可进一步分为两种：
- 第一种是多道程序系统的程序执行环境变化所引起的多道程序的并发执行。**因此，尽管多道程序的并发执行在宏观上是同时进行的，但在微观上仍是顺序执行的；**
- 第二种并发执行是在某道程序的几个程序段中（例如几个程序）包含着一部分可以同时执行或顺序颠倒执行的代码。

**并发执行概念**
一组在逻辑上互相独立的程序或程序段在执行过程中，其执行时间在客观上互相重叠，即一个程序段的执行尚未结束，另一个程序段的执行已经开始的这种执行方式。

*并发与并行的概念辨析*
并行：一组程序按独立的、异步的速度执行。并行执行不等于时间上的重叠。而是<u>同时执行多个任务</u>
并发：在宏观上并不是同时（并行）执行，而是<u>微观上的交错执行。</u>

## 进程的定义
**主要关注动态的执行过程这一概念。**
即：并发执行的程序在执行过程中分配和管理资源的基本单位。

*为什么要引入进程这一概念？*
> 计算机要实现并行处理，开始使用**程序**的概念作为单位，发现无法满足多道程序三特性：独立，随机，资源共享。
> 遂引入新的基本单位来控制程序的并行——进程。其更多的关注于程序执行**过程**。


*进程和程序的概念辨析*
- 进程是动态的，程序是静态的。进程强调执行过程，程序是指令的集合。
- 进程具有并发特性，程序没有。进程具有独立性与异步性。
- 进程是竞争计算机资源的基本单位。（制约是对进程独立性和异步性地限制）
- 不同的进程可以包含同一个程序，只要程序对应的数据集不同。

- <u>从理论角度看，进程是一种对程序运行过程的抽象。（面向过程？啧啧）</u>
- <u>从实现角度看，是一种数据结构</u>，目的在于清晰地**刻画动态系统的内在规律**，**有效管理和调度**进入计算机系统主存储器运行的程序。


# 进程的描述
*一个进程是一个程序对某个数据集的执行过程，是分配资源的基本单位。那么，从处理机的活动角度来看，又如何识别描述程序执行活动的进程呢？*

**进程的静态描述**
<u>是系统中描述进程存在和反应其变化的物理实体</u>
- 进程控制块PCB：进程的描述信息、控制信息和资源信息。进程动态特征的集中反馈。
- 程序段
- 数据集：程序执行时必不可少的工作区与操作对象。

## 进程控制块PCB
包含一个进程的描述信息，控制信息和资源信息。
**PCB集中反应一个进程的动态特征。** 进程并发执行时，由于资源共享，带来各进程之间的相互制约。

**PCB反映制约关系和资源共享关系**
在创建一个进程时，应首先创建其PCB,然后才能根据PCB中的信息对进程实施有效的管理和控制。
当一个进程完成其功能之后，系统释放PCB,进程也随之消亡。

**PCB包含内容：**
- 描述信息
- 控制信息
- 资源管理信息
- CPU现场保护结构

> 总之，**PCB是系统感知进程存在的唯一实体。** 通过对PCB的操作，系统为有关进程分配资源从而使得有关进程得以被调度执行；而完成进程所要求功能的程序段的有关地址，以及程序段在进程过程中因某种原因被停止执行后的现场信息也都在PCB中。最后，当进程执行结束后，则通过释放PCB来释放进程所占有的各种资源。

## 进程上下文
进程上下文即：有关**程序段**和**数据集**。

即：
$$进程 = 进程控制块PCB \ + 进程上下文$$

进程上下文实际上是进程执行过程中顺序关联的**静态描述**。进程上下文是一个与进程切换和处理机状态发生交换有关的概念。在进程执行过程中，由于中断、等待或程序出错等原因造成进程调度，这时操作系统需要知道和记忆进程已经执行到什么地方或新的进程将从何处执行。另外，进程执行过程中还经常出现调用子程序的情况。在调用子程序执行后， 进程将返回何处继续执行，执行结果将返回或存放到什么地方等都需要进行记忆。

**进程上下文是一个抽象的概念。**
其包含了每个进程执行过的、执行时的以及待执行的指令和数据，在指令寄存器、堆栈（存放各调用子程序的返回点和参数等）和状态字寄存器等中的内容。

**上文**
已经执行过的进程指令和数据相关寄存器与堆栈中的内容。
**正文**
正在执行的进程和数据在寄存器中的堆栈。
**下文**
待执行的部分。

*在不发生进程调度时，进程上下文的改变都是在同一进程内进行的*，此时，每条指令的执行对进程上下文的改变较小，一般反映为指令寄存器、程序计数器以及保存调用子程序返回接口用的堆栈值等的变化。

同一进程的上下文的结构由与执行该进程有关的各种寄存器中的值、程序段经过编译后形成的机器指令代码集（或称正文段）、数据集及各种堆栈值与PCB结构构成。

这里，有关寄存器和栈区的内容是重要的。例如，没有程序计数器P和程序状态字寄存器PSW,CPU将无法知道下条待执行指令的地址和控制有关操作。

**用户级上下文与系统级上下文** #待精读

## 进程上下文切换
**提出进程上下文的概念主要是为了上下文切换**

==进程上下文切换发生在不同进程之间而不是一个进程内。==

进程上下文切换过程一般包含3个部分，并涉及3个进程。第一部分为保存被切换进程的正文部分（或当前状态）至有关存储区，例如该进程的PCB中。第二部分是操作系统进程中有关调度和资源分配程序执行，并选取新的进程。第三部分则是将被选中进程的原来被保存的正文部分从有关存储区中取出，并送至有关寄存器与堆栈中，激活被选中进程执行。

进程上下文切换过程涉及谁来保护和获取进程的正文问题，即如何使寄存器和堆栈等中的数据流入流出PCB存储区。
进程上下文切换还涉及系统调度和分配程序，都比较浪费CPU时间。

为了提高进程上下文切换效率，提出了多组寄存器技术。**为了进一步提升效率，提出了线程的概念。**

**进程空间与大小**
进程空间大小只与处理机位数有关。
还被划分为用户空间和系统空间+用户态和系统态。
进程的大小就是进程空间的大小。


# 进程状态及其转换
一个进程的声明周期可以划分为一组状态，这些状态刻画了整个进程。
系统根据PCB结构中的状态值控制进程。

1. 初始态
2. 执行状态
3. 等待状态
4. 就绪状态
5. 终止状态

**就绪状态**
处于就绪状态的进程已经得到除CPU之外的其他资源，只要由调度得到处理机，便可立即投人执行。

> 在有些系统中，为了有效地利用内存，就绪状态又可进一步分为内存就绪状态和外存就绪状态。在这样的系统中，只有处于内存就绪状态的进程在得到处理机后才能立即投入执行；而处于外存就绪状态的进程只有先成为内存就绪状态后，才可能被调度执行。这种方式明显地提高了内存的利用效率，但反过来也增加了系统开销和系统复杂性。

**执行状态**
微观上看，在单CPU系统中，任一时刻处于执行状态的进程只能有一个。只有处于就绪状态的进程经调度选中之后才可进入执行状态。

> 在某些操作系统中，一个进程在其生命期内的执行过程中，总要涉及用户程序和操作系统内核程序两部分。因此，进程的执行状态又可进一步划分为用户执行状态（简称为用户态)和系统执行状态（简称为系统态或核心态）。进程的用户程序段在执行时，该进程处于用户态。而一个进程的系统程序段在执行时，该进程处于系统态。为什么要划分用户态和系统态呢？一个最主要的原因是要把用户程序和系统程序区分开来，以利于程序的共享和保护。显然，这也是以增加系统复杂度和系统开销为代价的。

**等待状态**
进程因等待某个事件发生而放弃处理机进入等待状态。显然，等待状态可根据等待事件的种类而进一步划分为不同的子状态，例如内存等待、设备等待、文件等待和数据等待等。
这样做的好处是系统控制简单，发现和唤醒相应的进程较为容易。但系统中设置过多的状态又会造成系统参数和状态转换过程的增加。

**进程状态转换**
从一个状态到另一状态的转换除了要使用不同的控制过程，有时还要借助于硬件触发器才能完成。

# 进程控制
进程和处理机管理的一个重要任务是进程控制。所谓进程控制，**就是系统使用一些具有特定功能的程序段来创建、撤销进程以及完成进程各状态间的转换**，从而达到多进程高效率并发执行和协调、实现资源共享的目的。

**原语**
一般地，把系统态下执行的某些具有特定功能的程序段称为原语。
原语可分为两类：一类是机器指令级的，其特点是执行期间不允许中断， 正如在物理学中的原子一样，在操作系统中，它是一个不可分割的基本单位；另一类是功能级的，其特点是作为原语的程序段不允许并发执行。这两类原语都在系统态下执行，且都是为了完成某个系统管理所需要的功能和被高层软件所调用。

## 进程创建与撤销
进程的创建原语和撤销原语完成了进程从无到有、从存在到消亡的变化。被创建后的进程最初处于就绪状态，经调度程序选中后进入执行状态。有关进程调度过程在进程调度章节详细说明。
**创建**
无论是系统创建方式还是父进程创建方式，都必须调用创建原语来实现。创建原语扫描系统的PCB链表，在找到一定的PCB表之后，填入调用者提供的有关参数，最后形成代表进程的PCB结构。这些参数包括进程名、进程优先级P0、进程正文段起始地址d0和资源清单R0等。

**撤销**
无论哪一种情况导致进程被撤销，进程都必须释放它所占用的各种资源和PCB结构本身，以利于资源的有效利用。当然，一个进程所占有的某些资源在使用结束时可能早已释放。另外，当一个祖先进程撤销某个子进程时，还需审查该子进程是否还有自己的子孙进程，若有的话，还需撤销其子孙进程的PCB结构并释放它们所占有的资源（为什么？请思考)。

## 进程阻塞与唤醒

**阻塞**
阻塞原语在一个进程期待某一事件（例如键盘输入数据、写盘、其他进程发来的数据等） 发生，但发生条件尚不具备时，被该进程自己调用来阻塞自己。阻塞原语在阻塞一个进程时，由于该进程正处于执行状态，故应先中断处理机和保存该进程的CPU现场。然后将被阻塞进程置“阻塞”状态后插入等待队列中，再转进程调度程序选择新的就绪进程投人运行。

这里，转进程调度程序是很重要的，否则，处理机将会出现空转而浪费资源。

==进程自己调用来阻塞自己==

**唤醒**
当等待队列中的进程所等待的事件发生时，等待该事件的所有进程都将被唤醒。显然， 一个处于阻塞状态的进程不可能自己唤醒自己（为什么？请思考）

唤醒一个进程有两种方法：一种是由系统进程唤醒。另一种是由事件发生进程唤醒。当由系统进程唤醒等待进程时，系统进程统一控制事件的发生并将“事件发生”这一消息通知等待进程。从而使得该进程因等待事件已发生而进入就绪队列。等待进程也可由事件发生进程唤醒。由事件发生进程唤醒时，事件发生进程和被唤醒进程之间是合作关系。因此，唤醒原语既可被系统进程调用，也可被事件发生进程调用。
调用唤醒原语的进程称为唤醒进程。唤醒原语首先将被唤醒进程从相应的等待队列中摘下，将被唤醒进程置为就绪状态之后，送入就绪队列。在把被唤醒进程送入就绪队列之后，唤醒原语既可以返回原调用程序，也可以转向进程调度，以便让调度程序有机会选择一个合适的进程执行。

==由系统或事件控制来进行唤醒==
 

# 进程互斥与同步
本质上基于进程并发执行。
## 互斥-资源共享引起的制约
资源有限，导致进程之间的资源竞争和共享。因此，进程的并发执行不仅仅是用户程序的执行开始时间的随机性和提高资源利用率的结果，也是资源有限性导致资源的竞争与共享对进程的执行过程进行制约导致的。

**临界区**
不允许并发进程交叉执行的一段程序。
是由不属于多个并发进程的程序段共享公用数据或公用数据变量引起的。临界区不可能用增加硬件的方法解决。因此，临界区也可被称为访问公共数据的那段程序。

**间接制约**
把这种由于共享某一公有资源而引起的在临界区内不允许并发进程交叉执行的现象， 称为由共享公有资源而造成的对并发进程执行速度的间接制约。

**互斥**
**不允许两个以上的共享该资源的并发进程同时进入临界区。**

> 一组并发进程互斥执行时必须满足如下准则： 
> (1)不能假设各并发进程的相对执行速度。即各并发进程享有平等地、独立地竞争共有资源的权利，且在不采取任何措施的条件下，在临界区内任一指令结束时，其他并发进程可以进入临界区。
> (2)并发进程中的某个进程不在临界区时，它不阻止其他进程进入临界区。
> (3)并发进程中的若干个进程申请进入临界区时，只能允许一个进程进入。
> (4)并发进程中的某个进程从申请进入临界区时开始，应在有限时间内得以进入临界区。

## 互斥-信号量和P V原语
**信号量**
信号量的概念和下面所述的P、V原语是荷兰科学家E.W.Dijkstra提出来的。信号是铁路交通管理中的一种常用设备，交通管理人员利用信号颜色的变化来实现交通管理。

在操作系统中，信号量sem是一个整数。在sem大于等于零时代表可供并发进程使用的资源实体数，但sem小于零时则表示正在等待使用临界区的进程数。显然，用于互斥的信号量se的初值应该大于零，而建立一个信号量必须说明所建信号量代表的意义，赋初值，以及建立相应的数据结构，以便指向那些等待使用该临界区的进程。

**PV原语**
信号量的数值仅能由P、V原语操作改变(P和V分别是荷兰语Passeren和Verhoog 的头一个字母，相当于英文的pass和increment的意思)。采用P、V原语，可以把类名为S 的临界区描述为When S do P(sem)临界区V(sem)od。

**用PV原语实现进程互斥**

---
## 同步-概念
一组在异步环境下的并发进程，各自的执行结果互为对方的执行条件，从而限制各进程的执行速度的过程称为并发进程间的直接制约。
异步环境主要是指各并发进程的执行起始时间的随机性和执行速度的独立性。

## 同步-私用信号量
一般来说，也可以把各进程之间发送的消息作为信号量看待。与进程互斥时不同的是， 这里的信号量只与制约进程及被制约进程有关而不是与整组并发进程有关。因此，称该信号量为私用信号量(private semaphore)。一个进程P,的私用信号量Sem;是从制约进程发送来的进程P,的执行条件所需要的消息。与私用信号量相对应，称互斥时使用的信号量为公用信号量。

**信号量和P V原语**
有了私用信号量的概念，可以使用P、V原语操作实现进程间的同步，其实现方法与利用wait和signal过程时相同，也是分为3步。首先为各并发进程设置私用信号量，然后为私用信号量赋初值，最后利用P、V原语和私用信号量规定各进程的执行顺序。

## 综合-生产者消费者问题 #待精读 
把并发进程的同步和互斥问题一般化，可以得到一个抽象的一般模型，即生产者-消费者问题(producer-consumer problems)。

计算机系统中，每个进程都申请使用和释放各种不同类型的资源，这些资源既可以是外设、内存及缓冲区等硬件资源，也可以是临界区、数据和例程等软件资源。把系统中使用某一类资源的进程称为该资源的消费者，而把释放同类资源的进程称为该资源的生产者。

# 进程通信
通信意味着在进程间传递数据。
## 进程通信方式
1. 主从式
2. 会话式
3. 消息或邮箱机制
4. 共享存储区方式

**主从式**
(1)主进程可自由地使用从进程的资源或数据。
(2)从进程的动作受主进程的控制。
(3)主进程和从进程的关系是固定的。

*典型例子是中断控制进程和终端进程*

**会话式**
进程双方可分别称为使用进程和服务进程。
*用户进程与磁盘管理进程在进行进程通信时有固定的连接关系*

**消息或邮箱机制**
消息或邮箱机制则无论接收进程是否已准备好接收消息，发送进程都将把所要发送的消息送入缓冲区或邮箱。
这里，消息(message)是用来区别于命令(command)或指令(instruction)等用语的。除了表示所交换的数据传递大量信息之外，消息还具有两个互相通信的进程地位平等的意思。消息的一般形式由4个部分组成，即发送进程名、接收进程名、数据和有关数据的操作。
特点如下
- 只要存在空缓冲区或邮箱，发送进程就可以发送消息
- 与会话系统不同，发送与接收进程之间无直接连接关系
- 发送进程和接收进程之间存在缓冲区或邮箱用来存放被传送消息。

**消息缓冲机制** #碎片摄入👌🏻


# 死锁
死锁是指各并发进程互相等待对方所拥有的资源，且这些并发进程在得到对方资源之前不会释放自己拥有的资源。从而造成大家都想得到资源而又得不到资源。

**死锁的起因**
死锁的起因是并发进程的资源竞争。产生死锁的根本原因在于系统提供的资源个数少于并发进程所要求的该类资源数。显然，由于资源的有限性，不可能为所有要求资源的进程无限制地提供资源。但是，可以采用适当的资源分配算法，以达到消除死锁的目的。

## 产生死锁的必要条件
1. 互斥条件
2. 不剥夺条件
3. 部分分配
4. 环路条件
==只要以上四种条件的某一个不满足，即可消除死锁==

## 死锁的消除
> 一般而言，由于操作系统的并行与共享以及随机性等特点，通过预防和避免的手段达到消除死锁的目的是一件十分困难的事。这需要较大的系统开销，甚至不能充分利用资源。

死锁的检测和恢复则与此相反，不必花费多少执行时间就能发现死锁和从死锁中恢复出来。
**在实际操作系统中大都使用检测与恢复法消除死锁。**


# 线程
***为什么要引入线程？***
进程是为了提高CPU的执行效率，减少因为程序等待带来的CPU空转以及其他计算机软硬件资源的浪费而提出来的。进程是为了完成用户任务所需要的程序的一次执行过程以及为其分配资源的一个基本单位。以进程为单位来分配资源时，为了便于处理机执行，系统要定义如何对进程进行识别和操作的物理实体。

## 线程基本概念
线程是进程的一部分。有时又被称为轻权进程。
线程也是CPU调度的一个基本单位。

一个没有线程的进程可以被看做是单线程的。只有一个对应的寄存器和堆栈，执行过程在此进行和完成。
若一个进程拥有多个线程，则其执行过程中不再是唯一线状的，由多条线状执行过程组成。

## 线程与进程的区别
虽然进程和线程都是处理机调度的基本单位，但线程的改变只代表了CPU执行过程的改变，而进程所拥有的资源没有发生变化。
即：除了CPU之外，计算机内软硬件资源的分配与线程无关，线程只能共享它所属进程的资源。

==进程是系统资源分配时的基本单位==
==线程是CPU分配的基本单位==

**线程控制块TCB**
与进程控制表和PCB相似，每个线程也有自己的线程控制块(TCB),而这个TCB中所保存的线程状态信息则要比PCB少得多，这些信息主要是相关指针用堆栈（系统栈和用户栈)以及寄存器中的状态数据。

进程拥有一个完整的虚拟地址空间。
进程不依赖于线程而独立存在。

## 线程的适用范围
使用线程的最大好处是在有多个任务需要处理机处理时可以减少处理机的切换时间； 而且，线程的创建和结束所需要的系统开销也比进程要小得多。由此，可以推出最适合使用线程的系统是多处理机系统、网络系统或分布式系统。

**典型应用：**
- 服务器中文件管理或通信控制
- 前后台处理
- 异步处理

## 线程分类
**用户级线程**
管理全部由用户程序完成，OS内核只对进程进行管理。

> 为了对用户级线程进行管理，操作系统提供一个在用户空间执行的线程库。该线程库提供创建、调度和撤销线程功能。同时，该线程库也提供线程间的通信、线程的执行以及存储线程上下文的功能。用户级线程只使用户堆栈和分配给所属进程的用户寄存器。当一个线程被派生时，线程库为其生成相应的线程控制块(TCB)等数据结构，并为TCB中的参量赋值和把该线程置于就绪状态。其处理过程与进程创建过程大致相似。

- 用户级线程的调度算法和调度过程全部由用户自行确定，与kernel无关。
- 用户级线程的调度算法只进行线程上下文切换而不进行处理机切换，且线程切换与kernel无关。

> 因为用户级线程的上下文切换与内核无关，所以可能出现如下情况：即当一个进程由于I/O中断或时间片用完等原因造成该进程退出处理机，而属于该进程的执行中线程仍处于执行状态。也就是说，尽管相关进程的状态是阻塞的或等待的，但所属线程状态却是执行的。

^9611c2


**系统级线程/kernel**
由操作系统kernel进行管理。kernel给应用程序提供相应的[[2 操作系统用户界面#接口2-系统调用|系统调用]]和API，以使用户程序可以创建，执行和撤销线程。

与用户线程不同，内核级线程既可以被调度到一个处理机上并发执行，也可以被调度到不同的处理机上并行执行。操作系统内核既负责进程的调度，也负责进程内不同线程的调度工作。因此，内核级线程不会出现[[3 进程管理#^9611c2|进程处于阻塞或等待状态，而线程处于执行状态的情况]]。

内核级线程也可用于内核程序自身，以提高OS内核程序执行效率。

## 线程的执行特性
**基本状态**
1. 执行
2. 就绪
3. 阻塞

==线程无挂起/等待状态，即线程是一个只与内存和寄存器相关的概念，其内容不会因swap进入外存。==

*有些情况下，某个线程被阻塞也可能导致该线程所属进程被阻塞*

线程也存在同步和互斥机制，与进程类似。

# 小结
进程是操作系统中最重要、最基本的概念之一。它是系统分配资源的基本单位，是一个具有独立功能的程序段对某个数据集的一次执行活动。引入进程的概念是由操作系统的资源有限性、处理上的并行性以及系统用户的执行起始时间的随机性所决定的。一切仅具有静态特征的概念，例如程序，不能反映系统的上述特征，因此，导入了具有动态特征的进程概念。



