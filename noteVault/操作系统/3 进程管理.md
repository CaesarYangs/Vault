#第二遍阅读

# Points
1.  多道程序系统与并发执行
2.  进程概念与管理
3.  进程上下文及其切换
4.  线程概念与存在意义
5.  死锁

# Intro
> 现代操作系统的重要特点是在保证安全的前提下，**程序并发执行**，以及**系统所拥有的资源被共享**和**系统的用户随机地使用**。
> 这 3 个特点是互相联系和互相依赖的，它们是互相独立的用户如何使用有限的计算机系统资源的反映。

**操作系统的重要任务之一是使用户充分、有效地利用系统资源。**

**现代操作系统四大特点：**
- 并发性
- 共享性
- 虚拟性（用户随机使用）
- 异步性

*采用一个什么样的概念来描述计算机程序的执行过程和作为资源分配的基本单位，才能充分反映操作系统的执行并发、资源共享及用户随机的特点呢？*
即：进程

# 程序并发执行
**程序**
程序(program)描述计算机所要完成的具有独立功能的，并在时间上按严格次序前后相继的计算机操作序列集合，是一个静态的概念。
它体现了编程人员要求计算机完成相应功能时所应该采取的**顺序步骤**。

### 单道程序设计（顺序执行）
**程序顺序执行**
计算机的 CPU 是通过时序脉冲来控制顺序执行指令的。
程序的顺序性与计算机硬件的顺序性一致。
将一个具有独立功能的程序**独占处理机直至最终结束的过程**称为程序的顺序执行。

**顺序执行的特点**
1.  顺序性
2.  封闭性
3.  可再现性

### 多道程序设计
*什么是多道程序设计？*
是在计算机内存中同时存放几道相互独立的程序，使它们在管理程序控制之下，相互穿插的运行。 两个或两个以上程序在计算机系统中同处于开始到结束之间的状态。

**多道程序系统中执行环境的变化**
**多道程序系统三大特性：**
1.  独立性：每道程序逻辑上独立
2.  随机性：要求在短时间内对随机的输入作出反应
3.  资源共享性
（单 CPU 系统中，多道环境下执行程序的道数总是要超过计算机系统中 CPU 的个数）

**进入多道程序设计，程序就失去了封闭性和顺序性**

### 程序的并发执行
**程序并发执行 concurrent**
为了**增强计算机系统的处理能力**和**提高资源利用率**所采取的一种同时操作技术。
可进一步分为两种：
- 第一种是多道程序系统的程序执行环境变化所引起的多道程序的并发执行。**因此，尽管多道程序的并发执行在宏观上是同时进行的，但在微观上仍是顺序执行的；**
- 第二种并发执行是在某道程序的几个程序段中（例如几个程序）包含着一部分可以同时执行或顺序颠倒执行的代码。

**并发执行概念**
一组在逻辑上互相独立的程序或程序段在执行过程中，其执行时间在客观上互相重叠，即一个程序段的执行尚未结束，另一个程序段的执行已经开始的这种执行方式。

*并发与并行的概念辨析*
并行：一组程序按独立的、异步的速度执行。<u>并行执行不等于时间上的重叠。而是同时执行多个任务</u>
并发：<u>在宏观上并不是同时（并行）执行，而是微观上的交错执行。</u>

# 进程的概念
## 进程的定义
**主要关注动态的执行过程这一概念。**
即：并发执行的程序在执行过程中分配和管理资源的基本单位。

*为什么要引入进程这一概念？*
> 计算机要实现并行处理，开始使用**程序**的概念作为单位，发现无法满足多道程序三特性：独立，随机，资源共享。
> 遂引入新的基本单位来控制程序的并发执行——进程。其更多的关注于程序执行**过程**。

*进程和程序的概念辨析*
- 进程是动态的，程序是静态的。进程强调执行过程，程序是指令的集合。
- 进程具有并发特性，程序没有。进程具有独立性与异步性。
- 进程是竞争计算机资源的基本单位。（制约是对进程独立性和异步性地限制）
- 不同的进程可以包含同一个程序，只要程序对应的数据集不同。*（类比作业的概念[[2 操作系统用户界面#作业|作业的组成]]：程序段和数据集是构成一个 xxx 基本单位的组成要素 以及下面的[[#^d59453|进程静态描述]]）*

- <u>从理论角度看，进程是一种对整个程序运行过程的抽象。（面向过程？啧啧）</u>
- <u>从实现角度看，是一种数据结构</u>，目的在于清晰地**刻画动态系统的内在规律**，**有效管理和调度**进入计算机系统主存储器运行的程序。

# 进程的描述
*一个进程是一个程序对某个数据集的执行过程，是分配资源的基本单位。那么，从处理机的活动角度来看，又如何识别描述程序执行活动的进程呢？*

**进程的静态描述**
<u>是系统中描述进程存在和反应其变化的物理实体</u>
$$进程的静态描述 = 进程控制块 PCB + 程序段 + 数据结构集$$ ^d59453

- 进程控制块 PCB：进程的描述信息、控制信息和资源信息。进程动态特征的集中反馈。
- 程序段
- 数据集：程序执行时必不可少的工作区与操作对象。

## 进程控制块 PCB
包含一个进程的描述信息，控制信息和资源信息。
**PCB 集中反应一个进程的动态特征。**
进程并发执行时，由于资源共享，带来各进程之间的相互制约。

- **PCB 反映制约关系和资源共享关系**
    - 在创建一个进程时，应首先创建其 PCB,然后才能根据 PCB 中的信息对进程实施有效的管理和控制。
    - 当一个进程完成其功能之后，系统释放 PCB,进程也随之消亡。

**PCB 包含内容：**
- 描述信息：编号，标识号等
- 控制信息：进程当前状态，优先级，占用内存的时间 etc.
- **资源管理信息**：包含最多 包括存储器，IO 和文件系统的信息
- CPU 现场保护结构：为中断做准备 存储退出执行时进程的现场数据

> 总之，**PCB 是系统感知进程存在的唯一实体。**
> 通过对 PCB 的操作，系统为有关进程分配资源从而使得有关进程得以被调度执行；而完成进程所要求功能的程序段的有关地址，以及程序段在进程过程中因某种原因被停止执行后的现场信息也都在 PCB 中。最后，当进程执行结束后，则通过释放 PCB 来释放进程所占有的各种资源。

## 进程上下文
进程上下文即：有关**程序段**和**数据集**。

即：
$$进程 = 进程控制块 PCB \ + 进程上下文$$

- **进程上下文集中反映一个进程的静态描述**
    - 进程上下文是一个与进程切换和处理机状态发生交换有关的概念。在进程执行过程中，由于中断、等待或程序出错等原因造成进程调度，这时操作系统需要知道和记忆进程已经执行到什么地方或新的进程将从何处执行。
    - 进程执行过程中调用子程序执行后， 进程将返回何处继续执行，执行结果将返回或存放到什么地方等都需要进行记忆。

<u>进程上下文主要用于进程切换时，处理机状态发生交换或调用子程序时，OS 记忆当前进程执行的内容和中断发生的位置，以便返回继续执行。</u>

**进程上下文是一个抽象的概念。**
其包含了每个进程执行过的、执行时的以及待执行的指令和数据，在指令寄存器、堆栈（存放各调用子程序的返回点和参数等）和状态字寄存器等中的内容。

**上文**
已经执行过的进程指令和数据相关寄存器与堆栈中的内容。
**正文**
正在执行的进程和数据在寄存器中的堆栈。
**下文**
待执行的部分。

**不同进程间的进程上下文切换只在发生进程调度时出现**
*在不发生进程调度时，进程上下文的改变都是在同一进程内进行的*，此时，每条指令的执行对进程上下文的改变较小，一般反映为指令寄存器、程序计数器以及保存调用子程序返回接口用的堆栈值等的变化。

同一进程的上下文的结构由与执行该进程有关的各种寄存器中的值、程序段经过编译后形成的机器指令代码集（或称正文段）、数据集及各种堆栈值与 PCB 结构构成。

这里，有关寄存器和栈区的内容是重要的。例如，没有程序计数器 P 和程序状态字寄存器 PSW, CPU 将无法知道下条待执行指令的地址和控制有关操作。

<u>进程上下文在底层还可以看做是各种控制表指针与寄存器的结合</u>

### UNIX 系统上下文组成
- **用户级上下文**
    - 进程的用户程序段部分编译而成的用户正文段、用户数据和用户栈组成。

- **寄存器上下文**——<u>从硬件层面最底层了解整个进程上下文如何实现 相当于接触整个 OS 底层如何进行上下文切换的，各种硬件的细节信息主要都在寄存器间的数据流动上</u>
    - 程序寄存器 PC、处理机状态字寄存器 PSW、栈指针和通用寄存器的值组成。
        - PC：给出 CPU 将要执行的下一条指令的虚地址
        - PSW：给出机器与该进程相关联时的硬件状态
        - 通用寄存器：用于不同执行模式之间的参数传递 e.g.[[2 操作系统用户界面#^d03f5a|系统调用用户和系统程序间传参的一种方法]]

- **系统级上下文**
    - 静态部分
        - PCB 结构、将进程虚拟地址映射到物理空间用的有关表格和核心栈。核心栈主要用于装载进程中所使用的系统调用的调用序列。
    - 动态部分
        - 与寄存器上下文相关联。进程上下文的层次概念主要体现在动态部分
        - <u>系统级上下文的动态部分可以看做是一些数量变化的层次组成的。</u>
        - 其变化规则满足 LIFO 的堆栈方式，每个上下文层次在栈中各占一项。

### 进程上下文切换
**提出进程上下文的概念主要是为了上下文切换**

==进程上下文切换发生在不同进程之间而不是一个进程内。==
**发生时间：系统做进程调度时出现**

进程上下文切换过程一般包含 3 个部分，并涉及 3 个进程。
1.  保存被切换进程的正文部分（或当前状态）至有关存储区
2.  操作系统进程中有关调度和资源分配程序执行
3.  将被选中进程的原来被保存的正文部分从有关存储区中取出，并送至有关寄存器与堆栈中，激活被选中进程执行。

进程上下文切换过程涉及谁来保护和获取进程的正文问题，即如何使寄存器和堆栈等中的数据流入流出 PCB 存储区。
进程上下文切换还涉及系统调度和分配程序，都比较浪费 CPU 时间。

为了提高进程上下文切换效率，提出了多组寄存器技术。**为了进一步提升效率，提出了线程的概念。**

**进程空间与大小**
任一进程都有自己的地址空间，该空间称为进程空间或虚空间。

进程空间大小只与处理机位数有关。
还被划分为用户空间和系统空间+用户态和系统态。
进程的大小就是进程空间的大小。

# 进程状态及其转换
一个进程的声明周期可以划分为一组状态，这些状态刻画了整个进程。
系统根据 PCB 结构中的状态值控制进程。

1.  初始态
2.  执行状态
3.  阻塞状态
4.  就绪状态
5.  终止状态

**就绪状态**
处于就绪状态的进程已经得到除 CPU 之外的其他资源，只要由调度得到处理机，便可立即投人执行。

> 内存就绪&外存就绪状态：在有些系统中，为了有效地利用内存，就绪状态又可进一步分为内存就绪状态和外存就绪状态。在这样的系统中，只有处于内存就绪状态的进程在得到处理机后才能立即投入执行；而处于外存就绪状态的进程只有先成为内存就绪状态后，才可能被调度执行。这种方式明显地提高了内存的利用效率，但反过来也增加了系统开销和系统复杂性。

**执行状态**
微观上看，在单 CPU 系统中，任一时刻处于执行状态的进程只能有一个。只有处于就绪状态的进程经调度选中之后才可进入执行状态。

> 在某些操作系统中，一个进程在其生命期内的执行过程中，总要涉及用户程序和操作系统内核程序两部分。因此，进程的执行状态又可进一步划分为用户执行状态（简称为用户态)和系统执行状态（简称为系统态或核心态）。进程的用户程序段在执行时，该进程处于用户态。而一个进程的系统程序段在执行时，该进程处于系统态。为什么要划分用户态和系统态呢？一个最主要的原因是要把用户程序和系统程序区分开来，以利于程序的共享和保护。显然，这也是以增加系统复杂度和系统开销为代价的。

**等待状态**
进程因等待某个事件发生而放弃处理机进入等待状态。显然，等待状态可根据等待事件的种类而进一步划分为不同的子状态，例如内存等待、设备等待、文件等待和数据等待等。
这样做的好处是系统控制简单，发现和唤醒相应的进程较为容易。但系统中设置过多的状态又会造成系统参数和状态转换过程的增加。

**进程状态转换**
从一个状态到另一状态的转换除了要使用不同的控制过程，有时还要借助于硬件触发器才能完成。

# 进程控制
进程和处理机管理的一个重要任务是进程控制。

进程控制**是系统使用一些具有特定功能的程序段来创建、撤销进程以及完成进程各状态间的转换**，从而达到多进程高效率并发执行和协调、实现资源共享的目的。

**原语**
一般地，把系统态下执行的某些具有特定功能的程序段称为原语。

原语可分为两类：一类是机器指令级的，**其特点是执行期间不允许中断**， 正如在物理学中的原子一样，在操作系统中，它是一个不可分割的基本单位；
另一类是功能级的，**其特点是作为原语的程序段不允许并发执行**。这两类原语都在系统态下执行，且都是为了完成某个系统管理所需要的功能和被高层软件所调用。

在 OS 中，通常把进程控制用程序段做成原语。用于进程控制的原语包括：创建、撤销、阻塞、唤醒等。

## 进程创建与撤销
进程的创建原语和撤销原语完成了进程从无到有、从存在到消亡的变化。被创建后的进程最初处于就绪状态，经调度程序选中后进入执行状态。有关进程调度过程在进程调度章节详细说明。
**创建**
创建方式：
1.  由系统模块统一创建
2.  由父进程创建

无论是系统创建方式还是父进程创建方式，都必须调用创建原语来实现。创建原语扫描系统的 PCB 链表，在找到一定的 PCB 表之后，填入调用者提供的有关参数，最后形成代表进程的 PCB 结构。这些参数包括进程名、进程优先级 P0、进程正文段起始地址 d0 和资源清单 R0 等。

**撤销**
以下情况导致进程撤销：
1.  进程已完成所要求的功能而正常终止
2.  由于错误而非正常终止
3.  祖先进程要求撤销某个子进程

无论哪一种情况导致进程被撤销，进程都必须释放它所占用的各种资源和 PCB 结构本身，以利于资源的有效利用。当然，一个进程所占有的某些资源在使用结束时可能早已释放。另外，当一个祖先进程撤销某个子进程时，还需审查该子进程是否还有自己的子孙进程，若有的话，还需撤销其子孙进程的 PCB 结构并释放它们所占有的资源（为什么？请思考)。

## 进程阻塞与唤醒
阻塞的具体原因和发生时间则与下一章节[[4 处理机调度]]有关

**阻塞**
阻塞原语在一个进程期待某一事件（例如键盘输入数据、写盘、其他进程发来的数据等） 发生，但发生条件尚不具备时，被该进程自己调用来阻塞自己。阻塞原语在阻塞一个进程时，由于该进程正处于执行状态，故应先中断处理机和保存该进程的 CPU 现场。然后将被阻塞进程置“阻塞”状态后插入等待队列中，再转进程调度程序选择新的就绪进程投人运行。

这里，转进程调度程序是很重要的，否则，处理机将会出现空转而浪费资源。

==进程自己调用来阻塞自己==

**唤醒**
当等待队列中的进程所等待的事件发生时，等待该事件的所有进程都将被唤醒。

唤醒一个进程有两种方法：
==由系统或事件控制来进行唤醒==

当由系统进程唤醒等待进程时，系统进程统一控制事件的发生并将“事件发生”这一消息通知等待进程。从而使得该进程因等待事件已发生而进入就绪队列。等待进程也可由事件发生进程唤醒。由事件发生进程唤醒时，事件发生进程和被唤醒进程之间是合作关系。因此，唤醒原语既可被系统进程调用，也可被事件发生进程调用。

调用唤醒原语的进程称为唤醒进程。唤醒原语首先将被唤醒进程从相应的等待队列中摘下，将被唤醒进程置为就绪状态之后，送入就绪队列。在把被唤醒进程送入就绪队列之后，唤醒原语既可以返回原调用程序，也可以转向进程调度，以便让调度程序有机会选择一个合适的进程执行。

# 进程互斥与同步
本质上基于进程并发执行。
## 互斥-资源共享引起的制约
资源有限，导致进程之间的资源竞争和共享。因此，进程的并发执行不仅仅是用户程序的执行开始时间的随机性和提高资源利用率的结果，也是资源有限性导致资源的竞争与共享对进程的执行过程进行制约导致的。

**临界区**
不允许并发进程交叉执行的一段程序。
是由不属于多个并发进程的程序段共享公用数据或公用数据变量引起的。临界区不可能用增加硬件的方法解决。因此，临界区也可被称为访问公共数据的那段程序。

**间接制约**
把这种由于==共享某一公有资源==而引起的在临界区内不允许并发进程交叉执行的现象， 称为由共享公有资源而造成的对并发进程执行速度的间接制约。

**互斥**
**不允许两个以上的共享该资源的并发进程同时进入临界区。**

> 一组并发进程互斥执行时必须满足如下准则：
> 1. 不能假设各并发进程的相对执行速度。即各并发进程享有平等地、独立地竞争共有资源的权利，且在不采取任何措施的条件下，在临界区内任一指令结束时，其他并发进程可以进入临界区。
> 2. 并发进程中的某个进程不在临界区时，它不阻止其他进程进入临界区。
> 3. 并发进程中的若干个进程申请进入临界区时，只能允许一个进程进入。
> 4. 并发进程中的某个进程从申请进入临界区时开始，应在有限时间内得以进入临界区。

- 1,2,3 保证各父进程享有平等、独立竞争和使用公有资源的权利，且保证同一时间至多有一个进程在临界区。
- 4 是并发进程不发生死锁的重要保证。否则由于某个并发进程长期占有临界区，其他进程则因为不能进入临界区而进入互相等待状态

## 互斥-信号量和 P V 原语
**（公用）信号量**
信号量的概念和下面所述的 P、V 原语是荷兰科学家 E.W.Dijkstra 提出来的。信号是铁路交通管理中的一种常用设备，交通管理人员利用信号颜色的变化来实现交通管理。

在操作系统中，信号量 sem 是一个整数。在 sem 大于等于零时代表可供并发进程使用的资源实体数，但 sem 小于零时则表示正在等待使用临界区的进程数。显然，用于互斥的信号量 se 的初值应该大于零，而建立一个信号量必须说明所建信号量代表的意义，赋初值，以及建立相应的数据结构，以便指向那些等待使用该临界区的进程。

**PV 原语**
信号量的数值仅能由 P、V 原语操作改变(P 和 V 分别是荷兰语 Passeren 和 Verhoog 的头一个字母，相当于英文的 pass 和 increment 的意思)。采用 P、V 原语，可以把类名为 S 的临界区描述为 When S do P(sem)临界区 V(sem)od。

- 执行一次 P 操作使得 sem 减一，V 操作使得 sem 加一。
- <u>在某个进程正在临界区执行时，其他进程执行了 P 原语操作，则该进程不会因为无法访问而回退到起点，而是在等待队列中等待其他进程执行 V 原语操作释放资源后，进入临界区。此时 P 原语的执行才算是真正结束。</u>

**用 PV 原语实现进程互斥**

---
## 同步-概念
**直接制约**
一组在异步环境下的并发进程，各自的执行结果互为对方的执行条件，从而限制各进程的执行速度的过程称为并发进程间的直接制约。

异步环境主要是指各并发进程的执行起始时间的随机性和执行速度的独立性。

## 同步-私用信号量
**私用信号量**
一般来说，也可以把各进程之间发送的消息作为信号量看待。与进程互斥时不同的是， 这里的信号量只与制约进程及被制约进程有关而不是与整组并发进程有关。
因此，称该信号量为私用信号量(private semaphore)。一个进程 P 的私用信号量 Sem 是从制约进程发送来的进程 P 的执行条件所需要的消息。

**PV 原语**
有了私用信号量的概念，可以使用 P、V 原语操作实现进程间的同步，其实现方法与利用 wait 和 signal 过程时相同，也是分为 3 步：
1.  为各并发进程设置私用信号量
2.  为私用信号量赋初值
3.  利用 P、V 原语和私用信号量规定各进程的执行顺序。

## 综合-生产者消费者问题 #待精读
把并发进程的同步和互斥问题一般化，可以得到一个抽象的一般模型，即生产者-消费者问题(producer-consumer problems)。

计算机系统中，每个进程都申请使用和释放各种不同类型的资源，这些资源既可以是外设、内存及缓冲区等硬件资源，也可以是临界区、数据和例程等软件资源。把系统中使用某一类资源的进程称为该资源的消费者，而把释放同类资源的进程称为该资源的生产者。

# 进程通信
通信意味着在进程间传递数据。

操作系统可以被看做是由各种进程组程度，例如用户进程、计算进程和打印进程 etc.。这些进程都具有各自独立的功能，且大多数被外部需要而启动执行。

**进程间的通信内容分类**
1.  控制信息的传送（低级通信）；目的为了控制进程执行速度 e.g.[[#进程互斥与同步|进程互斥与同步的信号量]]
2.  大批量数据的传送（高级通信）；目的为了交换信息

## 进程通信方式
1.  主从式
2.  会话式
3.  消息或邮箱机制
4.  共享存储区方式

**主从式**
(1)主进程可自由地使用从进程的资源或数据。
(2)从进程的动作受主进程的控制。
(3)主进程和从进程的关系是固定的。
*e.g.终端控制进程和终端进程*

**会话式**
进程双方可分别称为使用进程和服务进程。使用<u>进程调用服务进程</u>提供的服务。
*e.g.用户进程与磁盘管理进程在进行进程通信时有固定的连接关系*

**消息或邮箱机制**
无论接收进程是否已准备好接收消息，发送进程都将把所要发送的消息送入缓冲区或邮箱。

这里，消息(message)是用来区别于命令(command)或指令(instruction)等用语的。除了表示所交换的数据传递大量信息之外，消息还具有两个互相通信的进程地位平等的意思。消息的一般形式由 4 个部分组成，即发送进程名、接收进程名、数据和有关数据的操作。

特点如下：
- 只要存在空缓冲区或邮箱，发送进程就可以发送消息
- 与会话系统不同，发送与接收进程之间无直接连接关系
- 发送进程和接收进程之间存在缓冲区或邮箱用来存放被传送消息。

**共享存储区方式**
不要求数据移动。两个需要互相交换信息的进程通过对一共享数据区的操作来达到互相通信的目的。这个共享数据区是诶个互相通信进程的一个组成部分。

---
**邮箱通信**
由发送进程申请建立一个与接收进城链接的邮箱。发送进程把消息送往邮箱，接收进程从邮箱中取出消息，从而完成进程间的信息交换。

设置邮箱的最大好处是发送进程和接收进程之间没有处理时间上的限制。邮箱不像缓冲区被系统内所有进程共享。

**进程通信实例——和控制台的通信**

**进程通信的实例——管道**
会在内核中开辟出一块缓冲区用来进行进程间通信，这块缓冲区称为管道，它有一个读端和一个写端。

> 对比以上两种方法，我们也可以理解为，管道本质上就是一个文件，前面的进程以写方式打开文件，后面的进程以读方式打开。这样前面写完后面读，于是就实现了通信。实际上管道的设计也是遵循 UNIX 的“一切皆文件”设计原则的，它本质上就是一个文件。Linux 系统直接把管道实现成了一种文件系统，借助 VFS 给应用程序提供操作接口。

## 消息缓冲机制
利用消息缓冲作为进程通信的一种基本方式。

- 发送进程和接收进程采用消息缓冲机制进行数据传送时，发送进程在发送消息前，先在自己的内存空间设置一个发送区，把欲发送的消息填人其中，然后再用发送过程将其发送出去。
- 接收进程则在接收消息之前，在自己的内存空间内设置相应的接收区，然后用接收过程接收消息。

<u>通过操作系统底层的数据传输方式了解到用户使用的更为宏观的层次中，硬盘与 CPU 进行数据交换时所使用的的缓冲区方式是完全一致的。</u>

# 死锁
死锁是指各并发进程互相等待对方所拥有的资源，且这些并发进程在得到对方资源之前不会释放自己拥有的资源。从而造成大家都想得到资源而又得不到资源。

**死锁的起因**
==死锁的起因是并发进程的资源竞争。==产生死锁的根本原因在于系统提供的资源个数少于并发进程所要求的该类资源数。

显然，由于资源的有限性，不可能为所有要求资源的进程无限制地提供资源。但是，可以采用适当的资源分配算法，以达到消除死锁的目的。

## 产生死锁的必要条件
1.  互斥条件
2.  不剥夺条件
3.  部分分配
4.  环路条件
==只要以上四种条件的某一个不满足，即可消除死锁==

## 死锁的消除
> 一般而言，由于操作系统的并行与共享以及随机性等特点，通过预防和避免的手段达到消除死锁的目的是一件十分困难的事。这需要较大的系统开销，甚至不能充分利用资源。

死锁的检测和恢复则与此相反，不必花费多少执行时间就能发现死锁和从死锁中恢复出来。
**在实际操作系统中大都使用检测与恢复法消除死锁。**

预防、回避、检测与恢复 检测与恢复最为常见

# 线程
***为什么要引入线程？***
==进程是为了提高 CPU 的执行效率==，减少因为程序等待带来的 CPU 空转以及其他计算机软硬件资源的浪费而提出来的。进程是为了完成用户任务所需要的程序的一次执行过程以及为其分配资源的一个基本单位。

*为什么不能通过创建很多进程的方式来实现？*
- <u>系统资源角度：</u>理论上存在父进程和创建很多子进程的方式来实现高并发。但创建一个进程需要很大的系统开销和占用很多系统资源：至少要消耗一个 PCB 结构。若子进程过多，则占有系统的资源也越多。
- <u>并发访问数量角度：</u>并且针对于不确定的用户数以及随机访问的 Web 服务而言，用进程来管理用户会极大限制访问服务器的用户数
- <u>进程调度角度：</u>不同的用户子进程还涉及频繁的进程上下文切换

==为了减少进程切换和创建的开销，提高执行效率和节省资源，引入了线程（Thread）的概念。==

## 线程基本概念
线程是进程的一部分。有时又被称为轻权进程。
线程也是 CPU 调度的一个基本单位。

一个没有线程的进程可以被看做是单线程的。只有一个对应的寄存器和堆栈，执行过程在此进行和完成。
若一个进程拥有多个线程，则其执行过程中不再是唯一线状的，由多条线状执行过程组成。

## 线程与进程的区别
虽然进程和线程都是处理机调度的基本单位，但线程的改变只代表了 CPU 执行过程的改变，而进程所拥有的资源没有发生变化。
<u>即：除了 CPU 之外，计算机内软硬件资源的分配与线程无关，线程只能共享它所属进程的资源。</u>

==进程是系统资源分配时的基本单位==
==线程是 CPU 分配的基本单位==

- 进程拥有一个完整的虚拟地址空间。
- 进程不依赖于线程而独立存在。
- 线程是进程的一部分，它没有自己的地址空间，和进程内其他资源一起共享分配线程的全部资源。

- **引入线程后的重要结论和改变**
    - 在引入线程前，进程的两个基本属性是：1.可拥有资源的独立单位。2.可独立调度和分配的基本单位。
    - 后来为了使多个程序更好的并发执行，人们把上述两个属性分开，引入线程作为可独立调度和分配的基本单位。
    - **在无线程的系统中，进程是资源调度和并发执行的基本单位。在引入线程的系统中，进程退化为资源分配的基本单位，而线程代替进程被操作系统调度。** 线程便可以并发执行。

**线程控制块 TCB**
与进程控制表和 PCB 相似，每个线程也有自己的线程控制块(TCB)。
这个 TCB 中所保存的线程状态信息则要比 PCB 少得多，这些信息主要是相关指针用堆栈（系统栈和用户栈)以及寄存器中的状态数据。

## 线程的适用范围
使用线程的最大好处是在有多个任务需要处理机处理时可以减少处理机的切换时间； 而且，线程的创建和结束所需要的系统开销也比进程要小得多。由此，可以推出最适合使用线程的系统是多处理机系统、网络系统或分布式系统。

**典型应用：**
- 服务器中文件管理或通信控制
- 前后台处理
- 异步处理

## 线程分类
**用户级线程**
管理全部由用户程序完成，OS 内核只对进程进行管理。

> 为了对用户级线程进行管理，操作系统提供一个在用户空间执行的线程库。该线程库提供创建、调度和撤销线程功能。同时，该线程库也提供线程间的通信、线程的执行以及存储线程上下文的功能。用户级线程只使用户堆栈和分配给所属进程的用户寄存器。当一个线程被派生时，线程库为其生成相应的线程控制块(TCB)等数据结构，并为 TCB 中的参量赋值和把该线程置于就绪状态。其处理过程与进程创建过程大致相似。

- 用户级线程的调度算法和调度过程全部由用户自行确定，与 kernel 无关。
- 用户级线程的调度算法只进行线程上下文切换而不进行处理机切换，且线程切换与 kernel 无关。

> 因为用户级线程的上下文切换与内核无关，所以可能出现如下情况：即当一个进程由于 I/O 中断或时间片用完等原因造成该进程退出处理机，而属于该进程的执行中线程仍处于执行状态。也就是说，尽管相关进程的状态是阻塞的或等待的，但所属线程状态却是执行的。

^9611c2

**系统级线程/kernel**
由操作系统 kernel 进行管理。kernel 给应用程序提供相应的[[2 操作系统用户界面#接口 2-系统调用|系统调用]]和 API，以使用户程序可以创建，执行和撤销线程。

与用户线程不同，==内核级线程既可以被调度到一个处理机上并发执行，也可以被调度到不同的处理机上并行执行。操作系统内核既负责进程的调度，也负责进程内不同线程的调度工作==。因此，内核级线程不会出现[[3 进程管理#^9611c2|进程处于阻塞或等待状态，而线程处于执行状态的情况]]。

内核级线程也可用于内核程序自身，以提高 OS 内核程序执行效率。

**不同线程及进程上下文切换时的系统开销比较：**

| 操作      | 用户级线程 | 内核级线程 | 进程  |
| --------- | ---------- | ---------- | ----- |
| Null Fork | 34         | 948        | 11300 |
| 信号等待  | 37         | 441        | 1840  |

## 线程的执行特性
**基本状态**
1.  执行
2.  就绪
3.  阻塞

==线程无挂起/等待状态，即线程是一个只与内存和寄存器相关的概念，其内容不会因 swap 进入外存。==

*有些情况下，某个线程被阻塞也可能导致该线程所属进程被阻塞*

线程也存在同步和互斥机制，与进程类似。

# 小结
进程是操作系统中最重要、最基本的概念之一。它是系统分配资源的基本单位，是一个具有独立功能的程序段对某个数据集的一次执行活动。引入进程的概念是由操作系统的资源有限性、处理上的并行性以及系统用户的执行起始时间的随机性所决定的。一切仅具有静态特征的概念，例如程序，不能反映系统的上述特征，因此，导入了具有动态特征的进程概念。

尽管进程是一个动态概念，但是，从处理机执行的观点来看，进程仍需要静态描述。一个进程的静态描述是处理机的一个执行环境，被称为进程上下文。进程上下文由以下部分组成：PCB(进程控制块)、正文段和数据段以及各种寄存器和堆栈中的值。寄存器中主要存放将要执行指令的逻辑地址、执行模式以及执行指令时所要用到的各种调用和返回参数等。而堆栈中则存放 CPU 现场保护信息和各种资源控制管理信息等。

线程是为了提高操作系统的执行效率而引入的，它是进程内的一段程序的基本调度单位。线程可分为用户级线程和内核级线程。用户级线程的管理全部由线程库完成，与操作系统内核无关。线程由寄存器、堆栈以及程序计数器等组成，同一进程的线程共享该进程的进程空间和其他所有资源。线程主要用于多机系统以及网络系统的操作系统中。
