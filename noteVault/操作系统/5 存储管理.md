#第二遍阅读
# 存储管理的功能
存储器是计算机系统的重要资源之一。存储管理直接影响系统性能。

存储器由内存(primary storage)和外存(secondary storage)组成。**内存由顺序编址的块组成，每块包含相应的物理单元。** CPU 要通过启动相应的输入输出设备后才能使外存与内存交换信息。
## 虚拟存储器
此为内存管理/存储管理的核心概念。使用虚拟存储器的意义是兼顾内存的读写性能与外存的大容量。

>实验证明，在一个进程的执行过程中，其大部分程序和数据并不经常被访问。

因此，存储管理系统将进程中不经常访问的程序段和数据放入外存中，待需要时再将其调如内存。

*如何链接那些一部分在内存，一部分在外存的进程？*
- 旧办法：按照物理存储器的地址空间排序。程序编译会非常复杂。
- 虚拟存储器：编译链接程序把用户源程序编译后链接到一个以 0 地址为始地址的线性或多维虚拟地址空间。这里，链接既可以是在程序执行以前由链接程序完成的静态链接，也可以是程序执行过程中由于需要进行的动态链接。而且每一个进程都拥有这样一个空间。（此空间是几维由存储管理方式决定）

**虚拟存储器**
进程中目标代码，数据等虚拟地址组成的虚拟空间。

| 源程序   | 虚拟空间 | 物理存储器 |
| -------- | -------- | ---------- |
| 编译连接---> |  虚拟空间        | --->地址转换   |
<u>要实现此变换，需相应硬件支持</u>

**虚存不考虑物理存储器大小和信息存放的实际位置，只规定每个进程中互相关联信息的相对位置。**

与实际物理存储器的数量有限，且被所有程序共享不同，每个进程都拥有自己的虚拟存储器，且虚拟存储器的容量是由计算机的地址结构和寻址方式决定的。
如：CPU 有效地址长度为 16 位，则器寻址范围为 0~64K——由操作系统本身的位数决定。

**虚拟地址**
每个指令和数据单元在这个虚拟空间中确定的地址。显然，某个进程在该空间的地址排列可以是非连续的。
**其真实物理地址经变换得到。**

## 地址变换
**内存空间/物理地址空间**
内存地址的集合。
内存中每一个存储单元都与相应的称为内存地址的编号相对应
内存空间是***一维线性物理空间***。

*如何将几个虚存的一维或多维线性空间变换到内存唯一的一维线性物理空间？*
1.  虚拟空间划分问题
2.  地址映射或重定位问题（虚拟地址映射为内存地址）

**虚拟空间划分问题**
划分方式 e.g.
进程空间+系统空间
程序区 控制区 系统区 保留区

**实现地址映射问题的方法：**
- **静态地址重定位**

只完成一个首地址不同的连续地址变换。它要求所有待执行的程序必须在执行之前完成它们之间的链接，否则将无法得到正确的内存地址和内存空间。

优点：无需硬件支持
缺点：无法实现虚存。与虚存建立和目的思想背道而驰。

- **动态地址重定位**
在程序执行过程中，CPU 访存前，将要访问的程序或数据地址转换为内存地址。动态地址重定位依靠硬件地址变换机构完成。

具体实现：地址重定位机构
m 个基地址寄存器 BR+n 个程序虚拟地址寄存器 VR===>共同构成指令或数据的内存地址 MA
$$MA = (BR) + (VR)$$
优点：
- 对内存非连续分配。
- 是实现虚存的基础。
- 利于程序段共享。

## 内外存数据传输控制
要实现内存扩充，就需要在内外存之间频繁地交换数据。
*何种方式控制内外存间数据流动 Data Flow*
1.  用户程序自行控制
2.  OS 控制

- 用户自行控制：
    - **覆盖 overlay**

早期内存扩充技术。用户需指定好各程序调入 memory 的先后次序。

- OS 控制：
    - **交换 swapping**
        - 将内存等待状态进程换出内存；将处于外存就绪态进程换入内存。
    - **请求调入 on demand**
        - 程序执行时，要访问的程序或数据段不在内存，OS 自动从外存调入到内存的控制方式。
    - **预调入 on prefetch**
        - 由 OS 预测将来会访问到的程序段或数据段，在其访问前调入内存。

**只有请求调入和预调入能够实现大小不受内存容量限制的虚存**
*在这种情况下交换为什么不能实现虚存？*
交换不进行部分程序段或数据段的交换，其会交换整个进程。并且完成的部分交换也只是将受资源限制，暂时不能执行的程序段换出内存。
因此，虽然交换方式也能完成内存扩充任务，但无法实现自动覆盖，内外存统一管理。

**即：虚存的本质意义在于 seamless 让用户和进程无感切换内外存。**

## 内存的分配与回收
内存分配与回收是内存管理的主要功能之一。
*能否将外存中的数据和程序调入内存，取决于能否在内存中为其安排合适的位置。*

**存储管理为每个并发执行的进程分配内存空间。进程执行结束后，存储管理模块及时回收进程所占内存资源，以便分配给其他进程使用。**

- 分配结构
- 放置策略
- 交换策略
- 调入策略
- 回收策略

## 内存信息的共享与保护
> 在多道程序设计环境下，内存中的许多用户程序或系统程序和数据段可供不同的用户进程共享。这种资源共享将会提高内存的利用率。但是，反过来说，除了被允许共享的部分之外，又要限制各进程只在自己的存储区活动，各进程不能对别的进程的程序和数据段产生干扰和破坏，因此必须对内存中的程序和数据段采取保护措施。
> 即：既要在一定程度上实现用户进程间的共享，同时又需要做好足够的保护措施。

常用的内存信息保护法：硬件法、软件法、软硬件结合法。

**上下界保护法**（硬件）——即界限寄存器
为每个进程设置一对上下界寄存器，其中装有保护程序和数据段的起始地址与终止地址。

| 上界寄存器 UR | 下界寄存器 LR |
| ------------ | ------------ |
| 100K         | 200K         |

对内存的访问首先通过上下界进行访址合法性检查，若超过对应范围，则产生访址越界中断。

**保护键法**（软件）
为每一个被保护存储块分配单独保护键。
在程序状态字中设置相应的保护键开关字，对不同进程赋予不同的开关代码与被保护的存储块中的保护键匹配。
如果访问被保护禁止，则会产生访问出错中断。

即：每个指令被分配一个保护键，其与内存中的开关字比较，相同则允许读/写，不同则产生中断。

保护键可以对读写分别或同时设置保护策略。

**界限寄存器与 CPU 用户态/核心态相结合**（软硬件结合）
> 在这种保护方式下，**用户态进程**只能访问那些在界限寄存器所规定范围内的内存部分，而**核心态**进程则可以访问整个内存地址空间。
> UNIX 系统就是采用的这种内存保护方式。

# 分区存储管理
**分区存储管理是把内存划分成若干大小不等的区域，除 OS 占用一个区域以外，其余由多道环境下的各并发进程共享。**

> 分区管理是满足多道程序设计的一种最简单的存储管理方法。
## 分区基本原理
**基本原理**
给每一个内存中进程划分一块适当大小的存储区，以连续存储各进程的程序和数据。使各进程并发执行。

按照分区的时机可分为固定与动态分区方法。

### 固定分区法
把内存固定地划分为若干大小不等的区域。分区原则一般由系统操作员或 OS 决定。
分区一旦划分结束，整个执行过程中将保持不变。

**分区说明表**
OS 对内存的管理和控制通过分区说明表实现。
> 分区号、分区大小、起始地址和分区状态（是否空闲区）。
> 内存的分配实发、存储保护及地址变换都通过分区说明表实现。

![](https://img2018.cnblogs.com/blog/1734701/201911/1734701-20191121092748982-1252964356.png)

**缺点**：
内存利用率低。即使是小作业也要占用同等大小的分区。

### 动态分区法
作业执行前不建立分区，分区的建立是在作业的处理过程中进行的。其大小可随作业或进程对内存的要求而改变。

> 采用动态分区法，在系统初启时，除了操作系统中常驻内存部分之外，只有一个空闲分区。随后，分配程序将该区依次划分给调度选中的作业或进程。

随着进程执行，会出现一系列分配和释放。

![](https://img2018.cnblogs.com/blog/1734701/201911/1734701-20191121093345326-579125164.png)

*如何进一步划分不合适的内存空闲区大小？*
如果分配的空闲区比所要求的大，则管理程序将该空闲区分成两个部分，其中一部分成为已分配区，而另一部分成为一个新的小空闲区。

- 出现相应的内存分区管理：合并 拆分
	- 最先适应算法
	- 最佳适应算法
	- 最坏适应算法
	- 临近适应算法

下一节详细说明。

**内存数据管理结构**
使用**分区说明表、可用表或分区自由链**。以描述系统的内存资源情况。
与此对应，请求内存资源的作业也构成一个内存资源请求表。
- 可用表
	- 可用表的每个表目记录一个空闲区，主要参数包括区号、分区长度和起始地址。采用表格结构，管理过程比较简单，但表的大小难以确定，要占用一部分内存。

- 自由链
	- 利用每个内存空闲区的头几个单元存放本空闲区的大小及下个空闲区的起始地址，从而把所有的空闲区链接起来。然后，系统再设置一个自由链首指针让其指向第一个空闲区，这样，管理程序可通过链首指针查到所有的空闲区。
	- 优缺点：其优缺点的来源全部来自链表这种数据结构本身。即：易存储，易顺序遍历，难随机查找。
		- **优点**：链式管理，且无需额外内存。
		- **缺点**：查找困难。

以上无论可用表还是自由链方式都需按一定规则排列，便于分区分配与回收。
## 分区的分配与回收
### 固定分区
**分配**
用户通过请求表提出需求。存储管理程序查询分区说明表，将满足要求的空闲分区分配。

**回收**
进程执行完毕，将分区状态置为未使用。

### 动态分区
动态分区分配与回收主要解决 3 个问题

> 
> 1. 对于请求表中的要求内存长度，从可用表或自由链中寻找出合适的空闲区分配程序。
> 2. 分配空闲区之后，更新可用表或自由链。
> 3. 进程或作业释放内存资源时，和相邻的空闲区进行链接合并，更新可用表或自由链。

说人话：
1.  怎么找空闲
2.  空闲区大了，小了怎么办
3.  合并碎片

***从可用表或自由链中寻找空闲区的方法：***
**最先适应 first fit**——*快 无需排序*
可用表或自由链起始地址按递增次序排列。
一旦找到第一个≥需求长度的分区，则退出。

找到后划出要求长度，将余下部分合并（如果有相邻空闲存在）留在可用表中。

**最佳适应 best fit**——*省 低地址充分利用*
可用表或自由链按从小到大次序排列。
存储管理程序从表头起查找，一旦找到第一个≥需求长度的分区，则退出。

找到后划出要求长度，将余下部分合并（如果有相邻空闲存在）留在可用表中。
- 保证了高地址有较大空间放置对内存要求多的进程或作业。找到最适应，但不一定会增加内存利用率。

**最坏适应 worst fit**——*志在消灭空闲碎片*
可用表或自由链按大小递减次序排列。
一旦找到第一个≥需求长度的分区，则退出。

找到后划出要求长度，将余下部分合并（如果有相邻空闲存在）留在可用表中。
- 期望分配后的剩余空间仍能进行再分配。

### 分区拼接
当用户作业或进程执行结束时，存储管理程序要收回已使用完毕的空闲区，并将其插入空闲区可用表或自由链。在插入时便遇到了分区拼接问题。

如果不对空闲区拼接，则会出现大量分散的小空闲区，非常浪费内存空间。
- 分区拼接的 4 种情况：
	- 上下相邻区都是空闲区
	- 上相邻区是空闲区
	- 下相邻区是空闲区
	- 空闲区的上下都不是空闲区：释放区作为一个新的空闲可用区插入可用表或自由链。

- 各种分区管理算法比较：
	- 查找速度方面：最先适应性能最好。
	- 回收过程：最先适应性能最好。
	- 最佳适应法找到的空闲区是最佳的。但会增加内存碎片数量。
	- 最坏适应算法的目的是基于不留下碎片空闲区这一出发点的。期望剩余空闲区能再分配。

---

**Important discussiones**
1.  分区管理无法实现虚存。每个用户进程所需内存容量受分区大小限制。
2.  分区管理使用覆盖和交换技术扩充内存。——*使用覆盖和交换就意味着无法实现真正的虚存*
3.  动态分区使用动态地址重定位技术。*obviously*
4.  分区管理使用保护键法。

## 分区管理优缺点
**优点**
1.  实现了多作业或进程对内存的共享，有助于多道程序设计，提高 OS 资源利用率。
2.  实现容易

**缺点**
1.  内存利用率低。碎片多。
2.  作业或进程受分区大小限制。说白了没实现虚存。
3.  无法实现分区间信息共享。

# 覆盖与交换
覆盖与交换技术在多道环境下用来扩充内存的两种方法。
## 覆盖
> 覆盖技术是基于这样一种思想提出来的：一个程序并不需要一开始就把它的全部指令和数据都装人内存后再执行。在单 CPU 系统中，每一时刻事实上只能执行一条指令。
> 因此，不妨把程序划分为若干个功能上相对独立的程序段，按照程序的逻辑结构让那些不会同时执行的程序段共享同一块内存区。通常，这些程序段都被保存在外存中，当有关程序段的先头程序段执行结束后，再把后续程序段调入内存覆盖前面的程序段。这使得用户看来， 好像内存扩大了，从而达到了内存扩充的目的。

**说人话即：无需同时驻留内存的两段程序 可以共享同一段内存区。**

覆盖技术要求程序员提供清晰的覆盖结构，必须将程序提前划分成程序段。

## 交换 swap
同时存在于内存中的进程，有些处于执行或就绪状态，有些处于等待状态。
交换技术类似于处理机调度中的[[4 处理机调度|交换调度]]
- **swap 将处于等待状态的进程换出内存，以提高内存空间利用率**。
- **swap 在进程或作业间进行，而覆盖主要在进程或作业内部进行。**
- swap 只针对整个的进程或作业，这也是其不能实现虚存的原因。

广义地说，交换是指先将内存某部分的程序和数据写入外存交换区，再从外存交换区中调入指定的程序或数据到内存中来，并让其执行的一种内存扩充技术。
- 换出：内存中的数据和程序换到外存交换区
- 换入：viceversa


# 页式管理
## 页式管理基本原理
> 页式管理正是为了**减少碎片**以及为了只在内存存放那些反复执行或即将执行的程序段与数据部分，而把那些不经常执行的程序段和数据存放于外存，待执行时调入，以**提高内存利用率**而提出来的。

**从页式管理开始便利用请求调页和预调页技术成功实现了虚存。**

- **各进程的虚拟空间被划分为若干个长度相等的页（page）。**
	- 经过页划分后，进程的虚地址变为页号 P 与页内地址 W 组成。
	- 页长的划分和内存、外存间的数据传输速度及内存大小有关
- **内存空间按页的大小划分为片或页面（page frame）。**
	- 这些页面为系统中任一进程所共享。

| 页号 P | 页内地址 |
| ----- | -------- |

<u>相当于有了两个衡量和参考的维度：一个是以进程的空间-页号，另一个是以内存空间-页面号</u>
- 优点：
	- **内存中碎片的极大减少。**因为任意一个碎片都会小于一个页面
	- **实现了由连续存储到非连续存储的飞跃。**

==用户进程在页面间不再连续。实现了从连续到非连续管理的飞跃。为虚存的真正实现打下了基础。==

*如何由页式虚拟地址 变换为 内存页面物理地址？*
- **页式虚地址与页面物理地址建立一一对应的页表，并用地址变换机构解决离散地址变换。**
页表是[[5 存储管理#地址变换|动态重定位技术]]的一种延伸。

- **采用请求调页或预调页技术实现内外存统一管理。即实现了虚存**
	- 基于工作区的局部性原理建立。

- **页面的分配与回收与页面淘汰和缺页处理技术结合。**

==**页式管理的重点在于页划分后的地址变换，以及页面调入调出技术**。==

## 静态页面管理
在作业或进程开始执行之前，把该作业或进程的程序段和数据**全部**装入内存的各个页面中，并通过页表和硬件地址变换机构实现虚拟地址到内存物理地址的映射。
### 页面分配与回收
第一步：为要求内存的作业或进程分配足够的页面。
**页表**
页号+页面号组成
***每个进程至少拥有一个页表***

| 页号 | 页面号 |
| ---- | ------ |
|      |        |

**请求表**
类似分区说明表。用来确定作业或进程的虚拟空间各页在内存中的实际对应位置。
***整个系统需要一张请求表***

| 进程号 | 请求页面数 | 页表始地址 | 页表长度 | 状态 |
| ------ | ---------- | ---------- | -------- | ---- |
|        |            |            |          |      |

**存储页面表**
指出内存各页面是否已被分配。
***整个系统一张存储页面表***

- 位示图法
	- 利用方格状的表来分配和处理页面的分配情况。
- 空闲页面链法
	- 使用了空闲页面本身的单元存放指针，不占据额外的内存空间


### 分配算法
请求表----->存储页面表检查空间是否充足----->查找空闲页面，分配页表

执行完毕----->拆除页表----->使用完的页表插入空闲页面表
### 页面地址变换
#难点
*怎样由页号和页内相对地址变换到内存物理地址？*
**重点：先找页号，找出对应的页面号，具体使用页面号进行操作。——因为真正的内存地址分配是在页面中处理的。**
- 连续的页号对应着不连续的页面号——每个页面是被分配到各个页当中去的
- 变换过程中包含变换指令的地址+数据地址
- 类似动态重定位，内存真实地址 = 页面地址（物理内存中）+页内相对地址

综合两张表：**页**    **页表**
进行两块寻址：**程序（指令）段**  **数据集**

**全部由地址转换机构自动完成**
页表驻留在内存中。<u>取一次指令或数据至少需要访址两次以上。</u>

**优化寻址速度：**
将存于内存中的页表转换为存储在*高速联想寄存器中的快表*。提升查找速度。

> 静态页式管理解决了分区管理时的碎片问题。但是，由于静态页式管理要求进程或作业在执行前全部装人内存，如果可用页面数小于用户要求时，该作业或进程只好等待。而且，作*业或进程的大小仍受内存可用页面数的限制。* 这些问题将在动态（请求）页式管理中解决。
> **即：碎片问题仍存在。静态页式管理仍未实现虚存。**

## 动态页式管理
在静态的基础上发展而来。

请求页式管理和预调入页式管理在作业或进程开始执行之前，都不把作业或进程的程序段和数据段一次性地全部装入内存，而只装入被认为是经常反复执行和调用的工作区部分。其他部分则在执行过程中动态装人。

**请求页式管理与预调入页式管理的主要区别在它们的调入方式上。** 
请求页式管理的调入方式是，当需要执行某条指令而又发现它不在内存时，或当执行某条指令需要访问其他的数据或指令，而这些指令和数据不在内存中时，即发生**缺页中断**，系统将外存中相应的页面调入内存。

预调入页式管理的调人方式是，系统对那些在外存中的页进行调入顺序计算，估计出这些页中指令和数据的执行和被访问的顺序，并按此顺序将它们顺次调入和调出内存。

**除了在调入方式上请求页式管理和预调入页式管理有些区别之外，在其他方面这两种方式基本相同。**

### 请求&预调入页式管理
**置换算法在内存中没有空闲页面时被调用，它的目的是选出一个被淘汰的页面。** 因此，如果内存中有足够的空闲页面存储调入的页，则不必使用调入算法。

内外存统一管理的真正目的是把那些被访问概率非常高的页存放到内存中。因此，置换算法应该置换那些被访问概率最低的页，将它们移出内存。

两个基本问题：
*怎样发现不在内存中的虚页？*
方法：扩充页表。即与每个虚页号相对应。增设判断是否在内存中的中断位及外存中始地址。

*怎样处理虚页不在内存中的情况？*
即：内存中的页面淘汰算法。
方法：扩充页表。增设记录该页是否发生改变的改变位。

*缺页的调入和存放*
即：内存页面置换算法。
容易出现抖动问题。
即调回内存的页面不久后又被调出，如此反复。页面调度过于频繁，以至于大量时间用于调页面。

*缺页缺的是什么？*
<u>缺的是指令或数据所在的页。而页是身处于一个操作系统分配的内存页面中的。如果想要找到当前缺失的这一页，则需要在不同的大页面块中进行寻找；如果找到则 ok，没有找到则需要置换这个页面，到新的页面上寻找缺失的页（page）。</u>
所以下面的算法被称为页面置换算法。

**[[5 存储管理#页面地址变换|地址变换]]**
过程与静态相同。
当硬件变换机构发现缺页，产生缺页中断信号，由中断处理程序进行相应处理。
中断处理程序由软件实现。除了选择淘汰页面还需要从外存读入虚页，涉及外存及文件系统。
> 内存利用率的提高是以牺牲系统开销代价换来的。

==**页面置换算法==**
1.  随机淘汰
completely random

2.  Round Robin
循环换出内存可用区内可被换出的页。和其他因素均无关。

3.  FIFO
严格先进先出。最先调入的页被调出。

**Belady 现象**
在未给进程或作业分配足够的页面数时，会出现分配的页面数增多，缺页次数反而增加的奇怪现象。

> 由实验和测试发现 FIFO 算法和轮转法的内存利用率不高。这是因为，这两种算法都是基于 CPU 按线性顺序访问地址空间的这个假设。事实上，许多时候，CPU 不是按线性顺序访问地址空间的，例如在执行循环语句时。因此，那些在内存中停留时间最长的页往往也是经常被访问的页。尽管这些页变“老”了。但它们被访问的概率仍然很高。

4.  最近最久未使用 LRU
当需要淘汰某一页时，选择离当前时间最近的一段时间内最久未被使用过的页淘汰。 ^ed8554

由于完全使用需要巨大的系统开销：LRU——时间+使用双限制，实际中经常使用其近似算法：
- 最不经常使用 LFU——时间最近
- 最近没有使用 NUR——使用最少

5.  理想型淘汰算法 OPT
无法实现。因为其需要预知未来进程访问序列。

## 页式管理优缺点
**优点**
- 有效解决碎片问题：因为无需连续存放
- 提供内外存统一管理的虚存实现。提高内存利用率且有利于多道程序运行。
**缺点**
- 需要相应的硬件支持
- 增加系统开销
- 可能产生抖动问题
- 仍有一部分（最后一页）的内存空间未被利用。

# 段式管理
> 分区式管理和页式管理时的进程地址空间结构都是线性的，这要求对源程序进行编译、链接时，把源程序中的主程序、子程序和数据区等按线性空间的一维地址顺序排列起来。这使得不同作业或进程之间共享公用子程序和数据变得非常困难。
> ——无法实现共享

> 再者，从链接的角度看，分区管理和页式管理只能采用静态链接。一个大的进程可能包含数百个甚至上千个程序模块。对它们进行链接要花费大量的CPU时间，而实际执行时则可能只用到其中的一个子集。因此，从减少CPU开销和存储空间浪费的角度来看，静态链接是不合适的。
> ——无法使用动态链接

==段式存储管理是基于为用户提供一个方便灵活的程序设计环境而提出的。==

**基本思想**
把程序按内容或过程（函数）分段，独立命名。一个作业或进程包含的段对应于一个二维线性虚拟空间，即二维虚拟存储器。内存管理程序以段为单位分配内存，通过地址变换机构映射到实际物理地址。

## 实现原理
**段式虚拟空间**
二维结构

| 段号 s | 段内相对地址 w |
| ----- | ------------- |
**段式管理中段号与段号之间无顺序关系。段也不具有相同的页长，长度不固定。每个段定义一组逻辑上完整的程序或数据。**

每个段是一个首地址为零的、连续的一维线性空间。根据需要，段长可动态增长。对段式虚地址空间的访问包括两个部分：段名和段内地址。

> 一维空间：页式管理。页号按递增排列。线性。

类似于二维数组。其中一个维度中含的都是一维数组。合并起来成为了二维结构。

### 段式管理内存分配与释放
**分配**
以段为单位，每段分配一个连续内存区。
同一进程所含各段之间不要求连续。

随着进程的执行，进程根据需要随时申请调入新段和释放老段。

**段式管理内存分配与释放在执行过程中动态进行。**
*内存中有足够的空闲区时*
OS 用相应表格或数据结构管理内存空闲区。采用和[[5 存储管理#动态分区法|动态分区管理]]相同的空闲区管理方法。(最先，最佳最坏 .etc.)

*内存中无足够内存区满足段的内存要求时*
段式管理程序根据给定内存置换算法淘汰一段时间内 CPU 不访问的段，即淘汰访问概率最低的段。
采用[[5 存储管理#动态页式管理|动态页式管理]]相同的那些置换算法均可。

**任何一个段长不允许超过内存可用区长度**

> 除了初始分配之外，段的动态分配是在 CPU 所要访问的指令和数据不在内存时产生缺段中断的情况下发生的。因此，段的淘汰或置换算法实际上是缺段中断处理过程的一部分。

### 段式管理地址变换
两个问题：
*段式管理程序如何感知到访问的段不在内存中？*
*二维空间虚拟地址如何变换为一维线性物理地址？*
均由段式地址变换机构解决。

**段表**
与页表类似。为一个进程或作业建立段表。

| 段号 | 始地址 | 长度 | 存取方式 | 内外 | 访问位 |
| ---- | ------ | ---- | -------- | ---- | ------ |
|      |        |      |          |      |        |
和页式管理方案类似，段式管理程序在进行初始内存分配之前，首先根据用户要求的内存大小为一个作业或进程建立一个段表，以实现动态地址变换和缺段中断处理及存储保护等。与页式管理时一样，段式管理也是通过段表来进行内存管理的。

**动态地址变换**
段表始址--->访问段表----->根据段号 s----->辅助段内相对地址 w----->实际内存地址
![](https://img-blog.csdn.net/20160311131653886)
**同样段式管理的地址变换也需要两次以上的内存访问**。为提高访问速度，也可以将段表存入高速联想寄存器。

### 共享与保护
**段的共享**
在内存中只保留一个程序的副本供多个用户使用。
![](https://img2018.cnblogs.com/blog/1734701/201911/1734701-20191124121848587-584731530.png)
另外，在多道环境下，由于进程的并发执行，一段程序为多个进程共享时，有可能出现多次同时重复执行该段程序的情况（即某个进程在未执行完该段程序之前，其他并发进程又已开始执行该段程序)。——类似于数据库中的[[SQL基础知识#脏读|脏读和幻读]]。
这就要求在执行过程中，该段程序的指令和数据不能被修改。还有， 与一个进程中的其他程序段一样，共享段有时也要被换出内存。这时，就要在段表中设立相应的共享位来判别该段是否正被某个进程调用。显然一个正在被某个进程使用或即将被某个进程使用的共享段是不应该调出内存的。

**保护**
- 地址越界保护法
	- 利用段表中的段长一项与虚拟地址中段内相对地址的比较进行。
	- 若段内相对地址>段长，系统会产生保护中断。
	- 段表中应设置相应的增补位以指示该段是否允许动态增长
- 存取方式保护法

## 段式管理优缺点
**优点**
- 提供了内外存统一管理的虚存实现
- 段长可动态增长
- 便于信息段共享
- 便于实现动态链接。

**缺点**
- 碎片问题比页式更严重。
- 每个段长度受内存可用区大小限制。
- 选择淘汰算法时和页式管理相同，可能会产生抖动现象。

# 段页式管理
> 以上几种存储管理方式各有特长。段式管理为用户提供了一个二维的虚地址空间，反映了程序的逻辑结构，有利于段的动态增长、共享和内存保护等，这大大地方便了用户。
> 
> 而分页系统则有效地克服了碎片，提高了存储器的利用率。从存储管理的目的来讲，主要是方便用户的程序设计和提高内存的利用率。

那么，把段式管理和页式管理结合起来让其互相取长补短不是更好吗？于是，段页式管理方式便被提了出来。
## 实现原理
### 虚地址构成
**段页式管理时，一个进程仍然拥有一个自己的二维地址空间，与段式管理相同。**

- 一个进程中所包含的具有独立逻辑功能的程序或数据仍被划分为段，并有各自的段号 s——反映了段式管理的特征。
- 对于段 s 中的程序或数据，按照一定大小将其划分为不同的页。和页式系统一样，最后不足一页的部分仍占一页——反应了页式管理的特征。

即：原来段式管理的情况相当于`大段[段[n]]`
而合并两种管理方式后的情况相当于`大段[页[n]]`

| 段号 s | 页号 p | 页内相对地址 d |
| ----- | ----- | ------------- |
**p 和 d 一起构成了段式管理中的段内相对地址 w**

***此时虚拟空间中的最小单位是页***
==由于虚拟空间的最小单位是页而不是段，从而内存可用区也就被划分成为若干个大小相等的页面，且每段所拥有的程序和数据在内存中可以分开存放。分段的大小也不再受内存可用区的限制。==

**段表和页表**
段表和页表本身与纯页式和纯段式管理的情况相同。只是需要将段表每一项的指向地址改为页表地址。
![](https://images.gitee.com/uploads/images/2020/1005/121012_416e26e1_508704.png)

### 动态地址变换过程
OS 为每个进程建立一张段表。每一个段又被划分为若干页，每个段则必须建立一张页表，以进行地址变换。

段表----->页表----->真实内存地址

**至少需要访问 3 次以上内存。** 也可以使用高速联想寄存器提高运行速度。
1. 由段表地址寄存器得到段表始址去访问段表。取出对应段的页表地址。
2. 访问页表得到要访问的物理地址。
3. 访问真正的内存物理单元。

**有关段页式管理中的存储保护和共享以及缺段或缺页中断处理等，可参照段式管理或页式管理中的方法解决。**

## 段页式管理优缺点
**优点**
- 兼具段、页二者优点

**缺点**
- only 运行速度慢。

# 局部性原理和抖动问题
*什么是局部性原理，在什么条件和情况下会产生？*
各种实现了虚拟存储器的存储管理方法，实质上要在内存和外存之间频繁交换信息。因此，就要不断地启动外设以及相应的处理过程。

> 外存的访问速度远低于内存，如果一个系统的缺页率过高，意味着使得性能的主要开销浪费在反复调入调出数据和程序段上，从而使得真正有需要的用户程序效率大幅降低。这就是这个问题的出现动机。

此处和数据结构中的[[6 搜索树#伸展树|B 树，伸展树]]的存储结构有着相似的目的。

针对于需要进行内外存交换信息的存储管理方法：
动态页式管理，段式管理，段页式管理

解决反复调入调出的问题，提高运行速度和运行效率。

**局部性原理**
> 由模拟实验知道，在几乎所有的程序的执行中，在一段时间内，CPU 总是集中地访问程序中的某一个部分而不是随机地对程序所有部分具有平均访问概率。

如果不能正确地将那些系统需要的局部段放入内存，则系统效率必然大大降低，甚至无法正常工作。
![](https://github.com/CaesarYangs/MyPictureHotel/blob/main/Basic/OS/IMG_F702FC416643-1.jpeg?raw=true)

**工作集**
任何程序在局部性放入时，都有临界值要求。内存分配小于此值，内外存交换会显著增加；大于此值，再增大内存分配也不能显著减少交换次数。

> 在物理系统中，为了防止抖动的产生，在进行淘汰或置换时，一般总是把缺页进程锁住， 不让其换出，而调入的页或段总是占据那些暂时得不到执行的进程所占有的内存区域，从而扩大缺页进程的工作集。UNIX System V 中就是采用的这种方法。

# 小结
![](https://img-blog.csdnimg.cn/201907151214090.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5dGhvbl9qZWZm,size_16,color_FFFFFF,t_70)




[Paging in Operating System - GeeksforGeeks](https://www.geeksforgeeks.org/paging-in-operating-system/)

