
# 存储管理的功能 #第一遍阅读 
存储器是计算机系统的重要资源之一。存储管理直接影响系统性能。

存储器由内存(primary storage)和外存(secondary storage)组成。**内存由顺序编址的块组成，每块包含相应的物理单元。** CPU要通过启动相应的输入输出设备后才能使外存与内存交换信息。
## 虚拟存储器
此为内存管理/存储管理的核心概念。使用虚拟存储器的意义是兼顾内存的读写性能与外存的大容量。

>实验证明，在一个进程的执行过程中，其大部分程序和数据并不经常被访问。

因此，存储管理系统将进程中不经常访问的程序段和数据放入外存中，待需要时再将其调如内存。

*如何链接那些一部分在内存，一部分在外存的进程？*
- 旧办法：按照物理存储器的地址空间排序。程序编译会非常复杂。
- 虚拟存储器

**虚拟存储器**
进程中目标代码，数据等虚拟地址组成的虚拟空间。
>编译链接程序把用户源程序编译后链接到一个以0地址为始地址的线性或多维虚拟地址空间。这里，链接既可以是在程序执行以前由链接程序完成的静态链接，也可以是在程序执行过程中由于需要而进行的动态链接。而且，每一个进程都拥有这样一个空间。
>（此空间是几维由存储管理方式决定）

| 源程序   | 虚拟空间 | 物理存储器 |
| -------- | -------- | ---------- |
| 编译连接---> |  虚拟空间        | --->地址转换   | 
<u>要实现此变换，需相应硬件支持</u>

**虚存不考虑物理存储器大小和信息存放的实际位置，只规定每个进程中互相关联信息的相对位置。**


**虚拟地址**
每个指令和数据单元在这个虚拟空间中确定的地址。显然，某个进程在该空间的地址排列可以是非连续的。
**其真实物理地址经变换得到。**


## 地址变换
**内存空间/物理地址空间**
内存地址的集合。内存空间是***一维线性物理空间***。

*如何将几个虚存的一维或多维线性空间变换到内存唯一的一维线性物理空间？*
1. 虚拟空间划分问题
2. 地址映射问题（虚拟地址映射为内存地址）

划分方式e.g.
进程空间+系统空间

实现地址映射的方法：
- **静态地址重定位**

只完成一个首地址不同的连续地址变换。它要求所有待执行的程序必须在执行之前完成它们之间的链接，否则将无法得到正确的内存地址和内存空间。

优点：无需硬件支持
缺点：无法实现虚存。与虚存建立和目的思想背道而驰。

- **动态地址重定位**

在程序执行过程中，CPU访存前，将要访问的程序或数据地址转换为内存地址。

具体实现：地址重定位机构
m个基地址寄存器BR+n个程序虚拟地址寄存器VR===>共同构成指令或数据的内存地址MA
$$MA = (BR) + (VR)$$
优点：
- 对内存非连续分配。
- 是实现虚存的基础。
- 利于程序段共享。


## 内外存数据传输控制
*何种方式控制内外存间数据流动 Data Flow*
1. 用户程序自行控制
2. OS控制

用户自行控制：
- **覆盖 overlay** 

早期内存扩充技术。用户需指定好各程序调入memory的先后次序。

OS控制：
- **交换 swapping**

将内存等待状态进程换出内存；将处于外存就绪态进程换入内存。

- **请求调入 on demand**

程序执行时，要访问的程序或数据段不在内存，OS自动从外存调入到内存的控制方式。

- **预调入 on prefetch**

由OS预测将来会访问到的程序段或数据段，在其访问前调入内存。


**只有请求调入和预调入能够实现大小不受内存容量限制的虚存**
交换不进行部分程序段或数据段的交换，其会交换整个进程，无法实现自动覆盖，内外存统一管理。
即：虚存的意义在于seamless 让用户和进程无感切换内外存。

## 内存的分配与回收
内存分配与回收是内存管理的主要功能之一。
*能否将外存中的数据和程序调入内存，取决于能否在内存中为其安排合适的位置。*

**存储管理为每个并发执行的进程分配内存空间。进程执行结束后，存储管理模块及时回收进程所占内存资源，以便分配给其他进程使用。**

- 分配结构
- 放置策略
- 交换策略
- 调入策略
- 回收策略


## 内存信息的共享与保护
> 在多道程序设计环境下，内存中的许多用户程序或系统程序和数据段可供不同的用户进程共享。这种资源共享将会提高内存的利用率。但是，反过来说，除了被允许共享的部分之外，又要限制各进程只在自己的存储区活动，各进程不能对别的进程的程序和数据段产生干扰和破坏，因此必须对内存中的程序和数据段采取保护措施。

常用的内存信息保护法：硬件法、软件法、软硬件结合法。

**上下界保护法**（硬件）
为每个进程设置一对上下界寄存器，其中装有保护程序和数据段的起始地址与终止地址。

| 上界寄存器UR | 下界寄存器LR |
| ------------ | ------------ |
| 100K         | 200K         | 

对内存的访问首先通过上下界进行访址合法性检查，若超过对应范围，则产生访址越界中断。

**保护键法**
为每一个被保护存储块分配单独保护键。
在程序状态字中设置相应的保护键开关字，对不同进程赋予不同的开关代码与被保护的存储块中的保护键匹配。

即：每个指令被分配一个保护键，其与内存中的开关字比较，相同则允许读/写，不同则产生中断。

保护键可以对读写分别或同时设置保护策略。

**界限寄存器与CPU用户态/核心态相结合**
> 在这种保护方式下，用户态进程只能访问那些在界限寄存器所规定范围内的内存部分，而核心态进程则可以访问整个内存地址空间。
> UNIX系统就是采用的这种内存保护方式。

# 分区存储管理
**分区存储管理是把内存划分成若干大小不等的区域，除OS占用一个区域以外，其余由多道环境下的各并发进程共享。**

> 分区管理是满足多道程序设计的一种最简单的存储管理方法。
## 分区基本原理
**基本原理**
给每一个内存中进程划分一块适当大小的存储区，以连续存储各进程的程序和数据。使各进程并发执行。

按照分区的时机可分为固定与动态分区方法。

### 固定分区法
把内存固定地划分为若干大小不等的区域。分区原则一般由系统操作员或OS决定。
分区一旦划分结束，整个执行过程中将保持不变。

**分区说明表**
OS对内存的管理和控制通过分区说明表实现。
> 分区号、分区大小、起始地址和分区状态（是否空闲区）。
> 内存的分配实发、存储保护及地址变换都通过分区说明表实现。

![](https://img2018.cnblogs.com/blog/1734701/201911/1734701-20191121092748982-1252964356.png)

**缺点**：
内存利用率低。即使是小作业也要占用同等的大分区。

### 动态分区法
作业执行前不建立分区，分区的建立是在作业的处理过程中进行的。其大小可随作业或进程对内存的要求而改变。

> 采用动态分区法，在系统初启时，除了操作系统中常驻内存部分之外，只有一个空闲分区。随后，分配程序将该区依次划分给调度选中的作业或进程。


随着进程执行，会出现一系列分配和释放。

![](https://img2018.cnblogs.com/blog/1734701/201911/1734701-20191121093345326-579125164.png)

*如何进一步划分不合适的内存空闲区大小？*
如果分配的空闲区比所要求的大，则管理程序将该空闲区分成两个部分，其中一部分成为已分配区，而另一部分成为一个新的小空闲区。
- 最先适应算法
- 最佳适应算法
- 最坏适应算法
- 临近适应算法
下一节详细说明。

**内存数据管理结构**
使用分区说明表、可用表或分区自由链。以描述系统的内存资源情况。
与此对应，请求内存资源的作业也构成一个内存资源请求表。
- 可用表
> 可用表的每个表目记录一个空闲区，主要参数包括区号、分区长度和起始地址。采用表格结构，管理过程比较简单，但表的大小难以确定，要占用一部分内存。

- 自由链
> 利用每个内存空闲区的头几个单元存放本空闲区的大小及下个空闲区的起始地址，从而把所有的空闲区链接起来。然后，系统再设置一个自由链首指针让其指向第一个空闲区，这样，管理程序可通过链首指针查到所有的空闲区。

其优缺点的来源全部来自链表这种数据结构本身。即：易存储，易顺序遍历，难随机查找。
**优点**：链式管理，且无需额外内存。
**缺点**：查找困难。

以上无论可用表还是自由链方式都需按一定规则排列，便于分区分配与回收。
## 分区的分配与回收
### 固定分区
**分配**
用户通过请求表提出需求。存储管理程序查询分区说明表，将满足要求的空闲分区分配。

**回收**
进程执行完毕，将分区状态置为未使用。

### 动态分区
动态分区分配与回收主要解决3个问题
> 1. 对于请求表中的要求内存长度，从可用表或自由链中寻找出合适的空闲区分配程序。
> 2. 分配空闲区之后，更新可用表或自由链。
> 3. 进程或作业释放内存资源时，和相邻的空闲区进行链接合并，更新可用表或自由链。

说人话：
1. 怎么找空闲
2. 空闲区大了，小了怎么办
3. 合并碎片

***从可用表或自由链中寻找空闲区的方法：***
**最先适应 first fit**——*快 无需排序*
可用表或自由链起始地址按递增次序排列。
一旦找到第一个≥需求长度的分区，则退出。

找到后划出要求长度，将余下部分合并（如果有相邻空闲存在）留在可用表中。


**最佳适应 best fit**——*省 低地址充分利用*
可用表或自由链按从小到大次序排列。
存储管理程序从表头起查找，一旦找到第一个≥需求长度的分区，则退出。

找到后划出要求长度，将余下部分合并（如果有相邻空闲存在）留在可用表中。
- 保证了高地址有较大空间放置对内存要求多的进程或作业。找到最适应，但不一定会增加内存利用率。

**最坏适应 worst fit**——*志在消灭空闲碎片*
可用表或自由链按大小递减次序排列。
一旦找到第一个≥需求长度的分区，则退出。

找到后划出要求长度，将余下部分合并（如果有相邻空闲存在）留在可用表中。
- 期望分配后的剩余空间仍能进行再分配。

**Important discussiones**
1. 分区管理无法实现虚存。每个用户进程所需内存容量受分区大小限制。
2. 分区管理使用覆盖和交换技术扩充内存。
3. 动态分区使用动态地址重定位技术。*obviously*
4. 分区管理使用保护键法。

## 分区管理优缺点
**优点**
1. 实现了多作业或进程对内存的共享，有助于多道程序设计，提高OS资源利用率。
2. 实现容易

**缺点**
1. 内存利用率低。碎片多。
2. 作业或进程受分区大小限制。说白了没实现虚存。
3. 无法实现分区间信息共享。

# 覆盖与交换
覆盖与交换技术在多道环境下用来扩充内存的两种方法。
## 覆盖
> 覆盖技术是基于这样一种思想提出来的：一个程序并不需要一开始就把它的全部指令和数据都装人内存后再执行。在单CPU系统中，每一时刻事实上只能执行一条指令。
> 因此，不妨把程序划分为若干个功能上相对独立的程序段，按照程序的逻辑结构让那些不会同时执行的程序段共享同一块内存区。通常，这些程序段都被保存在外存中，当有关程序段的先头程序段执行结束后，再把后续程序段调入内存覆盖前面的程序段。这使得用户看来， 好像内存扩大了，从而达到了内存扩充的目的。

**说人话即：无需同时驻留内存的两段程序 可以共享同一段内存区。**

覆盖技术要求程序员提供清晰的覆盖结构，必须将程序提前划分成程序段。

## 交换swap
同时存在于内存中的进程，有些处于执行或就绪状态，有些处于等待状态。
swap将处于等待状态的进程换出内存，以提高内存空间利用率。

swap在进程或作业间进行，而覆盖主要在进程或作业内部进行。

# 页式管理
## 页式管理基本原理
> 页式管理正是为了减少碎片以及为了只在内存存放那些反复执行或即将执行的程序段与数据部分，而把那些不经常执行的程序段和数据存放于外存，待执行时调入，以提高内存利用率而提出来的。

- **各进程被划分为若干个长度相等的页（page）。**
经过页划分后，进程的虚地址变为页号P与页内地址W组成。

| 页号P | 页内地址 |
| ----- | -------- |

- **内存空间按页的大小划分为片或页面（page frame）。**
这些页面为系统中任一进程所共享。

用户进程在页面间不再连续。实现了从连续到非连续管理的飞跃。为虚存的真正实现打下了基础。

*如何由页式虚拟地址 变换为 内存页面物理地址？*
- **页式虚地址与页面物理地址建立一一对应的页表，并用地址变换机构解决离散地址变换。**
页表是[[5 存储管理#地址变换|动态重定位技术]]的一种延伸。

- **采用请求调页或预调页技术实现内外存统一管理。即实现了虚存**
基于工作区的局部性原理建立。

- **页面的分配与回收与页面淘汰和缺页处理技术结合。**


==**页式管理的重点在于页划分后的地址变换，以及页面调入调出技术**。==

## 静态页面管理
在作业或进程开始执行之前，把该作业或进程的程序段和数据**全部**装入内存的各个页面中，并通过页表和硬件地址变换机构实现虚拟地址到内存物理地址的映射。
### 页面分配与回收
第一步：为要求内存的作业或进程分配足够的页面。
**页表**
页号+页面号组成
***每个进程至少拥有一个页表***

**请求表**
类似分区说明表。用来确定作业或进程的虚拟空间各页在内存中的实际对应位置。
***整个系统需要一张请求表***

**存储页面表**
指出内存各页面是否已被分配。
***整个系统一张***
### 分配算法
请求表====>存储页面表检查空间是否充足====>查找空闲页面，分配页表

执行完毕====>拆除页表====>使用完的页表插入空闲页面表
### 页面地址变换 
#难点
*怎样由页号和页内相对地址变换到内存物理地址？*
- 连续的页号对应着不连续的页面号
- 变换过程中包含变换指令的地址+数据地址
- 类似动态重定位，内存真实地址 = 页面地址+页内相对地址

综合两张表：**页**    **页表**
进行两块寻址：**程序（指令）段**  **数据集**

**全部由地址转换机构自动完成**
页表驻留在内存中。取一次指令或数据至少需要访址两次以上。

**优化寻址速度：**
将存于内存中的页表转换为存储在*高速联想寄存器中的快表*。提升查找速度。

> 静态页式管理解决了分区管理时的碎片问题。但是，由于静态页式管理要求进程或作业在执行前全部装人内存，如果可用页面数小于用户要求时，该作业或进程只好等待。而且，作业或进程的大小仍受内存可用页面数的限制。这些问题将在动态（请求）页式管理中解决。
> **即：碎片问题仍存在。仍未实现虚存。**

## 动态页式管理
在静态的基础上发展而来。

> 请求页式管理和预调入页式管理在作业或进程开始执行之前，都不把作业或进程的程序段和数据段一次性地全部装入内存，而只装入被认为是经常反复执行和调用的工作区部分。其他部分则在执行过程中动态装人。
> 请求页式管理与预调入页式管理的主要区别在它们的调入方式上。请求页式管理的调入方式是，当需要执行某条指令而又发现它不在内存时，或当执行某条指令需要访问其他的数据或指令，而这些指令和数据不在内存中时，即发生**缺页中断**，系统将外存中相应的页面调入内存。
> 预调入页式管理的调人方式是，系统对那些在外存中的页进行调入顺序计算，估计出这些页中指令和数据的执行和被访问的顺序，并按此顺序将它们顺次调入和调出内存。除了在调人方式上请求页式管理和预调入页式管理有些区别之外，在其他方面这两种方式基本相同。

### 请求&预调入页式管理
两个基本问题：
*怎样发现不在内存中的虚页？*
方法：扩充页表。即与每个虚页号相对应。增设判断是否在内存中的中断位及外存中始地址。

*怎样处理虚页不在内存中的情况？*
即：内存中的页面淘汰算法。
方法：扩充页表。增设记录该页是否发生改变的改变位。

*缺页的调入和存放*
即：内存页面置换算法。
容易出现抖动问题。
即调回内存的页面不久后又被调出，如此反复。页面调度过于频繁，以至于大量时间用于调页面。

**[[5 存储管理#页面地址变换|地址变换]]**
过程与静态相同。
当硬件变换机构发现缺页，产生缺页中断信号，由中断处理程序进行相应处理。
中断处理程序由软件实现。除了选择淘汰页面还需要从外存读入虚页，涉及外存及文件系统。
> 内存利用率的提高是以牺牲系统开销代价换来的。

==**页面置换算法==**
1. 随机淘汰
completely random

2. Round Robin 
循环换出内存可用区内可被换出的页。和其他因素均无关。

3. FIFO
严格先进先出。最先调入的页被调出。

**Belady现象**
在未给进程或作业分配足够的页面数时，会出现分配的页面数增多，缺页次数反而增加的奇怪现象。

> 由实验和测试发现FIFO算法和轮转法的内存利用率不高。这是因为，这两种算法都是基于CPU按线性顺序访问地址空间的这个假设。事实上，许多时候，CPU不是按线性顺序访问地址空间的，例如在执行循环语句时。因此，那些在内存中停留时间最长的页往往也是经常被访问的页。尽管这些页变“老”了。但它们被访问的概率仍然很高。

4. 最近最久未使用 LRU
当需要淘汰某一页时，选择离当前时间最近的一段时间内最久未被使用过的页淘汰。

由于完全使用需要巨大的系统开销：LRU——时间+使用双限制，实际中经常使用其近似算法：
- 最不经常使用 LFU——时间最近
- 最近没有使用 NUR——使用最少

5. 理想型淘汰算法 OPT
无法实现。因为其需要预知未来进程访问序列。

## 页式管理优缺点
**优点**
- 有效解决碎片问题：因为无需连续存放
- 提供内外存统一管理的虚存实现。提高内存利用率且有利于多道程序运行。
**缺点**
- 需要相应的硬件支持
- 增加系统开销
- 可能产生抖动问题
- 仍有一部分（最后一页）的内存空间未被利用。

# 段式管理
> 分区式管理和页式管理时的进程地址空间结构都是线性的，这要求对源程序进行编译、链接时，把源程序中的主程序、子程序和数据区等按线性空间的一维地址顺序排列起来。这使得不同作业或进程之间共享公用子程序和数据变得非常困难。
> ——无法实现共享

> 分区式管理和页式管理时的进程地址空间结构都是线性的，这要求对源程序进行编译、链接时，把源程序中的主程序、子程序和数据区等按线性空间的一维地址顺序排列起来。这使得不同作业或进程之间共享公用子程序和数据变得非常困难。
> ——无法使用动态链接

==段式存储管理是基于为用户提供一个方便灵活的程序设计环境而提出的。==

**基本思想**
把程序按内容或过程（函数）分段，独立命名。一个作业或进程包含的段对应于一个二维线性虚拟空间，即二维虚拟存储器。内存管理程序以段为单位分配内存，通过地址变换机构映射到实际物理地址。

## 实现原理
**段式虚拟空间**
二维结构

| 段号s | 段内相对地址w |
| ----- | ------------- |

> 一维空间：页式管理。页号按递增排列。线性。

段式管理中段号与段号之间无顺序关系。段也不具有相同的页长，长度不固定。
每个段定义一组逻辑上完整的程序或数据。

> 每个段是一个首地址为零的、连续的一维线性空间。根据需要，段长可动态增长。对段式虚地址空间的访问包括两个部分：段名和段内地址。

类似于二维数组。其中一个维度中含的都是一维数组。合并起来成为了二维结构。

### 段式管理内存分配与释放
**分配**
以段为单位，每段分配一个连续内存区。
同一进程所含各段之间不要求连续。

随着进程的执行，进程根据需要随时申请调入新段和释放老段。

**段式管理内存分配与释放在执行过程中动态进行。**
*内存中有足够的空闲区时*
OS用相应表格或数据结构管理内存空闲区。采用和[[5 存储管理#动态分区法|动态分区管理]]相同的空闲区管理方法。(最先，最佳最坏 .etc.)

*内存中无足够内存区满足段的内存要求时*
段式管理程序根据给定内存置换算法淘汰一段时间内CPU不访问的段，即淘汰访问概率最低的段。
采用[[5 存储管理#动态页式管理|动态页式管理]]相同的那些置换算法均可。

**任何一个段长不允许超过内存可用区长度**

> 除了初始分配之外，段的动态分配是在CPU所要访问的指令和数据不在内存时产生缺段中断的情况下发生的。因此，段的淘汰或置换算法实际上是缺段中断处理过程的一部分。

### 段式管理地址变换
两个问题：
*段式管理程序如何感知到访问的段不在内存中？*
*二维空间虚拟地址如何变换为一维线性物理地址？*
均由段式地址变换机构解决。

**段表**
与页表类似。为一个进程或作业建立段表。

**动态地址变换**
段表始址===>访问段表====>根据段号s====>辅助段内相对地址w====>实际内存地址

同样段式管理的地址变换也需要两次以上的内存访问。为提高访问速度，也可以将段表存入高速联想寄存器。

### 共享与保护
**段的共享**
在内存中只保留一个程序的副本供多个用户使用。

> 另外，在多道环境下，由于进程的并发执行，一段程序为多个进程共享时，有可能出现多次同时重复执行该段程序的情况（即某个进程在未执行完该段程序之前，其他并发进程又已开始执行该段程序)。这就要求在执行过程中，该段程序的指令和数据不能被修改。还有， 与一个进程中的其他程序段一样，共享段有时也要被换出内存。这时，就要在段表中设立相应的共享位来判别该段是否正被某个进程调用。显然一个正在被某个进程使用或即将被某个进程使用的共享段是不应该调出内存的。

**保护**
- 地址越界保护法
- 存取方式保护法


## 段式管理优缺点
**优点**
- 提供了内外存统一管理的虚存实现
- 段长可动态增长
- 便于信息段共享
- 便于实现动态链接。

**缺点**
- 碎片问题比页式更严重。
- 每个段长度受内存可用区大小限制。
- 会产生抖动现象。

# 段页式管理
> 以上几种存储管理方式各有特长。段式管理为用户提供了一个二维的虚地址空间，反映了程序的逻辑结构，有利于段的动态增长、共享和内存保护等，这大大地方便了用户。而分页系统则有效地克服了碎片，提高了存储器的利用率。从存储管理的目的来讲，主要是方便用户的程序设计和提高内存的利用率。那么，把段式管理和页式管理结合起来让其互相取长补短不是更好吗？于是，段页式管理方式便被提了出来。

## 实现原理
### 虚地址构成
对于段s中的程序和数据，按照一定大小将其划分为不同的页。

| 段号s | 页号p | 页内相对地址d |
| ----- | ----- | ------------- |

**p和d一起构成了段式管理中的段内相对地址w**

由于虚拟空间的最小单位是页而不是段，从而内存可用区也就被划分成为若干个大小相等的页面，且每段所拥有的程序和数据在内存中可以分开存放。分段的大小也不再受内存可用区的限制。

**段表和页表**

### 动态地址变换过程
OS为每个进程建立一张段表。每一个段又被划分为若干页，每个段则必须建立一张页表，以进行地址变换。

段表===>页表===>真实内存地址

至少需要访问3次以上内存。也可以使用高速联想寄存器提高运行速度。

**有关段页式管理中的存储保护和共享以及缺段或缺页中断处理等，可参照段式管理或页式管理中的方法解决。**


## 段页式管理优缺点
**优点**
- 兼具段、页二者优点

**缺点**
- only运行速度慢。


# 局部性原理和抖动问题
针对于需要进行内外存交换信息的存储管理方法：
动态页式管理，段式管理，段页式管理

解决反复调入调出的问题，提高运行速度和运行效率。

**局部性原理**
> 由模拟实验知道，在几乎所有的程序的执行中，在一段时间内，CPU总是集中地访问程序中的某一个部分而不是随机地对程序所有部分具有平均访问概率。

如果不能正确地将那些系统需要的局部段放入内存，则系统效率必然大大降低，甚至无法正常工作。

**工作集**
任何程序在局部性放入时，都有临界值要求。内存分配小于此值，内外存交换会显著增加；大于此值，再增大内存分配也不能显著减少交换次数。

> 在物理系统中，为了防止抖动的产生，在进行淘汰或置换时，一般总是把缺页进程锁住， 不让其换出，而调入的页或段总是占据那些暂时得不到执行的进程所占有的内存区域，从而扩大缺页进程的工作集。UNIX System V中就是采用的这种方法。

# 小结
![](https://img-blog.csdnimg.cn/201907151214090.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5dGhvbl9qZWZm,size_16,color_FFFFFF,t_70)