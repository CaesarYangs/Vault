# 二叉树部分
 
 

## 框架思维
> 从最简单的问题中提炼出所有二叉树题目的共性，并将这些思维反手用到 [动态规划](https://labuladong.github.io/algo/3/23/69/)， [回溯算法](https://labuladong.github.io/algo/4/29/108/)， [分治算法](https://labuladong.github.io/algo/4/31/128/)， [图论算法](https://labuladong.github.io/algo/2/19/35/) 中去，这也是我一直强调框架思维的原因。

前序遍历，中序遍历，后序遍历

> 举个例子，比如说我们的经典算法「快速排序」和「归并排序」，对于这两个算法，你有什么理解？**如果你告诉我，快速排序就是个二叉树的前序遍历，归并排序就是个二叉树的后序遍历，那么我就知道你是个算法高手了**。
> [二叉树的重要性](https://labuladong.gitee.io/algo/2/18/22/)



## 前中后序遍历
二叉树遍历框架：
```
void traverse(TreeNode root) {
    if (root == null) {
        return;
    }
    // 前序位置
    traverse(root.left);
    // 中序位置
    traverse(root.right);
    // 后序位置
}

```

即：递归之前，递归之后。
代码书写位置的不同，执行的时机不同，导致最后的结果不同。

所谓前序位置，就是刚进入一个节点（元素）的时候，后序位置就是即将离开一个节点（元素）的时候。

==**前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点**==，绝不仅仅是三个顺序不同的 List：

前序位置的代码在刚刚进入一个二叉树节点的时候执行；

后序位置的代码在将要离开一个二叉树节点的时候执行；

中序位置的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。

**每个节点都有「唯一」属于自己的前中后序位置**

_这里你也可以理解为什么多叉树没有中序位置，因为二叉树的每个节点只会进行唯一一次左子树切换右子树，而多叉树节点可能有很多子节点，会多次切换子树去遍历，所以多叉树节点没有「唯一」的中序遍历位置。_

==**二叉树的所有问题，就是让你在前中后序位置注入巧妙的代码逻辑，去达到自己的目的**。==

我只需思考每个节点应该做什么，其他的细节无需关注，也最好不要关注。因为一旦关注后就会陷入对递归实现细节的多层思考，反而适得其反，不能追本溯源。

抛给二叉树遍历框架，递归会对所有节点做相同的操作。

**写树相关的算法，简单说就是，先搞清楚当前 `root` 节点「该做什么」以及「什么时候做」，然后根据函数定义递归调用子节点**，递归调用会让孩子节点做相同的事情。
所谓「该做什么」就是让你想清楚写什么代码能够实现题目想要的效果，所谓「什么时候做」，就是让你思考这段代码到底应该写在前序、中序还是后序遍历的代码位置上。



### 后序
和前序位置对比，发现前序位置的代码执行是自顶向下的，而后序位置的代码执行是自底向上的

另一种思想是：后序遍历是指先让两个子树完成其操作，满足一定的性质或条件后，才可以开始后续的操作。这样理解后续遍历也是不错的想法。

**但这里面大有玄妙，意味着前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据**。

**只有后序位置才能通过返回值获取子树的信息**

**那么换句话说，一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了**。

### 层序遍历
[BFS 算法框架](https://labuladong.github.io/algo/4/29/113/) 就是从二叉树的层序遍历扩展出来的，常用于求无权图的**最短路径**问题
```// 输入一棵二叉树的根节点，层序遍历这棵二叉树
void levelTraverse(TreeNode root) {
    if (root == null) return;
    Queue<TreeNode> q = new LinkedList<>();
    q.offer(root);

    // 从上到下遍历二叉树的每一层
    while (!q.isEmpty()) {
        int sz = q.size();
        // 从左到右遍历每一层的每个节点
        for (int i = 0; i < sz; i++) {
            TreeNode cur = q.poll();
            // 将下一层节点放入队列
            if (cur.left != null) {
                q.offer(cur.left);
            }
            if (cur.right != null) {
                q.offer(cur.right);
            }
        }
    }
}
```


## 两种主要解题思路
**二叉树题目的递归解法可以分两类思路，第一类是遍历一遍二叉树得出答案，第二类是通过分解问题计算出答案，这两类思路分别对应着 [回溯算法核心框架](https://labuladong.github.io/algo/4/29/108/) 和 [动态规划核心框架](https://labuladong.github.io/algo/3/23/69/)**。

遇到一道二叉树的题目时的通用思考过程是：
**是否可以通过遍历一遍二叉树得到答案？如果不能的话，是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案**？


---
## 二叉树的构造（序列化与反序列化）
序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。

**所谓的序列化不过就是把结构化的数据「打平」，其实就是在考察二叉树的遍历方式**。

反序列化的过程只能使用前序和后序遍历实现。因为中序无法找到准确的根节点位置。