
# Algorithm Sec1

**写递归算法的关键是要明确函数的「定义」是什么，然后相信这个定义，利用这个定义推导最终结果，绝不要试图跳入递归**。

**二叉树题目的一个难点就是，如何把题目的要求细化成,转化成每个节点需要做的事情**。

递归算法的关键要明确函数的定义，相信这个定义，而不要跳进递归细节。

写二叉树的算法题，都是基于递归框架的，我们先要搞清楚`root`节点它自己要做什么，然后根据题目要求选择使用前序，中序，后续的递归框架

整个前序 中序 后序遍历的内在逻辑关系
如计算二叉树节点个数
```
int count(TreeNode root) {    
	if (root == null) {        
	return 0;    
	}    // 先算出左右子树有多少节点    

	int left = count(root.left);    
	int right = count(root.right);   
	/* 后序遍历代码位置 */    
	// 加上自己，就是整棵二叉树的节点数    
	int res = left + right + 1;    
	return res;
}
```

**二叉树培养的框架思维**

序列化与反序列化：——二叉树序列化
> JSON 的运用非常广泛，比如我们经常将变成语言中的结构体序列化成 JSON 字符串，存入缓存或者通过网络发送给远端服务，消费者接受 JSON 字符串然后进行反序列化，就可以得到原始数据了。这就是「序列化」和「反序列化」的目的，以某种固定格式组织字符串，使得数据可以独立于编程语言。

**所谓的序列化不过就是把结构化的数据「打平」，其实就是在考察二叉树的遍历方式**。

[二叉树序列与反序列化实例-综合讲解-练习](https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247485871&idx=1&sn=bcb24ea8927995b585629a8b9caeed01&chksm=9bd7f7a7aca07eb1b4c330382a4e0b916ef5a82ca48db28908ab16563e28a376b5ca6805bec2&scene=21#wechat_redirect)

