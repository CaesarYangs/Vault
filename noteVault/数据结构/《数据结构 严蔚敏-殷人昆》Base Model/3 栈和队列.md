非常重要的线性结构。
栈和队列也是线性表的一种；其特殊在于栈和队列的基本操作是线性表操作的子集。是操作受限的线性表。

# 栈
**栈顶 top**
**栈底 bottom**

LIFO

## 栈的表示和实现
### 顺序栈
先为栈分配一个基本容量，在使用过程中，当空间不够大时再逐段扩大。

**实现细节：**
1第一种实现方式（top指向栈顶空位置）
栈不存在：base == NULL
栈空标志：top == base
非空栈的top指针始终在栈顶元素的下一个位置上

- Push时使用top++
- Pop时使用--top
- 栈满时top=顺序表size
- （C）空间不足时要先分配内存空间

2另一种实现方式（top指向栈顶第一个元素）
- push时使用++top
- pop时使用top--
- 使用数组来定义栈：只需使用top一个标志位。top=-1空栈；top=size-1栈满。

读取栈顶元素的函数`getTop()`与退栈函数`Pop()`的区别是前者未改变栈顶指针的值。

**引申**
- 避免栈的溢出
- 双栈——两个栈同时使用的情况
当需要两个栈时，定义一个足够大的栈空间。空间的两端分别设为栈底，由两侧同时向中间作为分别的栈顶方向。直到两个栈顶指针相遇，则栈满溢出。
两个栈大小互相可变，动态调整，灵活性强。

在n>2个栈的情况下，多个栈共享空间的顺序表示将会非常复杂，且效率较低。解决方法是采用链式栈作为存储表示。

### 链式栈
便于节点的插入删除。在程序中同时使用多个栈的情况下，使用链接不仅能提高效率，还能够实现共享存储空间的目的。

**链式栈的栈顶出现在表头。**
新节点的插入和出栈删除操作均在链表表头，即栈顶进行。


## 应用
### 数制转换
10进制转8进制
计算和输入的顺序和最后要输出的数正好相反，所以利用栈的特殊结构实现。

### 括号匹配

1. 从左到右扫描字符串
2. 遇到的左括号入栈
3. 遇到又括号，将其与栈顶括号匹配，同时删除左括号（即pop操作）

左括号push
右括号和栈顶符号对比，检验是否匹配，并pop

### 表达式计算
前缀，中缀，后缀

**编译程序一般使用后缀表示来求解表达式的值，解决了运算符优先级问题，同时只需一个栈即可实现。**
进行运算的操作数总在操作符前面。

- 操作数压栈
- 若为操作符op，则令前两个数出栈，并计算1op2，重新压栈
- 处理完成后，栈顶存放的就是表达式的值。

### 中缀转后缀
- 从左至右扫描运算式
- 数字一律不压栈，自动输出
- 操作符压栈；若优先级>栈顶op优先级则压栈；若优先级<=栈顶op优先级，则退栈并输出（相等时退栈不输出）
- 读入结束，将栈元素全部弹出，清空。


### 行编辑程序
退行符"#"
退行符"@"

将输入字符送入缓冲区（栈），检查栈顶字符，对栈进行相应操作（pop或clear）


# 栈与递归
recurve
**基本定义**
利用前面运算来求得答案的过程就叫递归过程。

**递归的重要结构**
- 递归结束条件
分解后的子问题可以独立求解时，就停止分解。
- 递归情况

一旦到达递归结束条件，调用函数的递归链中断，同时在返回的途中计算其他值。最终返回计算结果。

**递归背后的思想**
- **分治法**：分解问题的思想。将大问题分解为小问题的集合
- 递归过程直接反映定义的结构

## 递归使用
### 定义是递归的
**使用递归的定义**
阶乘，幂函数，斐波那契数列

### 数据结构是递归的
- 可将一个头指针为first的单链表定义为一个递归数据结构：
递归结束条件：first为NULL，自身是一个单链表（空表）
递归情况：first≠NULL，其指针域指向一个单链表，仍是一个单链表。


```Cpp
//找到链表的尾节点
LinkNode *FindRear(LinkNode *f){
	if(f==NULL){
		return NULL;
	}else if(f->next == NULL){
		return f;
	}else{
		FindRear(f->next);
	}
}
```


- 树形结构也是递归的。以多重链表形式存储。

### 问题的解法是递归的
有些问题只能用递归来解决。

**汉诺塔**
移动n个盘子可以分解为移动n-1个盘子；可以分解为移动n-2个；最后总可以分解为移动1个盘子。

**递推问题**
递归和递推是两个不同的概念。

递推是利用问题本身的递推关系对问题求解的办法。采用递推关系建立的算法有重要的递推性质。
**递推问题可以用递归方法求解，也可以用迭代（重复）方法求解。**

## 递归过程与工作栈
**外部调用**结束后，将返回调用递归过程的主程序。
**内部调用**结束后，将返回到递归过程内部本次调用语句的后继语句处。

### 递归工作栈
*解决调用递归时每一层级的参数传递和地址返回问题。*
递归工作栈-活动记录（递归工作记录）：

| 记录表                           |
| -------------------------------- |
| 返回位置（递归调用的下一条指令） |
| 局部变量                         |
| 参数的副本空间                   |

**在每进入一层递归时，系统就要建立一个新的活动记录，把上述项目登入，加到递归工作栈的栈顶。每退出一层递归，就从递归工作栈退出一个工作记录。**

- 第一步是沿着递归路径一路向下，直到递归终止。将其压栈
- 逐层向上返回，同时计算并压栈。

活动记录：

| 参数 long n | 返回位置<下一条指令> | 返回值 long temp | 
| ----------- | -------------------- | ---------------- |


> 主程序外部调用的活动记录在栈的底部，随内部调用一层层地进栈。递归结束条件出现于函数 Fact(0)的内部,从此开始一连串的返回语句。退出栈顶的活动记录,控制按返回地址转移到上一层调用递归过程处。

### 用栈实现递归过程非递归算法
**利用栈将递归过程改造为非递归过程**

#myAlgoInspect 
**本质上就是对一棵递归树的深度优先搜索**

![](https://img-blog.csdnimg.cn/20190119175303152.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2V2ZXJ5X19kYXk=,size_16,color_FFFFFF,t_70)

包含大小两循环。

```cpp
do{
	while(blabla){

	}
}while(stack.IsEmpty() == false)

```
实际上递归调用树所表示的就是在递归过程中实际的各种计算过程或节点。就是一个可视化递归计算过程。

本书所给的此类递归树栈式非递归解法，时间复杂度很高，效率差。参见《Java语言描述》block: [[2 算法分析#^ce2051]] 或下文详见思考🤔。


### 用迭代法实现递归过程
上文所述递归调用树解法，时间复杂度达到*O(2^n)*。

利用递归方法可以大幅减少递归调用所消耗的时间复杂。
**一般对于尾递归或单向递归，都可利用迭代的方法，将递归改为非递归过程。**

- 单项递归：即解决类似斐波那契数列问题
- 尾递归：类树的后续遍历。

# 队列
操作系统中的[[4 处理机调度#调度算法]]便是队列的一个直接应用。

**概念**
队列queue是另一种限定存取位置的线性表。只许在表的一端插入，另一端删除。

插入的一端为**队尾rear**，删除的一端为**队首front**。此特性便是FIFO先进先出。

## 队列的表示和实现
### 循环队列
即，基于数组的队列表示方式。也叫顺序队列。
利用rear和front指针来进行相应的队列元素管理。

- 声明时初始化队列：front = rear = 0
- 新元素入队，rear++ 此时的rear始终指向下一元素应当插入的位置。
- front指向真正的队首位置

此种表示会产生**假溢出**

为了解决此问题，将输入首尾相接，形成环形队列存储。
- front = (front + 1)% maxSize
- rear = (rear + 1)% maxSize

- rear == front代表队空标志
- rear指向front的前一位置表示队列已满——会遗留一个空位置，用于区别队空与队满标记
- 最多只能存放maxSize-1个元素

### 链式队列
- front指针：始终指向单链表头结点
- rear指针：始终指向单链表尾节点

即：**双指针方法表示**

**用链式队列特别适合数据元素变动大的情形，且不存在队列满而溢出的情况。**

## 优先级队列
**每次从队列中取出优先级最高的元素**

为了提高优先级队列运算速度，后续会利用**堆作为优先级队列的存储结构，时间减少至*O(log2N)* 数量级**

## 双端队列
Deque，Double Ended Queue
可以在队列的两端插入和删除。





