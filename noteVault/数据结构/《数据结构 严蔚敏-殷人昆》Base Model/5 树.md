
线性结构不适合于描述有分支结构的数据。
**而树形结构是以分支关系定义的层次结构。** 是一类重要的非线性数据结构。

# 树基本概念
**自由树**
一个定义的二元组。包含顶点集合与边集合。最终形成一幅连通图。
free tree是图论的重要研究内容。此章节不深入讨论。

主要研究有根有序树，其顶点统称为结点node

**有根树T**
n个结点的有限集合。**一种递归/归纳的定义。**

根root 是一个特殊结点。每个子集合也是一棵树，叫做根的子树subtree

每课子树有且仅有一个直接前驱(即其上层结点)，可以有0或多个直接后继(下层结点)。

**结点 node**
包含数据项以及指向其他结点的分支

**结点的度 degree**
结点拥有的子树棵数。

**树的度 degree**
树种结点度的最大值。

**森林**
m棵树的集合。
森林可以和树之间简单转化：删除一棵非空树的根节点，就变成森林。

# 二叉树
Binary Tree是树形结构的一种重要类型。

特点是每个节点最多有两个子女(child)。
<u>即 二叉树中不存在度大于2的节点，且二叉树有左右子树之分，其次序不能颠倒。</u>

**二叉树的计算性质**
1. a
2. a
3. a
4. a
5. a

## 二叉树存储表示
主要有两种表示：数组方式与链表方式。

### 数组方式
适用于二叉树形态不发生剧烈动态变化的场合。——especially 完全二叉树
可随机存取二叉树节点。

**完全二叉树存储**
自上而下，根据BFS的顺序作为数组存储的位置数据。可根据编号的公式找到兄弟，父亲甚至子女节点信息。

**一般二叉树存储**
基于上述的存储方式。将普通二叉树当做完全二叉树处理，需要空出不存在节点的位置。
极大地浪费了地址空间。

### 链表方式
**即：二叉链表**/三叉链表

 | leftChild | data | rightChild | 
 | --------- | ---- | ---------- |

缺点：无法找到父节点。

**mark：广义表建立二叉树**
类似于二叉树的前序遍历过程，区分括号和逗号即可。

## 二叉树遍历
*什么是遍历？*
遵守某种次序，访问二叉树中的所有节点，使得每个节点被访问一次且只有一次。



### 递归算法
L-访问左子树 R-访问右子树 V-访问该节点

**前序遍历** VLR

**中序遍历** LVR

**后序遍历** LRV


### 非递归算法
如果暂时不访问当前节点的数据，即放弃V操作，三种递归遍历的架构是完全一致的。也即三种算法他们走过的路径是一样的。

**三序遍历的非递归**
**改为非递归，则需要设立工作栈，记录回退路径**——即手工实现[[3 栈和队列#递归工作栈]]的概念。

**层序遍历**
即BFS

### 二叉树的计数
*具有n个结点的不同二叉树有多少种？*

*给了一棵二叉树的前序和中序序列，是否能唯一地确定一棵二叉树？*
可以。


## 线索二叉树
二叉树虽然是非线性结构，但二叉树的遍历却为二叉树的节点集导出了一个线性序列。因而，二叉树的节点存在关于这个线性序列的前驱和后继。

### 线索
即从某个节点出发，能够找到其在某种次序（前序，中序，后续）下的前驱和后继。

目的是找到前驱和后继而不用每次都对二叉树进行整体遍历。即需要把每个节点的前驱和后继信息记录下来。

节省空间：
利用空的leftChild存放前驱节点 rightChild存放后继指针

**线索**
指示前驱与后继的指针叫做线索。
对应的二叉链表即**线索二叉链表**。
无需遍历二叉树就可得到任一节点的前驱和后继节点的地址。

| leftChild | ltag | data | rtag | rightChild | 
| --------- | ---- | ---- | ---- | ---------- |


**指示指针 ltag与rtag**
tag = 0表示child域中存放的是指向左右孩子的指针。*即正常树节点*
tag != 0表示child域中存放的是前驱或后继节点的指针。

**利用线索二叉树**
利用`First()`找到遍历序列的第一个节点后，使用`Next()`寻找其后继节点。从而可以连成一个包含相对应遍历顺序(前，中，后)的长链表。以遍历的第一个元素为首，到最后一个为止。

*利用中序线索二叉树的信息，不仅可以实现中序遍历，还可以实现前序和后序遍历。*

# 树与森林
## 树的存储表示
**广义表表示法**

**父指针表示法**
以一组连续的存储单元来存放树中节点。每个节点两个域。

| data | parent |
| ---- | ------ |

**孩子链表表示法**
由于一般的树具有的左右孩子个数不相同。如果向二叉链表一样，，每个节点设置的左右指针个数也会完全不同，难以确定。

为树中每个节点设置一个子女链表（孩子链表），将这些节点对应的孩子链表的头指针放在一个向量中。类似于[[邻接表]]表示法. ^a55c35

适合于频繁寻找孩子节点的情况。

![](https://img-blog.csdnimg.cn/2020020513261515.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dteTAyMTdf,size_16,color_FFFFFF,t_70)

**孩子-兄弟链表表示法**
每个节点的度是2，是最节省空间的树的存储表示。

| data | firstChild | nextSibling | 
| ---- | ---------- | ----------- |

![](https://upload-images.jianshu.io/upload_images/5600819-df94e075d6577fca.png?imageMogr2/auto-orient/strip|imageView2/2/w/790/format/webp)

<u>即：孩子链表表示法的一种树形结构表示，而非使用邻接表形式表示。</u>
<u>与上述</u>[[#^a55c35|孩子链表表示法]]<u>是一种同构异性体的关系。</u>

### 森林与二叉树的转换
==森林与二叉树有一一对应关系。==

**每棵二叉树表示的根节点都没有右兄弟**

**森林转化为二叉树的规则**
1. 每棵树的根节点与其第一个孩子通过firstChild连接
2. 每棵树根的第一个孩子与同层兄弟通过nextSibling连接
3. 去掉每棵树根节点除第一个孩子外其余孩子的连接
4. 把每棵树的根节点通过nextSibling连接
<u>本质：通过转化为孩子-兄弟链表进而容易变为二叉树的做法</u>

其是一种递归的算法。每棵树转化为对应二叉树表示后，对每棵树根节点的子树森林进行同样的操作，最后都变换为二叉树为止。

**二叉树转换为森林的规则**


## 树和森林的遍历
### 树的DFS
又可以分为先根次序 后根次序

**树的遍历不宜进行所谓中序遍历，因为树的叉链表个数不明确，不能准确地判断根节点位置。**

### 树的BFS

# 堆
即二叉堆。
堆heap 是优先级队列中最高效地一种数据结构。
## 堆的结构性质
堆是一棵完全二叉树。

## 最小堆和最大堆
**关键码key**
一个能够标识数据记录或元素的数据项。

### 最小堆 mini-Heap
任意节点的关键码均小于或等于其左右孩子的关键码

**堆序 heap-ordered**
堆中所有的记录都具有的关系。

**最大堆 max-Heap**
任意节点的关键码均大于或等于其左右孩子的关键码。

## 堆的建立


# Huffman 树
最优二叉树。是一类加权路径长度最短的二叉树。

**路径长度**
指路径上的分支系数。树的路径长度是从树的根节点到每一个节点的路径长度之和。

本质思想：**从树的根节点到达树中每一节点有且仅有一条路径。**

**Huffman**
即：带权路径长度（Weighted Path Length，WPL）
**带权路径长度最小的扩充二叉树不一定是完全二叉树。**

**权值大的外节点离根节点最近的扩充二叉树——带权路径长度最小的二叉树。**

## Huffman树构造
利用堆的性质

在一组节点中选取两个值最小的节点取出，合并为新的根节点，放入最小堆中，继续进行。直到结束。

## Huffman树应用
### 最优判定树
一次猜测可将问题规模减半。这种决策和判定的过程可用最优二叉树表示。称为判定树。

> 等概率情况下的判定问题的最优判定树一定是完全树。

### Huffman编码
消除通信冗余，极大地提高通信信道的传输效率。是数据压缩的重要方法。

**变长编码**
为出现概率较高的字符指定较短的码字。会显著提高传输的平均性能。

**最优编码问题**
以字符出现概率为权值构造Huffman树，即可解决最优二进制编码问题。

不定长编码与定长编码对应于不同的Huffman树。
<u>所有的字符数据都存储在叶子结点上。其余节点或边只存放有关路径或权值信息。</u>




# 搜索树
又即：搜索结构

**平均搜索长度 ASL（average search length）** 
衡量搜索算法的时间效率标准：在搜索过程中关键码的平均比较次数或平均读写磁盘次数（外部搜索）。

## 二叉搜索树
从折半查找中进化而来：如果每次从搜索序列的中间进行搜索，把区间缩小一半，通过有限次迭代，很快就能逼近要寻找的元素。

进一步：直接输入搜索序列，构造出类似于折半搜索的判定树那样的树形结构，能够实现快速搜索。

**二叉搜索树即一种基于二叉树的动态搜索结构**

**概念**
- 每个节点都有一个作为搜索依据的关键码key，所有节点的关键码不相同
- 左子树上的节点关键码均小于根节点
- 右子树上的节点关键码均大于根节点
- 左子树和右子树都是二叉搜索树

**对二叉搜索树的中序遍历——能够得到排列起来的数组**

*二叉搜索树经常用来表示字典元素*
二叉搜索树的存储方式依旧是二叉链表。与普通二叉树相同。

### 插入
首先检查该元素是否在树中已经存在。

利用插入算法能够建立一棵二叉搜索树。
**每次节点的插入，都需要从根节点出发搜索插入位置，然后把新节点作为叶子结点插入。**

若插入序列不好，则会建立一棵单枝树，大幅降低搜索性能。

### 删除
1. 如果右子树为空：用左子树填补位置
2. 如果左子树为空：用右子树填补位置
3. 左右子树均不空：在其右子树中寻找中序下的第一个节点（关键码最小），用它的值填补到被删节点，再处理这个节点的删除问题，即递归处理。

### 性能分析
定义：
树的成功平均搜索长度ASL succ
树的失败平均搜索长度ASL unsucc

**ASL succ**
该树所有内部节点上的权值与搜索该节点时所需的关键码的比较次数 乘积之和。

**ASL unsucc**
树中所有外部节点上的权值与到达该外部节点所需关键码的比较次数 乘积之和。


## AVL树
即：平衡二叉搜索树。
引入其目的就是为了提高二叉搜索树的效率。

**Overview：**
每次向二叉搜索树插入一个新节点时调整树的结构，使得二叉搜索树保持平衡，从而尽可能降低树的高度，减少树的平均搜索长度。

**AVL树特点**
或者是空树，或者左子树和右子树都是AVL树。左子树和右子树高度之差不超过1

**平衡因子**
左右子树高度差的绝对值。
AVL树的任一节点平衡因子只能取0,-1,1

在每插入一个新节点时调整树的结构，使得二叉搜索树保持平衡，从而尽可能降低树的高度，减少平均搜索长度。

### 性能分析
如果一棵AVL树有n个节点，其高度可以保持在O(log2N),平均搜索长度也可保持在O(log2n)

### Balance旋转
每当插入一个新节点，AVL树中相关节点的平衡状态会发生改变。

<u>因此在**此时需要从插入位置向根的路径回溯**，检查各节点左右子树的高度差。如果发现平衡因子大于1，停止回溯。从发生不平衡的节点（即平衡因子为2的点 k1）起，沿刚才回溯路径取下两层的节点(k2,k3)。如果三个点在一条直线上，单旋转；若处于一条折线上，双旋转。</u>

### AVL删除
1. 若被删除节点p有两个孩子节点：选择p中序次序下的直接前驱q，q内容传送给p，问题转移为删除节点q，转化为只有一个孩子节点的情况。
2. 若被删除节点p最多只有一个孩子节点：可以一步简单调整

1. 被删节点为叶子节点：直接删除
2. 被删除节点只有一个孩子，删除，用孩子替代该节点的位置
3. 当被删除结点n存在左右孩子时，**真正的删除点**应该是n的中序遍历直接前驱，或者说是左子树最大的节点，之后n的值替换为真正删除点的值。这就归结为上述两种问题之一。


## 伸展树
一种与AVL树类似的改进型二叉搜索树。

与AVL树相同，属于自调整数据结构。

*AVL树中每一步的这种重新调整是否总是必要的呢？*
伸展树是另一种提高效率的方法，利用以下两种想法与思考：
- 单一旋转：目的是将经常访问的节点上移到靠近根的地方。
- 移动到根部

每当访问一个节点s时，伸展树就进行一次“展开”的过程。


## 红黑树
不具有非常严格平衡标准的二叉查找树。但使得树高稳定于logn
红黑树最高高度是2log(n+1)
### 概念
**红黑树是这样一棵二叉搜索树**：树中每一个节点的颜色不是黑色就是红色。
将红黑树视作一棵扩充二叉树，用外部节点表示空指针。
特性：
- 从根节点和所有外部节点的颜色是黑色
- 从根节点到外部节点的途中没有连续两个节点的颜色是红色。
- 所有从根到外部节点的路径上都有相同数目的黑色节点。

- 每个节点是黑色或红色
- 根节点和叶节点是黑色的
- 任何相邻的两节点不能同时为红色
- 任意节点到叶节点的树链中包含相同数量的黑节点


**对二叉搜索树来说，其操作复杂度主要取决于其树的高度。**

**黑高度**
从红黑树中任意节点x出发，到达一个外部节点的任意路径上的黑节点个数。
红黑树的黑高度定义为其黑节点的黑高度。


### 变色与旋转
**变色**


**左旋**


**右旋**

- 旋转操作不会改变树的中序遍历顺序
- 旋转操作通过降低高子树的高度，来维护二叉树的平衡

### 插入
**基本插入**
与二叉搜索树相同 每次插入节点的颜色是红色

**修复**
四种不同情况
