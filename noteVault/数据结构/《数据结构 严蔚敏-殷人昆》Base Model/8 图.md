图是另一种非线性数据结构，它的每一个顶点可以与多个其它顶点相关联，各顶点之间的关系是任意的。

# 图基本概念


**有向图**
有方向的图。

使用<x,y>表示无向图的一条边 尖括号表示有方向。表示从x到y的一条有向边。


**无向图**
使用(x,y)表示无向图的一条边。边没有特定方向。

**完全图**
完全图中的边数达到最大。

**权 weight**
代表边与之有相关的数值。带权图也称为**网络(network)**

**临接顶点 adjacent vertex**

**子图 subgraph**

**度 degree**
与顶点关联的边数称作度，记为deg(v)
有向图中：顶点的度=入度 + 出度

**路径**
就是点的集合的概念

**路径长度**
不带权图：路径长度指此路径上边的条数
带权图：路径长度指路径上各条边上的权值的和

**简单路径与回路**
在解决实际问题时，通常只考虑简单路径

**连通（弱连通）图**
在无向图中，若从顶点v1到v2有路径，则称这两点是联通的。

**联通（弱连通）分量**
非联通图的极大联通子图

**强连通图**
在有向图中，若在每一对顶点之间都存在一条双向的路径，则称这两点是强连通的。

**强连通分量**
非强连通图的极大强连通子图

**生成树**
即一幅图生成的树。
一个无向连通图的生成树是他的极小联通子图。若图中含有n个节点，则其生成树由n-1条边组成。

若是有向图，则可能得到其若干有向树组成的生成森林。

# 图的存储结构
## 邻接矩阵
表示图的一种简单的方法是使用一个二维数组，称为邻接矩阵(adjacent matrix)表示法。

边在数组中的一个值来代表：`A[u][v]`；
对于带权图，0表示矩阵对角线上的点，即自身成环的点；∞表示不连通。

| 0   | 1   | 2   | 3   | 4   | 5   |
| --- | --- | --- | --- | --- | --- |
| 1   |     |     |     |     |     |
| 2   |     |     |     |     |     |
| 3   |     |     |     |     |     |
| 4   |     |     |     |     |     |
| 5   |     |     |     |     |     |

**优点**
表示简单，容易理解和容易被人类观察
**缺点**
空间需求大。如果图的边不多（稀疏图），则空间需求则更为明显。若图示稠密（dense）的，则邻接矩阵是合适的表示方法。

## 邻接表
*为什么要给出邻接表表示法？*
在稀疏图的情况下，一个矩阵的大量位置都是0，极大浪费空间。

对每一个顶点，我们使用一个表存放所有邻接的顶点。
此时的空间需求相对于图的大小而言是线性的。

邻接表是表示图的标准方法。无向图可以类似地表示；每条边(u,v)出现在两个表中，因此空间的使用基本上是双倍的。在图论算法中通常需要找出与某个给定顶点v邻接的所有的顶点。而这可以通过简单地扫描相应的邻接表来完成，所用时间与这些找到的顶点的个数成正比。

[[邻接表]]

---
邻接表与临接矩阵关系比较
- 空间：在稀疏矩阵的情况下，邻接表明显优于临接矩阵
- 时间：邻接表的遍历速度远好于邻接矩阵
- 操作方便度：无向图中，邻接表一次操作需要修改两次相关内容，方便度远小于邻接矩阵。

# 图的遍历
*什么是遍历？*
==能覆盖所有的节点，并能让每个顶点只被访问一次。==

> 对于树结构而言，上述两点要求自然满足：因为树是连通的，故以任意个项点出发迟早都可以抵达其他的每个顶点。此外，树是无环图，故任意两个顶点之间最多只有一条通路。

1. **能覆盖所有节点**
对于非联通图，两个顶点之间可能不存在通路，每次只能遍历其中一个联通分量。为了保证所有顶点被访问，需要检测访问标志保证都被访问过。

2. **每个顶点只被访问一次**
因为图中难免存在回路，所以要避免此问题，需要设置标志位数组`visit[]`来记录是否已经被访问过。

## DFS
是一个不断探查和回溯的过程。


## BFS
没有探查和回溯的过程，是一个逐层遍历的过程。

图有多少顶点就要重复多少步。每一步都有一个当前顶点。

==BFS不是一个递归的过程，其算法也不是递归的。为了实现逐层访问，使用队列来辅助完成。==

在图的BFS算法中，每个顶点进队列一次且仅一次，因此算法中的while循环最多执行n次。

## 联通分量
当图为非联通图时，从图中某一顶点出发，利用DFS或BFS无法遍历图中的所有顶点，只能访问该顶点所在最大联通子图的所有顶点，这些顶点构成一个联通分量。

**利用DFS寻找图中的联通分量**
DFS每走完一遍退出遍历，意味着一个区域的联通分量都已经被深度遍历完成。即表示当前已经有一个联通分量，再继续下一个。

算法中调用DFS过程的次数与非联通图中的联通分量个数有关；而DFS过程的计算时间又与图的存储表示有关。

# 最小生成树
连通图中的每一棵生成树，都是原图的一个极大无环子图。
即：从中删除任何一条边，生成树就不再联通；反之，如果在其中插入任何一条新边，都会形成（恰好）一条回路。

以下两种最小生成树算法都采用了逐步求解的思路，即贪心算法。

同一带权图可能有多棵最小生成树。

## Kruskal算法
不断取最小边，检测是否产生回路，若未产生回路则插入该边，否则跳过该边。

> 在构造最小生成树的过程中，尚未处理的边存放在最小堆中。通过并查集的FInd运算，可以很快地判断任意一条边的两个端顶点是否来自同一个连通分量。

在算法初始的时候需要根据边的权值建立最小堆。

连续地按照最小的权选择边。并且当选择的边不产生圈时就把它作为索取定的边。

#myAlgoInspect 
还是一种贪婪策略。
形式上，Kruskal在处理一个森林——树的集合。当算法终止时就都合并为一棵树。

- Kruskal核心关键词：选择
选择最小的边是否成立，除非没有环路的情况。

## Prim算法
即处理最短桥

使其一步步长成。在每一步，把一个节点当做根并往上加边。

#myAlgoInspect 
- 与Dijkstra思想相同
- 遍历更新表格时无需加和，只需比较当前边长度。
- Prim关键词：扩散
==选择最小点 连接到树上 扩散周围未被标未T的点== 

# 最短路径
## 非负权值单源最短路径
对赋权图进行求解。但仍可使用来自无权图中的想法。

解决单源最短路径问题的一般方法是Dijkstra算法。
>这个有30年历史的解法是贪婪算法最好的例子。
>贪婪算法一般分阶段求解一个问题，在每个阶段都把出现当做最好的去处理。

**unknown的定义**
在每个阶段，Dijkstra算法选择一个顶点v,它在所有unknown顶点中具有最小的d.,同时算法声明从s到v的最短路径是known 的。阶段的其余部分由d值的更新工作组成。

#myAlgoInspect
- 三个辅助数组：
path[]记录前一个节点
dist[]记录到此点最短路径
set[]记录是否已遍历过
- djikstra关键：找出度



## 任意权值单源最短路径

# 拓扑排序
> 拓扑排序是对有向无圈图的顶点的一种排序，使得如果存在一条从vi到vj的路径，那么在排序中vj就出现在vi的后面。有向边(v,w)表明课程v必须在课程w选修前修完。这些课程的拓扑排序是不破坏课程结构要求的任意的课程序列。

**如果图中含有圈，则拓扑排序就是不可能的。对于圈上的任意两个顶点，互为先后，与定义矛盾。**
拓扑排序也不是唯一的；任何合理的排序都可以被称为一种拓扑排序。

- **一种简单想法的拓扑排序**

>一个简单的求拓扑排序的算法是先找出任意一个没有入边的顶点。然后显示出该顶点，并将它及其边一起从图中删除。然后，我们对图的其余部分同样应用这样的方法处理。——*寻找起始节点，删除之，然后继续寻找下一节点*

其时间复杂度会达到*O(V<sup>2</sup>)*。原因是对顶点数组的重复顺序扫描。尽管只有少部分节点被更新，但每次迭代期间为了检索入度为0的顶点，都扫描了所有顶点。

- **迭代1：减少对全体顶点的遍历次数**

使用一个栈或队列保存入度为0的顶点序列。下次选择只需在这个盒子中挑选即可。
算法时间复杂度*O(E+V)* 使用邻接表

# 点活动图 AOV网
Activity on Vector

用顶点表示活动的网络

可以用一个有向图来表示一个工程。
在这种有向图中，用顶点表示活动，用有向边<vi,vj>表示活动vi必须先于vj进行。

在AOV网络中，若Vi必须在Vj之前进行，则存在有向边<Vi,Vj>。直接前驱，直接后继。且这种前驱和后继关系具有传递性。

AOV网络具有反自反性，即AOV网络中不能出现有向环。若出现，则代表某项活动以自己为先决条件；程序也会出现死循环。

因此，对于给定的AOV网，必须先判断其是否存在有向环。

<u>检测有向环是在对AOV网络构造其拓扑有限序列。</u>

<u>构造AOV就是在构造该图的拓扑排序</u>

# 边活动图 AOE网
Activity on Edges

在没有环的有项带权图中，用有向边表示一个工程中的各项活动，用有向边上的权值表示活动持续时间，用顶点表示事件，则这样的有向图成为活动网络，AOE。

AOE网的作用：
*完成整个工程至少需要多少时间？*

*为缩短完成工程所需的时间，应当加快哪些活动？*

**关键路径**
完成整个工程所需的时间取决于从源点到汇点最长路径长度，即在这条路径上所有活动的持续时间之和。

**关键活动**
要找出关键路径，必须确定关键活动。

分析关键路径的目的：从源点出发开始估算各个活动，辨明哪些是影响整个工程进度的关键活动，以便科学的安排工作。
