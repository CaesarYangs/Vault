非常重要的线性结构。
栈和队列也是线性表的一种；其特殊在于栈和队列的基本操作是线性表操作的子集。是操作受限的线性表。

> 它们也属于线性序列结构,故其中存放的数据对象之间也具有线性次序。
>
> 相对于一般的序列结构,栈与队列的数据操作范围仅限于逻辑上的特定某端。然而,得益于其简洁性与规范性,它们既成为构建更复杂、更高级数据结构的基础,同时也是算法设计的基本出发点,甚至常常作为标准配置的基本数据结构以硬件形式直接实现。

# 栈

浏览器中的回退，编辑器中的撤销都是栈的应用实现。
## ADT 接口
**入栈与出栈**
栈顶 stack top
栈底 stack bottom

**后进先出 LIFO**

**Stack 模板类**
```cpp
template <typename T> class stack : public vector<T> {
public:
    void push(const T& x) {
        this->push_back(x);
    }
    T pop() {
        T x = this->back();
        this->pop_back();
        return x;
    }
    T& top() {
        return this->back();
    }
    const T& top() const {
        return this->back();
    }
    bool empty() const {
        return this->size() == 0;
    }
};
```

## 栈的表示和实现
### 顺序栈
先为栈分配一个基本容量，在使用过程中，当空间不够大时再逐段扩大。

**实现细节：**
1 第一种实现方式（top 指向栈顶空位置）
栈不存在：base == NULL
栈空标志：top == base
非空栈的 top 指针始终在栈顶元素的下一个位置上

- Push 时使用 top++
- Pop 时使用--top
- 栈满时 top=顺序表 size
- （C）空间不足时要先分配内存空间

2 另一种实现方式（top 指向栈顶第一个元素）
- push 时使用++top
- pop 时使用 top--
- 使用数组来定义栈：只需使用 top 一个标志位。top=-1 空栈；top=size-1 栈满。

读取栈顶元素的函数 `getTop()` 与退栈函数 `Pop()` 的区别是前者未改变栈顶指针的值。

**引申**
- 避免栈的溢出
- 双栈——两个栈同时使用的情况
当需要两个栈时，定义一个足够大的栈空间。空间的两端分别设为栈底，由两侧同时向中间作为分别的栈顶方向。直到两个栈顶指针相遇，则栈满溢出。
两个栈大小互相可变，动态调整，灵活性强。

在 n>2 个栈的情况下，多个栈共享空间的顺序表示将会非常复杂，且效率较低。解决方法是采用链式栈作为存储表示。

### 链式栈
便于节点的插入删除。在程序中同时使用多个栈的情况下，使用链接不仅能提高效率，还能够实现共享存储空间的目的。

**链式栈的栈顶出现在表头。**
新节点的插入和出栈删除操作均在链表表头，即栈顶进行。

# 栈与递归
==递归算法所需的空间量，主要决定于最大递归深度。==
recurve
**基本定义**
利用前面运算来求得答案的过程就叫递归过程。

**递归的重要结构**
- 递归结束条件
分解后的子问题可以独立求解时，就停止分解。
- 递归情况

一旦到达递归结束条件，调用函数的递归链中断，同时在返回的途中计算其他值。最终返回计算结果。

**递归背后的思想**
- **分治法**：分解问题的思想。将大问题分解为小问题的集合
- 递归过程直接反映定义的结构

## 递归使用
### 定义是递归的
**使用递归的定义**
阶乘，幂函数，斐波那契数列

### 数据结构是递归的
- 可将一个头指针为 first 的单链表定义为一个递归数据结构：
递归结束条件：first 为 NULL，自身是一个单链表（空表）
递归情况：first≠NULL，其指针域指向一个单链表，仍是一个单链表。

```Cpp
//找到链表的尾节点
LinkNode *FindRear(LinkNode *f){
    if(f==NULL){
        return NULL;
    }else if(f->next == NULL){
        return f;
    }else{
        FindRear(f->next);
    }
}
```

- 树形结构也是递归的。以多重链表形式存储。

### 问题的解法是递归的
有些问题只能用递归来解决。

**汉诺塔**
移动 n 个盘子可以分解为移动 n-1 个盘子；可以分解为移动 n-2 个；最后总可以分解为移动 1 个盘子。

**递推问题**
递归和递推是两个不同的概念。

递推是利用问题本身的递推关系对问题求解的办法。采用递推关系建立的算法有重要的递推性质。
**递推问题可以用递归方法求解，也可以用迭代（重复）方法求解。**

## 递归过程与工作栈
**外部调用**结束后，将返回调用递归过程的主程序。
**内部调用**结束后，将返回到递归过程内部本次调用语句的后继语句处。

### 递归工作栈
*解决调用递归时每一层级的参数传递和地址返回问题。*
递归工作栈-活动记录（递归工作记录）：

| 记录表                           |
| -------------------------------- |
| 返回位置（递归调用的下一条指令） |
| 局部变量                         |
| 参数的副本空间                   |

**在每进入一层递归时，系统就要建立一个新的活动记录，把上述项目登入，加到递归工作栈的栈顶。每退出一层递归，就从递归工作栈退出一个工作记录。**

- 第一步是沿着递归路径一路向下，直到递归终止。将其压栈
- 逐层向上返回，同时计算并压栈。

活动记录：

| 参数 long n | 返回位置<下一条指令> | 返回值 long temp |
| ----------- | -------------------- | ---------------- |

> 主程序外部调用的活动记录在栈的底部，随内部调用一层层地进栈。递归结束条件出现于函数 Fact(0)的内部,从此开始一连串的返回语句。退出栈顶的活动记录,控制按返回地址转移到上一层调用递归过程处。

### 用栈实现递归过程非递归算法
**利用栈将递归过程改造为非递归过程**

#myAlgoInspect
**本质上就是对一棵递归树的深度优先搜索**

![](https://img-blog.csdnimg.cn/20190119175303152.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2V2ZXJ5X19kYXk=,size_16,color_FFFFFF,t_70)

包含大小两循环。

```cpp
do{
    while(blabla){

    }
}while(stack.IsEmpty() == false)

```
实际上递归调用树所表示的就是在递归过程中实际的各种计算过程或节点。就是一个可视化递归计算过程。

本书所给的此类递归树栈式非递归解法，时间复杂度很高，效率差。参见《Java 语言描述》block: [[2 算法分析#^ce2051]] 或下文详见思考🤔。

### 用迭代法实现递归过程
上文所述递归调用树解法，时间复杂度达到*O(2^n)*。

利用递归方法可以大幅减少递归调用所消耗的时间复杂。
**一般对于尾递归或单向递归，都可利用迭代的方法，将递归改为非递归过程。**

- 单项递归：即解决类似斐波那契数列问题
- 尾递归：类树的后续遍历。

### *试探回溯法*
**试探与回溯**
> 忒修斯的高招, 与现代计算机中求解很多问题的算法异曲同工。 事实上, 很多应用问题的解, 在形式上都可看作若干元素按特定次序构成的一个序列。以经典的[[2 搜索 通过搜索进行问题求解|旅行商问题(traveling salesman problem, TSP)]]为例,其目标是计算出由给定的 n 个城市构成的一个序列,使得按此序列对这些城市的环游成本(比如机票价格)最低。尽管此类问题本身的描述并不复杂,但遗憾的是,由于所涉及元素(比如城市)的每一排列都是一个候选解,它们往往构成一个极大的搜索空间。

**剪枝**
为此, 必须基于对应用问题的深刻理解, 利用问题本身具有的某些规律尽可能多、 尽可能早地排除搜索空间中的候选解。其中一种重要的技巧就是,根据候选解的某些局部特征,以候选解子集为单位批量地排除。通常如图 4.7 所示,搜索空间多呈树状结构,而被排除的候选解往往隶属于同一分支,故这一技巧也可以形象地称作[[5 约束满足问题#树形结构 CSP|剪枝(pruning)]]。

**回溯**
与之对应的算法多呈现为如下模式。从零开始,尝试逐步增加候选解的长度。更准确地,这一过程是在成批地考查具有特定前缀的所有候选解。这种从长度上逐步向目标解靠近的尝试,称作试探(probing)。作为解的局部特征,特征前缀在试探的过程中一旦被发现与目标解不合, 则收缩到此前一步的长度,然后继续试探下一可能的组合。
特征前缀长度缩减的这类操作, 称作回溯(backtracking)。

<u>回溯的效果等同于剪枝</u>


## 应用
### 数制转换
10 进制转 8 进制
计算和输入的顺序和最后要输出的数正好相反，所以利用栈的特殊结构实现。

### 括号匹配

1.  从左到右扫描字符串
2.  遇到的左括号入栈
3.  遇到右括号，将其与栈顶括号匹配，同时删除左括号（即 pop 操作）

左括号 push
右括号和栈顶符号对比，检验是否匹配，并 pop

### 表达式计算
前缀，中缀，后缀

**编译程序一般使用后缀表示来求解表达式的值，解决了运算符优先级问题，同时只需一个栈即可实现。**
进行运算的操作数总在操作符前面。

- 操作数压栈
- 若为操作符 op，则令前两个数出栈，并计算 1op2，重新压栈
- 处理完成后，栈顶存放的就是表达式的值。

### 中缀转后缀
- 从左至右扫描运算式
- 数字一律不压栈，自动输出
- 操作符压栈；若优先级>栈顶 op 优先级则压栈；若优先级<=栈顶 op 优先级，则退栈并输出（相等时退栈不输出）
- 读入结束，将栈元素全部弹出，清空。

### 行编辑程序
退行符"#"
退行符"@"

将输入字符送入缓冲区（栈），检查栈顶字符，对栈进行相应操作（pop 或 clear）

# 队列
操作系统中的[[4 处理机调度#调度算法]]便是队列的一个直接应用。

**概念**
队列 queue 是另一种限定存取位置的线性表。只许在表的一端插入，另一端删除。

插入的一端为**队尾 rear**，删除的一端为**队首 front**。此特性便是 FIFO 先进先出。

## 队列的表示和实现
**Queue模板类**
```cpp
template <typename T> class Queue : public List<T> {
public:
    void enqueue(T value) {
        this->push_back(value);
    }
    T dequeue() {
        T value = this->front();
        this->pop_front();
        return value;
    }
    T& front() {
        return this->front();
    }
};
```


### 循环队列
即，基于数组的队列表示方式。也叫顺序队列。
利用 rear 和 front 指针来进行相应的队列元素管理。

- 声明时初始化队列：front = rear = 0
- 新元素入队，rear++ 此时的 rear 始终指向下一元素应当插入的位置。
- front 指向真正的队首位置

此种表示会产生**假溢出**

为了解决此问题，将输入首尾相接，形成环形队列存储。
- front = (front + 1)% maxSize
- rear = (rear + 1)% maxSize

- rear == front 代表队空标志
- rear 指向 front 的前一位置表示队列已满——会遗留一个空位置，用于区别队空与队满标记
- 最多只能存放 maxSize-1 个元素

### 链式队列
- front 指针：始终指向单链表头结点
- rear 指针：始终指向单链表尾节点

即：**双指针方法表示**

**用链式队列特别适合数据元素变动大的情形，且不存在队列满而溢出的情况。**

## 优先级队列
**每次从队列中取出优先级最高的元素**

为了提高优先级队列运算速度，后续会利用**堆作为优先级队列的存储结构，时间减少至*O(log2N)* 数量级**

## 双端队列
Deque，Double Ended Queue
可以在队列的两端插入和删除。

## 队列应用
### 循环分配器 Round Robin
即 操作系统中的[[5 存储管理#动态页式管理|动态页式管理——请求置换算法RoundRobin]]

在以上所谓轮值(round robin)算法中,首先令所有参与资源分配的客户组成一个队列Q。
接下来是一个反复轮回式的调度过程:取出当前位于队头的客户,将资源交予该客户使用;在经过固定的时间之后,回收资源,并令该客户重新入队。得益于队列“先进先出”的特性,如此既可在所有客户之间达成一种均衡的公平,也可使得资源得以充分利用。

