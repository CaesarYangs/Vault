递归的价值在于,许多应用问题都可简洁而准确地描述为递归形式。 以操作系统为例,多数[[6 文件系统]]的目录结构都是递归定义的。具体地,每个文件系统都有一个最顶层的目录,其中可以包含若干文件和下一层的子目录; 而在每一子目录中, 也同样可能包含若干文件和再下一层的子目录;如此递推,直至不含任何下层的子目录。通过如此的递归定义,文件系统中的目录就可以根据实际应用的需要嵌套任意多层(只要系统的存储资源足以支持)。

> 分支转向是算法的灵魂;函数和过程及其之间的相互调用,是在经过抽象和封装之后,实现分支转向的一种重要机制; 而递归则是函数和过程调用的一种特殊形式, 即允许函数和过程进行自我调用。

> 递归也是一种基本而典型的算法设计模式。 这一模式可以对实际问题中反复出现的结构和形式做高度概括,并从本质层面加以描述与刻画,进而导出高效的算法。从程序结构的角度看,递归模式能够统筹纷繁多变的具体情况, 避免复杂的分支以及嵌套的循环, 从而更为简明地描述和实现算法,减少代码量,提高算法的可读性,保证算法的整体效率。

# 线性递归
数组求和就是一种典型的线性递归操作。

```Cpp
int sum(int A[],n){
    if(1>n){
        return 0;
    }else{
        return sum(A,n-1) + A[n-1];
    }
}
```
可以理解为：<u>分解为两个独立的子问题。求一个数组的元素和就是前 n-1 个元素的求和+最后一个元素的值</u> `A[n-1]`

从中可以看出相应特点：为了保证递归算法有穷性，首先要判断“平凡情况”
**Base Case**
也称为递归基。base case 有多种情况，但至少要有一种且一定会出现。

**减而治之**
递归每深入一层，待求解问题的规模都缩减一个常数，直至最终退化为平凡小问题，即 base case。

# 递归分析

# 递归模式
## 多递归基 base case
针对每一类可能出现的平凡情况，都需设置对应的 base case，故一种算法的 base case 可能（显示或隐式）不止一个。

数组倒置问题：多 base case 递归版
```cpp
void reverse(int *A, int lo, int hi){
    if(lo<hi){
        swap(A[lo],A[hi]);
        reverse(A,lo+1,hi-1);
    }//else隐含了两种base case
}
```
**实现递归**
在设计递归算法时, 往往需要从多个角度反复尝试, 方能确定对问题的输入及其规模的最佳划分方式。有时,还可能需要从不同的角度重新定义和描述原问题,使得经分解所得的子问题与原问题具有相同的语义形式。

## 多向递归
不仅 base case 可能有多个，而且递归调用也可能有多种可选的分支。

每一递归实例虽有多个可能的递归方向,但只能从中选择其一,故各层次上的递归实例依然构成一个线性次序关系, 这种情况依然属于线性递归。

例如：可以根据不同的奇偶性进行递归操作。
针对输入参数 n 为奇数或偶数的两种可能,这里分别设有不同的递归方向。尽管如此,每个递归实例都只能沿其中的一个方向深入到下层递归, 整个算法的递归跟踪分析图的拓扑结构仍然与图 1.6 类似,故依然属于线性递归。

## 二分递归
**分而治之**
> 凡治众如治寡，分数是也
> ——孙子

利用每一层的多次递归，构造多路递归，将原问题一分为二，称为最终的二分递归。

例：数组求和问题
```cpp
int sum(int[] A,int lo,int hi){
    if(lo==hi){
        return A[lo];
    }else{
        int mid = (lo + hi)/2;
        return sum(A,lo,mid) + sum(A,mid+1,hi);
    }
}
```

例：Fibonacci 数列问题
```cpp
int fib(int n){
    if(n<2){
        return n;
    }else{
        return fib(n-1) + fib(n-2);
    }
}
```

**对递归算法的优化**
Fibonacci 数：迭代——利用动态规划

*我们之前一直写的简单的计算 fib 和的递归算法有何问题？*
反观以上线性递归版 fib()算法可见,其中所记录的每一个子问题的解答,只会用到一次。
在该算法抵达递归基之后的逐层返回过程中, 每向上返回一层, 以下各层的解答均不必继续保留。

若将以上逐层返回的过程, 等效地视作从递归基 base case 出发, 按规模自小而大求解各子问题的过程, 即可采用动态规划的策略,


```cpp
int fibI(int n){
	int f = 0,g = 1;//初始化fib(0) = 0,fib(1) = 1;
	while(0 < n--){
		g+=f;
		f = g - f;
	}
	return f;
}
```
这里仅使用了两个中间变量f和g, 记录当前的一对相邻Fibonacci数。 整个算法仅需线性步的迭代,时间复杂度为O(n)。更重要的是,该版本仅需常数规模的附加空间,空间效率也有了极大提高。

## 尾递归
在计算机学里，尾调用是指一个函数里的最后一个动作是返回一个函数的调用结果的情形，即最后一步新调用的返回值直接被当前函数的返回结果。此时，该尾部调用位置被称为尾位置。尾调用中有一种重要而特殊的情形叫做尾递归。经过适当处理，尾递归形式的函数的运行效率可以被极大地优化。尾调用原则上都可以通过简化函数调用栈的结构而获得性能优化（称为“尾调用消除”），但是优化尾调用是否方便可行取决于运行环境对此类优化的支持程度如何。

**特点**
尾递归在普通尾调用的基础上，多出了2个特征：
-   在尾部调用的是函数自身 （Self-called）；
-   可通过优化，使得计算仅占用常量栈空间 (Stack Space)。


> acc这种递归相当于外层调用依赖内层调用的结果，然后再做进一步的操作，最终由最外层的方法收口操作，返回最终结果。
> 
> 但尾递归由于将外层方法的结果传递给了内层方法，那外层方法实际上没有任何利用价值了，直接从栈里踢出去就行了，所以可以保证同时只有一个栈帧在栈里存活，节省了大量栈空间。

尾递归可以和while 循环相互转化。
  
[什么是尾递归？ - 知乎](https://www.zhihu.com/question/20761771/answer/1094636184)

[尾调用 - 维基百科，自由的百科全书](https://zh.wikipedia.org/wiki/%E5%B0%BE%E8%B0%83%E7%94%A8)

## 递归消除
**空间成本**
递归算法所消耗的主要空间量取决于递归深度。比较同一算法的迭代版，递归版往往会消耗更多的空间，进而影响实际的运行速度。

一般的转换思路是利用栈结构模拟操作系统的工作过程。
