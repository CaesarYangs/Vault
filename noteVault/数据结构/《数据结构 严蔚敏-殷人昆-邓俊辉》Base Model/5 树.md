线性结构不适合于描述有分支结构的数据。
**而树形结构是以分支关系定义的层次结构。** 是一类重要的非线性数据结构。

**树结构的出现是为了更好的查找效率和使用效率**
基本数据结构大致分为两种类型：数组与链表。
数组可以在常数时间内找到目标对象，然而一旦需要对这种结构进行修改，无论插入还是删除都需要花费线性时间；链表可以在常数时间内插入和删除等修改操作，但需要线性时间查找相关节点位置。

**半线性结构(semi-linear structure)**
在此前介绍的这些结构中, 元素之间都存在一个自然的线性次序, 故它们都属于所谓的线性结构(linear structure)。树中的元素之间并不存在天然的直接后继或直接前驱关系。只要附加某种约束(比如遍历),也可以在树中的元素之间确定某种线性次序。

> 相应地,算法设计的策略与模式也会因此有所变化, 许多基本的算法也将得以更加高效地实现。

> 树是一种分层结构,而层次化这一特征几乎蕴含于所有事物及其联系当中,成为其本质属性之一。从文件系统、互联网域名系统和数据库系统,一直到地球生态系统乃至人类社会系统,层次化特征以及层次结构均无所不在。

# 树基本概念
**自由树**
一个定义的二元组。包含顶点集合与边集合。最终形成一幅连通图。
free tree 是图论的重要研究内容。此章节不深入讨论。

主要研究有根有序树，其顶点统称为结点 node

**有根树 T**
n 个结点的有限集合。**一种递归/归纳的定义。**

根 root 是一个特殊结点。每个子集合也是一棵树，叫做根的子树 subtree

每课子树有且仅有一个直接前驱(即其上层结点)，可以有 0 或多个直接后继(下层结点)。

**结点 node**
包含数据项以及指向其他结点的分支

**结点的度 degree**
结点拥有的子树棵数。

**树的度 degree**
树种结点度的最大值。可以用图中的“出度”来进行理解。

**森林**
m 棵树的集合。
森林可以和树之间简单转化：删除一棵非空树的根节点，就变成森林。

# 二叉树
Binary Tree 是树形结构的一种重要类型。

特点是每个节点最多有两个子女(child)。
<u>即 二叉树中不存在度大于 2 的节点，且二叉树有左右子树之分，其次序不能颠倒，亦被称为有序二叉树。</u>

**二叉树的计算性质**
1.  a
2.  a
3.  a
4.  a
5.  a

## 二叉树存储表示
主要有两种表示：数组方式与链表方式。

### 数组方式
适用于二叉树形态不发生剧烈动态变化的场合。——especially 完全二叉树
可随机存取二叉树节点。

**完全二叉树存储**
自上而下，根据 BFS 的顺序作为数组存储的位置数据。可根据编号的公式找到兄弟，父亲甚至子女节点信息。

**一般二叉树存储**
基于上述的存储方式。将普通二叉树当做完全二叉树处理，需要空出不存在节点的位置。
极大地浪费了地址空间。

### 链表方式
**即：二叉链表**/三叉链表

 | leftChild | data | rightChild |
 | --------- | ---- | ---------- |

缺点：无法找到父节点。

**mark：广义表建立二叉树**
类似于二叉树的前序遍历过程，区分括号和逗号即可。

## 二叉树遍历
*什么是遍历？*
遵守某种次序，访问二叉树中的所有节点，使得每个节点被访问一次且只有一次。

### 递归算法
L-访问左子树 R-访问右子树 V-访问该节点

**前序遍历** VLR

**中序遍历** LVR

**后序遍历** LRV

与以上的先序和后序遍历序列做一对比不难发现, 各节点在中序遍历序列中的局部次序, 与按照有序树定义所确定的全局左、右次序完全吻合。这一现象并非巧合,在第 7 章和第 8 章中,这正是搜索树及其等价变换的原理和依据所在。

三种递归算法的时间复杂度是 O(n)

### 非递归算法
如果暂时不访问当前节点的数据，即放弃 V 操作，三种递归遍历的架构是完全一致的。也即三种算法他们走过的路径是一样的。

**三序遍历的非递归**

**改为非递归，则需要设立工作栈，记录回退路径**——即手工实现[[3 栈和队列#递归工作栈]]的概念。

**层序遍历**
即 BFS

### 迭代版遍历
递归版遍历算法时间、空间复杂度的常系数,相对于迭代版更大。同时,从学习的角度来看,从底层实现迭代式遍历,也是加深对相关过程与技巧理解的有效途径。

**先序遍历**
序列可分解为两段: 
1. 沿最左侧通路自顶而下访问的各节点
2. 自底而上遍历的对应右子树。

```java
//递归实现
void traverse_Inorder_R(TreeNode root){
	if(root!=null){
		visit(root.data);
		traverse_Inorder_R(root.left);
		traverse_Inorder_R(root.right);
	}
}

//迭代实现：两步走——沿着左下遍历 再沿着右子树向上返回
void traverse_Inorder_I(TreeNode root){
	while(root){
		visit(x.data);
		stack.push(x.right);  //右孩子进入缓存栈
		x = x.left;  //继续向左下行进
	}
}
```

**中序遍历**
沿最左侧通路自底而上,以沿途各节点为界,中序遍历序列可分解为d + 1段。各段均包括访问来自最左侧通路的某一节点Lk,以及遍历其右子树Tk。

```cpp
template <typename T>
static void goAlongLeftBranch(T& root, Stack& S) {
    while (root) {
        S.push(root);
        root = root->left;  //当前节点入栈后随即向左侧分支深入,迭代直到无左孩子
    }
}

template <typename T>
void traveralIn_I1(T& root){
    BinNode x;
    Stack S;    //辅助栈
    goAlongLeftBranch(root, S); //从根节点开始,迭代向左侧分支深入
    while (!S.empty()) {    //当栈不为空时,迭代输出栈顶元素
        T node = S.top();
        x = S.pop();    //弹出栈顶元素
        x = x->right;  //迭代向右侧分支深入
    }
}
```

**后序遍历**


### 二叉树的计数
*具有 n 个结点的不同二叉树有多少种？*

*给了一棵二叉树的前序和中序序列，是否能唯一地确定一棵二叉树？*
可以。

## 二叉树构造
前序和中序可以唯一确定一颗二叉树。
后序和中序可以唯一确定一颗二叉树。
前序和后序是**不能唯一确定**一颗二叉树的。因为没有中序遍历无法确定左右部分，也就是无法分割。

**完全二叉树**
叶节点只能出现在最底部的两层,且最底层叶节点均处于次底层叶节点的左侧。
得益于以上特性, 完全二叉树可以借助向量结构, 实现紧凑存储和高效访问

**满二叉树**
所有叶节点同处于最底层(非底层节点均为内部节点)。于是根据数学归纳法,每一层的节点数都应达到饱和,故将称其为满二叉树(full binary tree)。



## 线索二叉树
二叉树虽然是非线性结构，但二叉树的遍历却为二叉树的节点集导出了一个线性序列。因而，二叉树的节点存在关于这个线性序列的前驱和后继。

### 线索
即从某个节点出发，能够找到其在某种次序（前序，中序，后续）下的前驱和后继。

目的是找到前驱和后继而不用每次都对二叉树进行整体遍历。即需要把每个节点的前驱和后继信息记录下来。

节省空间：
利用空的 leftChild 存放前驱节点 rightChild 存放后继指针

**线索**
指示前驱与后继的指针叫做线索。
对应的二叉链表即**线索二叉链表**。
无需遍历二叉树就可得到任一节点的前驱和后继节点的地址。

| leftChild | ltag | data | rtag | rightChild |
| --------- | ---- | ---- | ---- | ---------- |

**指示指针 ltag 与 rtag**
tag = 0 表示 child 域中存放的是指向左右孩子的指针。*即正常树节点*
tag != 0 表示 child 域中存放的是前驱或后继节点的指针。

**利用线索二叉树**
利用 `First()` 找到遍历序列的第一个节点后，使用 `Next()` 寻找其后继节点。从而可以连成一个包含相对应遍历顺序(前，中，后)的长链表。以遍历的第一个元素为首，到最后一个为止。

*利用中序线索二叉树的信息，不仅可以实现中序遍历，还可以实现前序和后序遍历。*

# 树与森林
## 树的存储表示
**广义表表示法**

**父指针表示法**
以一组连续的存储单元来存放树中节点。每个节点两个域。

| data | parent |
| ---- | ------ |

**孩子链表表示法**
由于一般的树具有的左右孩子个数不相同。如果向二叉链表一样，，每个节点设置的左右指针个数也会完全不同，难以确定。

为树中每个节点设置一个子女链表（孩子链表），将这些节点对应的孩子链表的头指针放在一个向量中。类似于[[邻接表]]表示法. ^a55c35

适合于频繁寻找孩子节点的情况。

![](https://img-blog.csdnimg.cn/2020020513261515.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dteTAyMTdf,size_16,color_FFFFFF,t_70)

**孩子-兄弟链表表示法**
每个节点的度是 2，是最节省空间的树的存储表示。

| data | firstChild | nextSibling |
| ---- | ---------- | ----------- |

![](https://upload-images.jianshu.io/upload_images/5600819-df94e075d6577fca.png?imageMogr2/auto-orient/strip|imageView2/2/w/790/format/webp)

<u>即：孩子链表表示法的一种树形结构表示，而非使用邻接表形式表示。</u>
<u>与上述</u>[[#^a55c35|孩子链表表示法]]<u>是一种同构异性体的关系。</u>

### 森林与二叉树的转换
==森林与二叉树有一一对应关系。==

**每棵二叉树表示的根节点都没有右兄弟**

**森林转化为二叉树的规则**
1.  每棵树的根节点与其第一个孩子通过 firstChild 连接
2.  每棵树根的第一个孩子与同层兄弟通过 nextSibling 连接
3.  去掉每棵树根节点除第一个孩子外其余孩子的连接
4.  把每棵树的根节点通过 nextSibling 连接
<u>本质：通过转化为孩子-兄弟链表进而容易变为二叉树的做法</u>

其是一种递归的算法。每棵树转化为对应二叉树表示后，对每棵树根节点的子树森林进行同样的操作，最后都变换为二叉树为止。

**二叉树转换为森林的规则**

## 树和森林的遍历
### 树的 DFS
又可以分为先根次序 后根次序

**树的遍历不宜进行所谓中序遍历，因为树的叉链表个数不明确，不能准确地判断根节点位置。**

### 树的 BFS

# 堆
即二叉堆。
堆 heap 是优先级队列中最高效地一种数据结构。
## 堆的结构性质
堆是一棵完全二叉树。

## 最小堆和最大堆
**关键码 key**
一个能够标识数据记录或元素的数据项。

### 最小堆 mini-Heap
任意节点的关键码均小于或等于其左右孩子的关键码

**堆序 heap-ordered**
堆中所有的记录都具有的关系。

**最大堆 max-Heap**
任意节点的关键码均大于或等于其左右孩子的关键码。

## 堆的建立

# Huffman 树
最优二叉树。是一类加权路径长度最短的二叉树。

**路径长度**
指路径上的分支系数。树的路径长度是从树的根节点到每一个节点的路径长度之和。

本质思想：**从树的根节点到达树中每一节点有且仅有一条路径。**

**Huffman**
即：带权路径长度（Weighted Path Length，WPL）
**带权路径长度最小的扩充二叉树不一定是完全二叉树。**

**权值大的外节点离根节点最近的扩充二叉树——带权路径长度最小的二叉树。**

## Huffman 树构造
利用堆的性质

在一组节点中选取两个值最小的节点取出，合并为新的根节点，放入最小堆中，继续进行。直到结束。

## Huffman 树应用
### 最优判定树
一次猜测可将问题规模减半。这种决策和判定的过程可用最优二叉树表示。称为判定树。

> 等概率情况下的判定问题的最优判定树一定是完全树。

### Huffman 编码
消除通信冗余，极大地提高通信信道的传输效率。是数据压缩的重要方法。

**变长编码**
为出现概率较高的字符指定较短的码字。会显著提高传输的平均性能。

**最优编码问题**
以字符出现概率为权值构造 Huffman 树，即可解决最优二进制编码问题。

不定长编码与定长编码对应于不同的 Huffman 树。
<u>所有的字符数据都存储在叶子结点上。其余节点或边只存放有关路径或权值信息。</u>

