
> 曾仿效古希腊英雄忒修斯，以栈等基本数据结构模拟线绳和粉笔，展示了试探回溯策 略的应用技巧。实际上，这一技巧可进一步推广至更为一般性的场合，包括可以图结构描述的应 用问题，从而导出一系列对应的图算法。

> 忒修斯取得成功的关键在于，借助线绳掌握迷宫内各通道之间的联接关系。在很多应用中， 能否有效描述和利用这类信息，同样至关重要。一般地，这类信息往往可表述为定义于一组对象 之间的二元关系，比如城市交通图中，联接于各公交站之间的街道，或者互联网中，联接于IP 节点之间的路由，等等。尽管在某种程度上，第5章所介绍的树结构也可用以表示这种二元关系， 但仅限于父、子节点之间。相互之间均可能存在二元关系的一组对象，从数据结构的角度分类， 属于非线性结构(non-linear structure)。此类一般性的二元关系，属于图论(Graph Theory) 的研究范畴。从算法的角度对此类结构的处理策略，与上一章相仿，也是通过遍历将其转化为半 线性结构，进而借助树结构已有的处理方法和技巧，最终解决问题。

> 以下首先简要介绍图的基本概念和术语，已有相关基础的读者可直接跳过。接下来，介绍如 何实现作为抽象数据类型的图结构，主要讨论邻接矩阵和邻接表两种实现方式。然后，从遍历的 角度介绍将图转化为树的典型方法，包括广度优先搜索和深度优先搜索。进而，分别以拓扑排序 和双连通域分解为例，介绍利用基本数据结构并基于遍历模式，设计图算法的主要方法。最后， 从“数据结构决定遍历次序”的观点出发，将所有遍历算法概括并统一为最佳优先遍历这一模式。 如此，我们不仅能够更加准确和深刻地理解不同图算法之间的共性与联系，更可以学会通过选择 和改进数据结构，高效地设计并实现各种图算法这也是本章的重点与精髓。



图是另一种非线性数据结构，它的每一个顶点可以与多个其它顶点相关联，各顶点之间的关系是任意的。

# 图基本概念

- **图**
	- 图结构是描述和解决实际应用问题的一种基本而有力的工具。
	- 可定义为G = (V, E)。其中，集合V中的元素称作顶点(vertex);
	- 集合E中的元素分别对应于V中的 某一对顶点(u, v)，表示它们之间存在某种关系，故亦称作边(edge)
	- 

**有向图**
有方向的图。

使用<x,y>表示无向图的一条边 尖括号表示有方向。表示从x到y的一条有向边。

**无向图**
使用(x,y)表示无向图的一条边。边没有特定方向。

**完全图**
完全图中的边数达到最大。

**权 weight**
代表边与之有相关的数值。带权图也称为**网络(network)**

**临接顶点 adjacent vertex**

**子图 subgraph**

**度 degree**
与顶点关联的边数称作度，记为deg(v)
有向图中：顶点的度=入度 + 出度

**简单图**
联接于同一顶点之间的边，称作自环(self-loop)。
不含任何自环的图称作简单图(simple graph)——也是这种数据结构主要讨论的对象。

**路径**
就是点的集合的概念

**路径长度**
不带权图：路径长度指此路径上边的条数
带权图：路径长度指路径上各条边上的权值的和

**简单路径与回路**
在解决实际问题时，通常只考虑简单路径

**连通（弱连通）图**
在无向图中，若从顶点v1到v2有路径，则称这两点是联通的。

**联通（弱连通）分量**
非联通图的极大联通子图

**强连通图**
在有向图中，若在每一对顶点之间都存在一条双向的路径，则称这两点是强连通的。

**强连通分量**
非强连通图的极大强连通子图

**生成树**
即一幅图生成的树。
一个无向连通图的生成树是他的极小联通子图。若图中含有n个节点，则其生成树由n-1条边组成。

若是有向图，则可能得到其若干有向树组成的生成森林。

# 图的存储结构
## 邻接矩阵
表示图的一种简单的方法是使用一个二维数组，称为邻接矩阵(adjacent matrix)表示法。

<u>邻接矩阵(adjacency matrix)是图ADT最基本的实现方式，使用方阵A[n][n]表示由n
个顶点构成的图，其中每个单元，各自负责描述一对顶点之间可能存在的邻接关系，故此得名。</u>

边在数组中的一个值来代表：`A[u][v]`；
对于带权图，0表示矩阵对角线上的点，即自身成环的点；∞表示不连通。

| 0   | 1   | 2   | 3   | 4   | 5   |
| --- | --- | --- | --- | --- | --- |
| 1   |     |     |     |     |     |
| 2   |     |     |     |     |     |
| 3   |     |     |     |     |     |
| 4   |     |     |     |     |     |
| 5   |     |     |     |     |     |

**优点**
表示简单，容易理解和容易被人类观察
**缺点**
空间需求大。如果图的边不多（稀疏图），则空间需求则更为明显。若图示稠密（dense）的，则邻接矩阵是合适的表示方法。

- **邻接矩阵性能**
	- 时间性能：操作均只需要O(1)时间；单次操作耗时计入扩容时间也不超过O(n)
	- 空间性能：空间主要消耗于邻接矩阵。


## 邻接表
*为什么要给出邻接表表示法？*
在稀疏图的情况下，一个矩阵的大量位置都是0，极大浪费空间。

对每一个顶点，我们使用一个表存放所有邻接的顶点。
此时的空间需求相对于图的大小而言是线性的。

邻接表是表示图的标准方法。无向图可以类似地表示；每条边(u,v)出现在两个表中，因此空间的使用基本上是双倍的。在图论算法中通常需要找出与某个给定顶点v邻接的所有的顶点。而这可以通过简单地扫描相应的邻接表来完成，所用时间与这些找到的顶点的个数成正比。

[[邻接表]]

- **邻接表性能分析**
	- 空间性能：O(n+e) 与图自身的规模相当，较邻接矩阵有了很大改进
	- 时间性能：与顶点相关的操作接口仍然能够在O(1)时间内完成

---
邻接表与临接矩阵关系比较
- 空间：在稀疏矩阵的情况下，邻接表明显优于临接矩阵
- 时间：邻接表的遍历速度远好于邻接矩阵
- 操作方便度：无向图中，邻接表一次操作需要修改两次相关内容，方便度远小于邻接矩阵。

# 图的遍历
*什么是遍历？*
==访问所有顶点一次且仅一次；访问所有的边一次且仅一次==

> 对于树结构而言，上述两点要求自然满足：因为树是连通的，故以任意个项点出发迟早都可以抵达其他的每个顶点。此外，树是无环图，故任意两个顶点之间最多只有一条通路。

1. **能覆盖所有节点**
对于非联通图，两个顶点之间可能不存在通路，每次只能遍历其中一个联通分量。为了保证所有顶点被访问，需要检测访问标志保证都被访问过。

2. **每个顶点只被访问一次**
因为图中难免存在回路，所以要避免此问题，需要设置标志位数组`visit[]`来记录是否已经被访问过。

**无论采用何种策略和算法，图的遍历都可理解为，将非线性结构转化为半线性结构的过程。**
经遍历而确定的边类型中，最重要的一类即所谓的树边，它们与所有顶点共同构成了原图的一棵支撑树(森林)，称作遍历树(traversal tree)。以遍历树为背景，其余各种类型的边，也能提供关于原图的重要信息，比如其中所含的环路等。

> 与树遍历一样，作为图算法基石的图搜索，本身也必须能够高效地实现。幸运的是，正如我们马上就会看到的，诸如深度优先、广度优先、最佳优先等基本而典型的图搜索，都可以在线性 时间内完成。准确地，若顶点数和边数分别为n和e，则这些算法自身仅需O(n + e)时间。既然 图搜索需要访问所有的顶点和边，故这已经是我们所能期望的最优的结果。

<u>各种图搜索之间的区别，体现为边分类结果的不同，以及所得遍历树(森林)的结构差异。 其决定因素在于，搜索过程中的每一步迭代，将依照何种策略来选取下一接受访问的顶点。</u>
## DFS
是一个不断探查和回溯的过程。

==DFS 的本质就是回溯算法==

- 基本实现方法
	- 递归执行并访问
		- 首先访问顶点，再从其没有被访问的邻居中任取，递归执行 DFS 搜索。
	- 利用辅助栈进行操作

- **性能分析**
	- 空间性能：不超过 O(n+e)
	- 时间性能：同样需要花费 O(n+e)时间对顶点和边的状态复位；dfs 本身需要 O(n)时间；对每个节点和边的访问需要 O(1)时间。综合需要 O(n+e)时间。



## BFS
没有探查和回溯的过程，是一个逐层遍历的过程。图有多少顶点就要重复多少步。每一步都有一个当前顶点。

==BFS不是一个递归的过程，其算法也不是递归的。为了实现逐层访问，使用队列来辅助完成。==
在图的BFS算法中，每个顶点进队列一次且仅一次，因此算法中的while循环最多执行n次。

BFS(s)将覆盖起始顶点s所属的连通分量或可达分量，但无法抵达此外的顶点。 而上层主函数bfs()的作用，正在于处理多个连通分量或可达分量并存的情况。具体地，在逐个 检查顶点的过程中，只要发现某一顶点尚未被发现，则意味着其所属的连通分量或可达分量尚未触及，故可从该顶点出发再次启动BFS()，以遍历其所属的连通分量或可达分量。

如此，各次BFS() 调用所得的BFS树构成一个森林，称作BFS森林(BFS forest)。

- **BFS性能分析**
	- 空间性能：主要在于维护顶点访问次序的辅助队列 累计O(n + e)
	- 时间性能：BFS 函数对所有顶点枚举需要 O(n)时间；O(n + e)时间复位所有顶点和边状态；每个顶点操作仅需 O(1)时间。综合起来需要 O(n+e)时间


基于BFS搜索，可有效地解决连通域分解、最短路径等问题。

**BFS可以找到一点出发的最短距离**

## 联通分量
当图为非联通图时，从图中某一顶点出发，利用DFS或BFS无法遍历图中的所有顶点，只能访问该顶点所在最大联通子图的所有顶点，这些顶点构成一个联通分量。

**利用DFS寻找图中的联通分量**
DFS每走完一遍退出遍历，意味着一个区域的联通分量都已经被深度遍历完成。即表示当前已经有一个联通分量，再继续下一个。

算法中调用DFS过程的次数与非联通图中的联通分量个数有关；而DFS过程的计算时间又与图的存储表示有关。

# 最小生成树
连通图中的每一棵生成树，都是原图的一个极大无环子图。
即：从中删除任何一条边，生成树就不再联通；反之，如果在其中插入任何一条新边，都会形成（恰好）一条回路。

以下两种最小生成树算法都采用了逐步求解的思路，即贪心算法。

同一带权图可能有多棵最小生成树。

## Kruskal算法
不断取最小边，检测是否产生回路，若未产生回路则插入该边，否则跳过该边。

> 在构造最小生成树的过程中，尚未处理的边存放在最小堆中。通过并查集的FInd运算，可以很快地判断任意一条边的两个端顶点是否来自同一个连通分量。

在算法初始的时候需要根据边的权值建立最小堆。

连续地按照最小的权选择边。并且当选择的边不产生圈时就把它作为索取定的边。

#myAlgoInspect 
还是一种贪婪策略。
形式上，Kruskal在处理一个森林——树的集合。当算法终止时就都合并为一棵树。

- Kruskal核心关键词：选择
选择最小的边是否成立，除非没有环路的情况。

## Prim算法
即处理最短桥

使其一步步长成。在每一步，把一个节点当做根并往上加边。

#myAlgoInspect 
- 与Dijkstra思想相同
- 遍历更新表格时无需加和，只需比较当前边长度。
- Prim关键词：扩散
==选择最小点 连接到树上 扩散周围未被标未T的点== 

# 最短路径
## 非负权值单源最短路径
对赋权图进行求解。但仍可使用来自无权图中的想法。

解决单源最短路径问题的一般方法是Dijkstra算法。
>这个有30年历史的解法是贪婪算法最好的例子。
>贪婪算法一般分阶段求解一个问题，在每个阶段都把出现当做最好的去处理。

**unknown的定义**
在每个阶段，Dijkstra算法选择一个顶点v,它在所有unknown顶点中具有最小的d.,同时算法声明从s到v的最短路径是known 的。阶段的其余部分由d值的更新工作组成。

#myAlgoInspect
- 三个辅助数组：
path[]记录前一个节点
dist[]记录到此点最短路径
set[]记录是否已遍历过
- djikstra关键：找出度



## 任意权值单源最短路径

# 拓扑排序
> 拓扑排序是对有向无圈图的顶点的一种排序，使得如果存在一条从vi到vj的路径，那么在排序中vj就出现在vi的后面。有向边(v,w)表明课程v必须在课程w选修前修完。这些课程的拓扑排序是不破坏课程结构要求的任意的课程序列。

**如果图中含有圈，则拓扑排序就是不可能的。对于圈上的任意两个顶点，互为先后，与定义矛盾。**
拓扑排序也不是唯一的；任何合理的排序都可以被称为一种拓扑排序。

- **有向无环图**
	- *一个有向无环图是否一定存在拓扑排序？*——肯定的
	- 有向无环图对应于偏序关系，而拓 扑排序则对应于全序关系。在顶点数目有限时，与任一偏序相容的全序必然存在。

- **一种简单想法的拓扑排序**

>一个简单的求拓扑排序的算法是先找出任意一个没有入边的顶点。然后显示出该顶点，并将它及其边一起从图中删除。然后，我们对图的其余部分同样应用这样的方法处理。——*寻找起始节点，删除之，然后继续寻找下一节点*

其时间复杂度会达到*O(V<sup>2</sup>)*。原因是对顶点数组的重复顺序扫描。尽管只有少部分节点被更新，但每次迭代期间为了检索入度为0的顶点，都扫描了所有顶点。

- **迭代1：减少对全体顶点的遍历次数**

使用一个栈或队列保存入度为0的顶点序列。下次选择只需在这个盒子中挑选即可。
算法时间复杂度*O(E+V)* 使用邻接表

# 点活动图 AOV网
Activity on Vector

用顶点表示活动的网络

可以用一个有向图来表示一个工程。
在这种有向图中，用顶点表示活动，用有向边<vi,vj>表示活动vi必须先于vj进行。

在AOV网络中，若Vi必须在Vj之前进行，则存在有向边<Vi,Vj>。直接前驱，直接后继。且这种前驱和后继关系具有传递性。

AOV网络具有反自反性，即AOV网络中不能出现有向环。若出现，则代表某项活动以自己为先决条件；程序也会出现死循环。

因此，对于给定的AOV网，必须先判断其是否存在有向环。

<u>检测有向环是在对AOV网络构造其拓扑有限序列。</u>

<u>构造AOV就是在构造该图的拓扑排序</u>

# 边活动图 AOE网
Activity on Edges

在没有环的有项带权图中，用有向边表示一个工程中的各项活动，用有向边上的权值表示活动持续时间，用顶点表示事件，则这样的有向图成为活动网络，AOE。

AOE网的作用：
*完成整个工程至少需要多少时间？*

*为缩短完成工程所需的时间，应当加快哪些活动？*

**关键路径**
完成整个工程所需的时间取决于从源点到汇点最长路径长度，即在这条路径上所有活动的持续时间之和。

**关键活动**
要找出关键路径，必须确定关键活动。

分析关键路径的目的：从源点出发开始估算各个活动，辨明哪些是影响整个工程进度的关键活动，以便科学的安排工作。
