# 搜索树
又即：搜索结构

*建立搜索树的目的是什么？*
兼顾高效率的动态修改和静态查找

**平均搜索长度 ASL（average search length）**
衡量搜索算法的时间效率标准：在搜索过程中关键码的平均比较次数或平均读写磁盘次数（外部搜索）。

## 二叉搜索树
从折半查找中进化而来：如果每次从搜索序列的中间进行搜索，把区间缩小一半，通过有限次迭代，很快就能逼近要寻找的元素。

进一步：直接输入搜索序列，构造出类似于折半搜索的判定树那样的树形结构，能够实现快速搜索。

**二叉搜索树即一种基于二叉树的动态搜索结构**

**概念**
- 每个节点都有一个作为搜索依据的关键码 key，所有节点的关键码不相同
- 左子树上的节点关键码均小于根节点
- 右子树上的节点关键码均大于根节点
- 左子树和右子树都是二叉搜索树

**中序遍历搜索**
对二叉搜索树的中序遍历——能够得到排列的递增数组。

*二叉搜索树经常用来表示字典元素*

二叉搜索树的存储方式依旧是二叉链表。与普通二叉树相同。

---
二叉搜索树的三个基本对外接口即：`search()`,`insert()`,`remove()`
#数据结构算法
### 查找 search
二叉搜索树的查找算法，亦采用了减而治之的思路与策略，其执行过程可描述为:
> 从树根出发，逐步地缩小查找范围，直到发现目标(成功)或缩小至空树(失败)

**效率**
在二叉搜索树的每一层，查找算法至多访问一个节点，且只需常数时间，故总体所需时间应
线性正比于查找路径的长度，或最终返回节点的深度。

最好情况：目标关键码出现在树根 O(1)即可完成
最坏情况：二叉搜索树**退化**为一条单链表，则需要 O(n)时间才能完成。已经失去了树的性质，查找效率很低。

### 插入 insert
- **插入算法**
    - 首先需要利用查找算法 search()确定插入的位置及方向，然后才能将新节点作为叶子插入。 检查该元素是否在树中已经存在。
    - 无论插入成功与否，都会返回一个位置，以保证算法的一致性
    - 利用插入算法能够建立一棵二叉搜索树。
    - 若插入序列不好，则会建立一棵单枝树，大幅降低搜索性能。

**每次节点的插入，都需要从根节点出发搜索插入位置，然后把新节点作为叶子结点插入。**

- **效率**
    - 主要时间消耗是利用 `search()` 算法查找插入位置，每一层仅消耗 O(1)时间
    - 则其时间复杂度主要取决于新节点深度，最坏不超过全树高度

### 删除 remove

- **删除算法**
    - 也同样需要调用 `search()` 算法，查找目标节点是否存在以及返回其位置
    - **单分支情况**：利用存在的子树进行替换即可
    - **双分支情况**
        - 找到该节点的直接后继：即该节点右子树的最左孩子节点（关键码最小节点）
        - 交换二者的数据项。便将要删除节点转化为单分支问题
        - 根据单分支解决方法处理即可。

- **效率**
    - 主要取决于 `search()`,`succ()` 函数的调用。
    - 总体时间复杂度不超过全树高度

### 总体性能分析
定义：
树的成功平均搜索长度 ASL succ
树的失败平均搜索长度 ASL unsucc

**ASL succ**
该树所有内部节点上的权值与搜索该节点时所需的关键码的比较次数 乘积之和。

**ASL unsucc**
树中所有外部节点上的权值与到达该外部节点所需关键码的比较次数 乘积之和。

## AVL 树
即：平衡二叉搜索树。
引入其目的就是为了提高二叉搜索树的效率。

- 树高与性能
    - 三个主要操作接口的运行时间均线性正比与二叉搜索树的高度
    - 如果不加以处理，二叉搜索树会退化为单叉树，也就是普通单向链表

- 平衡的衡量
    - 理想平衡：故在节点数目固定的前提下，应尽可能地降低高度。相应地，应尽可能地使兄弟子树的高度彼此接近，即全树尽可能地平衡。
    - 适度平衡：若将树高限制为“渐进地不超过 O(logn)”，AVL 树，以及伸展树、红黑树、kd-树等，都属于适度平衡。

- 二叉搜索树的等价变换
    - 若两棵二叉搜索树的中序遍历序列相同，则他们等价。

- 平衡性
    - 平衡二叉搜索树的适度平衡性，都是通过对树中每一局部增加某种限制条件来保证的。比如，在红黑树中，从树根到叶节点的通路，总是包含一样多的黑节点;在 AVL 树中，兄弟节点的高度 相差不过 1。

- 局部性
    - 经过单次动态修改操作后，至多只有 O(1)处局部不再满足限制条件
    - 总可在 O(logn)时间内，使这 O(1)处局部(以至全树)重新满足限制条件

**等价变换**
这就意味着:刚刚失去平衡的二叉搜索树，必然可以迅速转换为一棵等价的平衡二叉搜索树。 等价二叉搜索树之间的上述转换过程，也称作等价变换。

> 这里的局部性至关重要。比如，尽管任何二叉搜索树都可等价变换至理想平衡的完全二叉树， 然而鉴于二者的拓扑结构可能相去甚远，在最坏情况下我们为此将不得不花费 O(n)时间。反观 图 7.10 中相互等价的两棵二叉搜索树，右侧属于 AVL 树，而左侧不是。鉴于二者的差异仅限于某 一局部(阴影区域)，故可轻易地将后者转换为前者。

*那么，此类局部性的失衡，具体地可以如何修复?如何保证修复的速度?*
旋转调整——通用方法。对所有的二叉搜索树类型均适用。

### 性质
通过合理设定适度平衡的标准，并借助以上等价变换，AVL 树可以实现近乎理想的平衡。在渐进意义下，AVL 树可始终将其高度控制在 O(logn)以内，从而保证每次查找、 插入或删除操作，均可在 O(logn)的时间内完成。

**AVL 树特点**
或者是空树，或者左子树和右子树都是 AVL 树。左子树和右子树高度之差不超过 1

**平衡因子**
左右子树高度差的绝对值。
AVL 树的任一节点平衡因子只能取 0,-1,1

在每插入一个新节点时调整树的结构，使得二叉搜索树保持平衡，从而尽可能降低树的高度，减少平均搜索长度。

**平衡性**
完全二叉树必是 AVL 树。

> 高度为 h 的 AVL 树的确至少包含 fib(h + 3) - 1 个节点。于是反过来，包含 n 个节点的 AVL 树的高度应为 O(logn)。因此就渐进意义而言，AVL 树的确是平衡的。

#数据结构算法
### Balance 旋转——重新平衡
每当插入一个新节点，AVL 树中相关节点的平衡状态会发生改变。

首先，从 x 出发沿 parent 指针逐层上行并核对平衡因子， 首次遇到的失衡祖先即为 g(x)。既然原树是平衡的，故这一过程只需 O(logn)时间。

**单旋转 single rotation**
这种情况是插入发生在“外部边”的情况（即左 - 左的情况或右 - 右的情况）。该情况通过对树的一次单旋转操作而完成调整。

**双旋转**
在一些情况下，由于存在两个边界内的中间子树太深，单次旋转没有降低它的深度。因此引出双旋转方法。

#myAlgoInspect
***New Balance 问题***
==总是能够将平衡问题简化为 k1,k2,k3 三个点的旋转问题。==
k1：平衡因子为 2 的点——最重要
k3：平衡因子为 1
k2：紧挨着 k3 距离新加入的错误节点最近

然后分析归类——单旋转 or 双旋转
==仅在判定好的以 k1 为根的部分子树中进行旋转操作即可，不会影响树的其余部分。==

单旋转：以靠近 k1 的一个节点为新根进行旋转，且主要枝干不发生变化。
==双旋转：就是先进行一次子树旋转后，满足条件再进行一次单旋转 解决问题==

在大单旋转的时候要考虑细节节点的放置问题。
且所有的平衡问题都能在一次操作后成为新的满足条件的 AVL 树。

<u>在 AVL 树中插入新节点后，仅需不超过两次旋转，即可使整树恢复平衡。</u>

<u>因此在**此时需要从插入位置向根的路径回溯**，检查各节点左右子树的高度差。如果发现平衡因子大于 1，停止回溯。从发生不平衡的节点（即平衡因子为 2 的点 k1）起，沿刚才回溯路径取下两层的节点(k2,k3)。如果三个点在一条直线上，单旋转；若处于一条折线上，双旋转。</u>

### AVL 删除
与一般二叉搜索树的删除操作完全相同，只是需要在删除后进行一次平衡调整过程。
1.  若被删除节点 p 有两个孩子节点：选择 p 中序次序下的直接前驱 q，q 内容传送给 p，问题转移为删除节点 q，转化为只有一个孩子节点的情况。
2.  若被删除节点 p 最多只有一个孩子节点：可以一步简单调整

1.  被删节点为叶子节点：直接删除
2.  被删除节点只有一个孩子，删除，用孩子替代该节点的位置
3.  当被删除结点 n 存在左右孩子时，**真正的删除点**应该是 n 的中序遍历直接前驱，或者说是左子树最大的节点，之后 n 的值替换为真正删除点的值。这就归结为上述两种问题之一。

**失衡传播**
与插入操作不同，在删除节点之后，尽管也可通过单旋或双旋调整使局部子树恢复平衡，但 就全局而言，依然可能再次失衡。

失衡传播的方向必然自底而上，而不致于影响到后代节点。在此过程中的任一时刻， 至多只有一个失衡的节点;高层的某一节点由平衡转为失衡，只可能发生在下层失衡节点恢复平 衡之后。因此，可沿 parent 指针逐层遍历所有祖先，每找到一个失衡的祖先节点，即可套用以 上方法使之恢复平衡。

### 性能分析
如果一棵 AVL 树有 n 个节点，其高度可以保持在 O(log2N),平均搜索长度也可保持在 O(log2n)

- **插入操作**
    - 插入节点：需要 O(logn)时间
    - 检查平衡性问题：需要 O(logn)时间
    - 恢复平衡：最多旋转两次
    - <u>总体插入操作需要 O(logn)时间即可完成</u>

- **删除操作**
    - 相比起插入操作需要多几步进行重新平衡
    - 所需重平衡节点都是祖先节点，故冲平衡过程累计不超过 O(logn)时间
    - <u>总体删除操作需要 O(logn)时间即可完成</u>

## 伸展树
一种与 AVL 树类似的改进型二叉搜索树。与 AVL 树相同，属于自调整数据结构。

*AVL 树中每一步的这种重新调整是否总是必要的呢？*
伸展树是另一种提高效率的方法，利用以下两种想法与思考：
- 单一旋转：目的是将经常访问的节点上移到靠近根的地方。
- 移动到根部

每当访问一个节点 s 时，伸展树就进行一次“展开”的过程。

伸展树无需时刻都严格地保持全树的平衡，但却能够在任何足够长 的真实操作序列中，保持分摊意义上的高效率。伸展树也不需要对基本的二叉树节点结构，做任 何附加的要求或改动，更不需要记录平衡因子或高度之类的额外信息，故适用范围更广。

### 局部性
通常在任意数据结构的生命期内，不仅执行不同操作的概率往往 极不均衡，而且各操作之间具有极强的相关性，并在整体上多呈现出极强的规律性。其中最为典型的，就是所谓的“数据局部性”(data locality)

1.  刚刚被访问过的元素，极有可能在不久之后再次被访问到
2.  将被访问的下一元素，极有可能就处于不久之前被访问过的某个元素的附近

因此，只需将刚被访问的节点，及时地“转移”至树根(附近)，即可加速后续的操作。

### 逐层伸展
**简易伸展树**
一种直接方式是:每访问过一个节点之后，随即反复地以它的父节点为轴，经适当的旋转将
其提升一层，直至最终成为树根。

*通过自下而上的一系列等价变换，可使任一节点上升至树根*
随着节点E的逐层上升，两侧子树的结构也不断地调整，故这一过程也称作伸展(splaying)， 而采用这一调整策略的二叉搜索树也因此得名。

- 简易伸展树存在很多问题：
	- 搜索效率和普通的二叉搜索树相当
	- 树的结构会经过搜索而还原，导致最坏情况持续出现

**双层伸展**
为克服上述伸展调整策略的缺陷，一种简便且有效的方法就是:将逐层伸展改为双层伸展。 具体地，每次都从当前节点v向上追溯两层(而不是仅一层)，并根据其父亲p以及祖父g的相对 位置，进行相应的旋转。

- zig-zig/zag-zag
	- 即：进行两次AVL平衡中的单旋转
	- 连续两次向左/向右进行旋转操作
- zig-zag/zag-zig
	- 即：进行一次AVL平衡中的双旋转
- zig/zag
	- 若v最初深度为奇数，则经过若干次双层调整后的最后一次调整时，v的父亲即是树根。
	- 此时只需围绕树根进行一次单旋转即可结束伸展过程。

稍作对比不难看出，就调整之后的局部结构而言，zig-zag和zag-zig调整与此前的逐层伸 展完全一致(亦等效于AVL树的双旋调整)，而zig-zig和zag-zag调整则有所不同。事实上， 后者才是双层伸展策略优于逐层伸展策略的关键所在。

<u>伸展树中较深的节点一旦被访问到，对应分支长度将随即减半。</u>——伸展树的性能意义。

> 伸展树虽不能杜绝最坏情 况的发生，却能有效地控制最坏情况发生的频度，从而在分摊意义下保证整体的高效率。

### 性能分析
在使用双层伸展策略后，伸展树的单次操作均可在O(logn)时间内完成。


# B-树
## 多路平衡查找
- **分级存储**
	- 实践证明，分级存储才是行之有效的方法。
	- 在由内存与外存(磁盘)组成的二级存储系统中，数据全集往往存放于外存中，计算过程中则可将内存作为外存的高速缓存，存放最常用数据项的复本。借助高效的调度算法，如此便可将内存的“高速度”与外存的“大容量”结合起来。


*当数据规模大到内存已不足以容纳时，常规平衡二叉搜索树的效率将大打折扣。*
上述情况的原因在于：查找过程对外存的访问次数过多。
若将10^9个记录在外存中组织为AVL树，则每次查找大致需做30次外存访问。

- **多路搜索树**
	- <u>外部存储器适合于批量式访问</u>：就时间成本而言，读取物理地址连续的一千个字节，与读取单个字节几乎没有区别。
	- 通过时间成本相对极低的<u>多次内存操作</u>，来替代时间成本相对极高的<u>单次外存操作</u>。
	- 相应地，需要将通常的二叉搜索树，改造为多路搜索树（在中序遍历的意义下，这也是一种等价变换。）
	- 一般地，以k层为间隔如此重组， 可将二叉搜索树转化为等价的2^k路搜索树，统称多路搜索树(multi-way search tree)。

*为什么多路搜索树能够优化外存的读取策略和方式？*
实际上，在此时的搜索每下降一层，都以“大节点” 为单位从外存读取一组(而不再是单个)关键码。更为重要的是，这组关键码在逻辑上与物理上 都彼此相邻，故可以批量方式从外存一次性读出，且所需时间与读取单个关键码几乎一样。

> 每组关键码的最佳数目，取决于不同外存的批量访问特性。比如旋转式磁盘的读写操作多以扇区为单位，故可根据扇区的容量和关键码的大小，经换算得出每组关键码的最佳规模。 例如若取k = 8，则每个“大节点”将拥有255个关键码和256个分支，此时同样对于1G个记录， 每次查找所涉及的外存访问将减至4~5次。

## 多路平衡搜索树
m路平衡搜索树即：m路B-树

所有外部节点均深度相等。同时，每个内部节点都存有不超过m - 1个关键码，以及 用以指示对应分支的不超过m个引用。

B-树的外部节点(external node)更加名副其实——它们实际上未必意味着查找失败，而可能表示目标关键码存在于更低层次的某一外部存储系统中，顺着该节点的指示，即可深入至 下一级存储系统并继续查找。正因为如此，不同于常规的搜索树，在计算B-树高度时，还需要计入其最底层的外部节点。

B-树的宽度(亦即最底层外部节点的数目)往往远大于其高度。

## 关键码查找
B-树结构非常适宜于在相对更小的内存中，实现对大规模数据的高效操作。

可以将大数据集组织为B-树并存放于外存。对于活跃的B-树，其根节点会常驻于内存;此外，任何时刻通常只有另一节点(称作当前节点)留驻于内存。

**B-树查找过程：**
从根节点开始，通过关键码的比较不断深入至下一层，直到某一关键码命中(查找成功)，或者到达某一外部节点(查找失败)。

**与普通二叉搜索树的不同：**
与二叉搜索树的不同之处在于，因此时各节点内通常都包含多个关键码，故有可能需要经过 (在内存中的)多次比较，才能确定应该转向下一层的哪个节点并继续查找。

- **整个查找分为两个位置：**
	- 在同一个大节点中进行比较时完全在内存中进行。
	- 切换或更新当前节点时才会发生IO操作，从外存中取数据。

#数据结构算法 
## 关键码插入
- **插入过程**
	- 先调用`search()`在树中查找关键码，检查是否有重复。
	- 查找过程必然终止于某一外部节点v。在其中查找关键码，确定插入位置。
	- 检查是否满足B-树条件。否则，发生一次上溢(overflow)并进行节点分裂。

### 上溢与分裂
{ k0, ..., ks-1; ks; ks+1, ..., km-1 }

- 上溢：令处于中间位置的关键码Ks上升一层。归入父节点（若存在）中的适当位置。
- 分裂：分别以两个子节点作为其左右孩子。即分裂。

- **上溢**
	- 存在着三种基本情况及其处理方式：
	- a1：原上溢父节点存在，且足以容纳一个关键码：只需将上溢节点按次序插入父节点
	- b1：上溢父节点存在，但处于饱和状态：上溢的向上传递。插入后再次进行上溢即可
	- c1：上溢传递至根节点，父节点不存在：令提升的关键码自成一个新的根节点，全树增高。

## 关键码删除
- **删除过程**
	- 先调用`search()`在树中查找关键码
	- 与直接后继（前驱）互换位置，保证删除的关键码所属节点为叶子节点。
	- 将节点e从树v中删去。节点v中所含的关键码以及分支将分别减少一个。
	- 若该节点所含关键码总数不合法，则使该节点进行下溢操作。重新满足B树要求

#还不太会 
### 下溢与合并
在删除过程中发生节点个数小于最小值限制。



## 性能分析

### 查找
B-树查找操作所需的时间不外乎消耗于两个方面:
1. 将某一节点载入内存
2. 在内存中对当前节点进行查找。

鉴于内存、外存在访问速度上的巨大差异，相对于前一类时间消耗，后一类时间消耗可以忽略不计。也就是说，B-树查找操作的效率**主要取决于查找过程中的外存访问次数**。

*整个查找过程中需要访问多少次外存？*
在每一高度上至多访问 一个节点。这就意味着，对于高度为h的B-树，外存访问不超过O(h - 1)次。
也即：整个B-树的查找效率主要取决于B-树的高度。

- **树高**
	- 关键码总数固定时，为使B-树更矮，每个内部节点都应该包含尽可能多的关键码。

- **复杂度分析**
	- 每次查找过程共需访问O(logmN)个节点
	- 相应地需要做O(logmN)次外存读取操作。
	- 由此可知：对存有N个关键码的m阶B-树的每次查找操作，耗时不超过O(logmN)。
	- 使用B-树后，实际访问效率尽管没有渐进意义上的改进，但比之前大概降低了一个数量级。

### 插入
- **复杂度分析**
	- 关键码的移动和复制操作所需时间都可以忽略。
	- 上溢操作每一递归实例只需常数之间。且递归层数不超过B-树高度。
	- 对于存有N个关键码的m阶B-树，每次插入操作都可在O(logmN)时间内完成。






## 红黑树
不具有非常严格平衡标准的二叉查找树。但使得树高稳定于 logn
红黑树最高高度是 2log(n+1)
### 概念
**红黑树是这样一棵二叉搜索树**：树中每一个节点的颜色不是黑色就是红色。
将红黑树视作一棵扩充二叉树，用外部节点表示空指针。
特性：
- 从根节点和所有外部节点的颜色是黑色
- 从根节点到外部节点的途中没有连续两个节点的颜色是红色。
- 所有从根到外部节点的路径上都有相同数目的黑色节点。

- 每个节点是黑色或红色
- 根节点和叶节点是黑色的
- 任何相邻的两节点不能同时为红色
- 任意节点到叶节点的树链中包含相同数量的黑节点

**对二叉搜索树来说，其操作复杂度主要取决于其树的高度。**

**黑高度**
从红黑树中任意节点 x 出发，到达一个外部节点的任意路径上的黑节点个数。
红黑树的黑高度定义为其黑节点的黑高度。

### 变色与旋转
**变色**

**左旋**

**右旋**

- 旋转操作不会改变树的中序遍历顺序
- 旋转操作通过降低高子树的高度，来维护二叉树的平衡

### 插入
**基本插入**
与二叉搜索树相同 每次插入节点的颜色是红色

**修复**
四种不同情况
