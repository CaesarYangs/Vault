# Intro

> 类似地，在多用户环境中，操作系统调度程序必须决定在若干进程中运行哪个进程。一般一个进程只被允许运行一个固定的时间片。一种算法是使用一个队列。开始时作业被放到队列的末尾。调度程序将反复提取队列中的第一个作业并运行它，直到运行完毕，或者该作业的时间片用完，并在作业未运行完毕时把它放到队列的末尾。这种策略一般并不太合适，因为一些很短的作业由于一味等待运行而要花费很长的时间去处理。一般说来，短的作业要尽可能快地结束，这一点很重要，因此在已经运行的作业当中这些短作业应该拥有优先权。此外，有些作业虽不短小但很重要，也应该拥有优先权。

需要一类特殊的队列，即优先级队列（priority queue）

**outline**
- 优先队列ADT的有效实现
- 优先队列的使用
- 优先队列的高级实现

> 我们将看到的这类数据结构属于计算机科学中最精致的一种

# 模型
最主要操作：
- 插入队列（入队）
- 删除最小者（即第一个出队）

除了操作系统外，优先队列还有许多的应用。在第7章，我们将看到优先队列如何用于外部排序。在贪婪算法(greedy algorithm)的实现方面优先队列也是很重要的，该算法通过反复求出最小元来进行操作；在第9章和第10章我们将看到一些特殊的例子。本章将介绍优先队列在离散事件模拟中的一个应用。

**一些简单的实现**
1. 用一个简单链表在表头以O(1)执行插入操作，并遍历该链表以删除最小元，又使用O(N)时间。
2. 始终让链表保持排序状态。使得插入代价O(N),出队为O(1)。而出队操作的使用要少于插入操作，1反而稍好。
3. 二叉查找树。其对两种操作的平均运行时间都是O(logN)。但反复删去左子树的最小元会导致树不平衡

使用查找树可能有些过分，因为它支持许许多多并不需要的操作。我们将要使用的基本的数据结构不需要链，它以最坏情形时间O(logN)支持上述两种操作。插入操作实际上将花费常数平均时间，若无删除操作的干扰，该结构的实现将以线性时间建立一个具有N项的优先队列。然后，我们将讨论如何实现优先队列以支持有效的合并。这个附加的操作似乎有些复杂， 它显然需要使用链接的结构。

# 二叉堆 binary heap
我们将要使用的这种工具叫作二叉堆(binary heap),它的使用对于优先队列的实现相当普遍，以至于当堆(heap)这个词不加修饰地用在优先队列的上下文中时，一般都是指数据结构的这种实现。在本节，我们把二叉堆只叫作堆。

类似二叉查找树，堆也有两个性质：结构性和堆序性。与AVL树类似，对堆的一次操作可能破坏这两个性质中的一个。

## 结构性质
堆是一棵完全二叉树。

因为完全二叉树非常有规律，所以其可以利用一个数组实现而不必须使用链。（即层次遍历）

| 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  | 11  | 12  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
|     | A   | B   | C   | D   | E   | F   | G   | H   | I   | J   |     |     |

对于数组中任一位置i上的元素，其左儿子在位置2i上，右儿子在左儿子后的单元(2i+1) 中，它的父亲则在位置L/2上。因此，这里不仅不需要链，而且遍历该树所需要的操作极简单， 在大部分计算机上运行很可能非常快。这种实现方法的唯一问题在于，最大的堆大小需要事先估计，但一般这并不成问题（而且如果需要，我们可以重新调整大小）。在图6-3中，堆大小的限界是13个元素。该数组有一个位置0，后面将详细叙述。

因此，一个堆结构将由一个(Comparable对象的)数组和一个代表当前堆的大小的整数组成。
本章我们将始终把堆画成树，这意味着具体的实现将使用简单的数组。

## 堆序性质
让操作快速执行的性质是堆序性质(heap-order property)。由于我们想要快速找出最小元， 因此最小元应该在根上。如果我们考虑任意子树也应该是一个堆，那么任意节点就应该小于它的所有后裔。

应用这个逻辑，我们得到堆序性质。在一个堆中，对于每一个节点X, X的父亲中的关键字小于或等于X中的关键字，根节点除外（它没有父亲）。

根据堆序性质，最小元总可以在根处找到。因此，我们能够以常数时间操作得到最小值。

## 基本的堆操作
无论是从概念上还是实际上考虑，执行这两个所要求的的操作都是容易的。所有工作都需要始终保持堆序性质。

**insert**
为将一个元素X插入到堆中，我们在下一个可用位置创建一个空穴，否则该堆将不是完全树。
如果X可以放在该空穴中而并不破坏堆的序，那么插入完成。否则，我们把空穴的父节点上的元素移入该空穴中，这样，空穴就朝着根的方向上冒一步。继续该过程直到X能被放人空穴中为止。
*向上找根*

这种一般操作叫做***上虑(percolate up)***;新元素在堆中上虑直到找出正确的位置。

如果欲插入的元素是新的最小元从而一直上滤到根处，那么这种插入的时间将长达O(logN)。平均看来，上滤终止得要早；业已证明，执行一次插入平均需要2.607次比较，因此平均insert操作上移元素1.607层。
*本次操作可以使用原地交换或只需一条语句的将元素下推*

**deleteMin**
deleteMin以类似于插入的方式处理。找出最小元是容易的，困难之处是删除它。当删除一个最小元时，要在根节点建立一个空穴。由于现在堆少了一个元素，因此堆中最后一个元素X必须移动到该堆的某个地方。如果X可以被放到空穴中，那么deleteMin完成。不过这一般不太可能，因此我们将空穴的两个儿子中较小者移入空穴，这样就把空穴向下推了一层。

重复该步骤直到X可以被放入空穴中。因此，我们的做法是将X置入沿着从根开始包含最小儿子的一条路径上的一个正确的位置。
*向下找叶*

这种操作一般叫***下虑(percolate down)***。在其实现中使用类似于在insert中用过的技巧来避免原地交换操作。*即只需一条语句的元素上移*

在堆的实现中经常发生的错误是当堆中存在偶数个元素的时候，将遇到一个节点只有一个儿子的情况。我们必须保证节点不总有两个儿子的前提，因此这就涉及一个附加的测试。
在图6-12描述的程序中，我们已在第29行进行了这种测试。一种极其巧妙的解决方法是始终保证算法把每一个节点都看成有两个儿子。为了实施这种解法，当堆的大小为偶数时在每个下滤开始处，可将其值大于堆中任何元素的标记放到堆的终端后面的位置上。我们必须在深思熟虑以后再这么做，而且必须插入一个是否确实使用这种技巧的评判。虽然这不再需要测试右儿子的存在性，但是还是需要测试何时到达底层，因为对每一片树叶算法将需要一个标记。

## 其他堆操作
注意，虽然求最小值操作可以在常数时间完成，但是，按照求最小元设计的堆（也称作最小堆，(min)heap)在求最大元方面却无任何帮助。

事实上，一个堆所蕴涵的序信息很少，因此， 若不对整个堆进行线性搜索，是没有办法找出任何特定的关键字的。为说明这一点，考虑大型堆结构（具体元素没有标出），我们在这里看到，关于最大值的元素所知道的唯一信息是：该元素在树叶上。但是，半数的元素位于树叶上，因此该信息是没什么价值的。由于这个原因，如果重要的是要知道元素都在什么地方，那么除堆之外，还必须用到诸如散列表等某些其他数据结构（回忆：该模型并不允许查看堆内部）。

如果我们假设通过某种其他方法得知每一个元素的位置，那么就有几种其他操作的开销变小。下述前三种操作均以对数最坏情形时间运行。

**decreaseKey 降低关键字的值**
decreaseKey(p,△)操作降低在位置p处的项的值，降值的幅度为正的量△。由于这可能破坏堆序性质，因此必须通过*上滤*对堆进行调整。
该操作对系统管理员是有用的：系统管理员能够使他们的程序以最高的优先级来运行。

**increaseKey 增加关键字的值**
increaseKey(p,△)操作增加在位置p处的项的值，增值的幅度为正的量△。这可以用*下滤*来完成。
许多调度程序自动地降低正在过多地消耗CPU时间的进程的优先级。

**delete 删除**
delete(p)操作删除堆中位置p上的节点。该操作通过首先执行decreaseKey(p,无穷) 然后再执行deleteMin()来完成。
当一个进程被用户中止（而不是正常终止）时，它必须从优先队列中除去。

**buildHeap 构建堆**
有时二叉堆是由一些项的初始集合构造而得。这种构造方法以N项作为输入，并把它们放到一个堆中。显然，这可以使用N个相继的insert操作来完成。由于每个insert将花费O(1) 平均时间以及O(logN)的最坏情形时间，因此该算法的总的运行时间是O(N)平均时间而不是O(N log N)最坏情形时间。由于这是一种特殊的指令，没有其他操作干扰，而且我们已经知道该指令能够以线性平均时间来执行，因此，期望能够保证线性时间界的考虑是合乎情理的。

# 优先队列的应用
## 选择问题
*找出第K个最大元素*
**算法6A**
为了简单起见，假设我们只考虑找出第k个最小的元素。该算法很简单。我们将N个元素读入一个数组。然后对该数组应用buildHeap算法。最后，执行k次deleteMin操作。从该堆最后提取的元素就是我们的答案。显然，只要改变堆序性质，就可以求解原始的问题：找出第k个最大的元素。

在排序部分，我们将细化该想法，得到一种快速的排序算法，即堆排序（heapsort）

## 事件模拟
**排队问题**


# d-堆
d-堆是二叉堆的简单推广，它就像一个二叉堆，只是所有节点都有d个孩子（因此，二叉堆是2-堆）。

注意，d-堆要比二叉堆浅得多，它将insert操作的运行时间改进为O(log.N)。然而，对于大的d,deleteMin操作费时得多，因为虽然树是浅了，但是d 个儿子中的最小者是必须要找出的，如使用标准的算法，这会花费d-1次比较，于是将操作的用时提高到O(dlog.N)。
如果d是常数，那么当然两个的运行时间都是O(logN)。虽然仍然可以使用一个数组，但是，现在找出儿子和父亲的乘法和除法都有个因子d,除非d是2的幂，否则将会大大增加运行时间，因为我们不能再通过移一个二进制位来实现除法了。d堆在理论上很有趣，因为存在许多算法，其插入次数比deleteMin的次数多得多（因此理论上的加速是可能的)。当优先队列太大而不能完全装入主存的时候，d-堆也是很有用的。在这种情况下，d-堆能够以与B树大致相同的方式发挥作用。最后，有证据显示，在实践中4堆可以胜过二叉堆。

---
**除不能实施find外，堆实现的最明显的缺点是：将两个堆合并成一个堆是困难的操作。**
这种附加的操作叫作合并(merge)。存在许多实现堆的方法使得一次merge操作的运行时间是O(logN)。现在我们就来讨论三种复杂程度不一的数据结构，它们都有效地支持merge操作。我们将把复杂的分析推迟到第11章讨论。

# 左式堆
设计一种堆结构像二叉堆那样有效地支持合并操作（即以o(N)时间处理一个merge)而且只使用一个数组似乎很困难。原因在于，合并似乎需要把一个数组拷贝到另一个数组中去，对于相同大小的堆这将花费时间⊙(N)。
**正因为如此，所有支持有效合并的高级数据结构都需要使用链式数据结构。**
实践中，我们预计这将可能使得所有其他操作变慢。

左式堆(leftist heap)像二叉堆那样也具有结构性和有序性。事实上，和所有使用的堆一样，左式堆具有相同的堆序性质，该性质我们已经看到过。

不仅如此，左式堆也是二叉树。左式堆和二叉堆唯一的区别是：左式堆不是理想平衡的(perfectly balanced),而实际上趋向于非常不平衡。

## 左式堆性质
**零路径长**
从任意节点X到一个不具有两个孩子节点的最短路径的长。

**左式堆性质是：对于堆中的每一个节点X,左儿子的零路径长至少与右儿子的零路径长相等。**

这个性质实际上超出了它确保树不平衡的要求，因为它显然偏重于使树向左增加深度。确实有可能存在由左节点形成的长路径构成的树（而且实际上更便于合并操作）一因此，我们就有了名称左式堆(leftist heap)。

因为左式堆趋向于加深左路径，所以右路径应该短。事实上，沿左式堆右侧的右路径确实是该堆中最短的路径。否则，就会存在过某个节点X的一条路径通过它的左儿子，此时X就破坏了左式堆的性质。

## 左式堆操作

# 斜堆

# 二项队列

# 标准库中的优先队列
在Java1.5之前，Java类库中不存在对优先队列的支持。然而在Java1.5中出现了泛型类PriorityQueue,在该类中insert、findMin和deleteMin通过调用add、element和remove而被表示。PriorityQueue对象可以通过无参数、一个比较器、或另一个兼容的集合构浩出来

