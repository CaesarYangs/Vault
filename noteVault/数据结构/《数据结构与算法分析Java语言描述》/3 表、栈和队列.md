# 抽象数据类型
抽象数据类型(abstract data type,ADT)是带有一组操作的一些对象的集合。抽象数据类型是数学的抽象；在ADT的定义中没有地方提到关于这组操作是如何实现的任何解释。诸如表、集合、图以及与它们各自的操作一起形成的这些对象都可以被看做是抽象数据类型，这就像整数、实数、布尔数都是数据类型一样。整数、实数和布尔数各自都有与之相关的操作，而抽象数据类型也是如此。对于集合ADT,可以有像添加(add)、删除(remove)以及包含(contain)这样一些操作。当然，也可以只要两种操作并(union)和查找(find),这两种操作又在这个集合上定义了一种不同的ADT。

# 表 ADT
## 数组
由固定容量创建

在java中可以随着使用扩展数组长度。

数组的实现可以使得printList以线性时间被执行，而findKth操作则花费常数时间， 这正是我们所能够预期的。不过，插入和删除的花费却潜藏着昂贵的开销，这要看插入和删除发生在什么地方。最坏的情形下，在位置0的插入（即在表的前端插入）首先需要将整个数组后移一个位置以空出空间来，而删除第一个元素则需要将表中的所有元素前移一个位置，因此这两种操作的最坏情况为O()。

平均来看，这两种操作都需要移动表的一半的元素，因此仍然需要线性时间。另一方面，如果所有的操作都发生在表的高端，那就没有元素需要移动，而添加和删除则只花费O(1)时间。

## 链表
为了避免插入和删除的线性开销，需要保证表可以不连续存储，否则表的每个部分都需要整体移动。

链表由一系列节点组成，这些节点不必在内存中相连。每一个节点均含有表元素和到包含该元素后继元的节点的链(Iink)。我们称之为next链。最后一个单元的next链引用null。

操作只需线性时间完成

**双链表**
让每一个节点持有一个指向它在表中的前驱节点的链。


## Java Collections API中的表
在类库中，Java语言包含有一些普通数据结构的实现。该语言的这一部分通常叫作Collections API。表ADT是在Collections API中实现的数据结构之一。

### Collection接口
Collections API位于java.util包中。集合(collection)的概念在Collection接口中得到抽象，它存储一组类型相同的对象。

```java
	int size();
	boolean isEmpty();
	void clear();
	boolean contains(AnyType x);
	boolean add(AnyType x);
	boolean remove(AnyType x);
```

常用的对于基本数据结构内部的操作均被Collection接口定义。适用于几乎全部定义好的数据结构中。

**Collection接口扩展了Iterable接口**。实现Iterable接口的那些类可以拥有增强的。for循环，该循环施于这些类之上以观察它们所有的项。

### Iterator接口
实现Iterable接口的集合必须提供一个称为iterator的方法，该方法返回一个iterator 类型的对象。该Iterator是一个在java.uti1包中定义的接口。

Iterator接口的思路是，通过iterator方法，每个集合均可创建并返回给客户一个实现Iterator接口的对象，并将当前位置的概念在对象内部存储下来。

- 每次对next的调用都给出集合的下一项。

`remove()方法`
Iterator的remove方法的主要优点在于，Collection的remove方法必须首先我出要被删除的项。如果知道所要删除的项的准确位置，那么删除它的开销很可能要小得多。下一节我们将要看到一个例子，是在集合中每隔一项删除一项。这个程序用迭代器(iterator)很容易编写，而且比用Collection的remove方法潜藏着更高的效率。

### List接口,ArrayList类与LinkedList类
本节跟我们关系最大的集合就是表(list),它由java.util包中的List接口指定。List 接口继承了co11 ection接口，因此它包含co11 ection接口的所有方法，外加其他一些方法。

```java
public interface List<E> extends Collection<E> {
	Iterator<E> iterator();	
	Object[] toArray();
	boolean add(E e);
	E get(int index);
	E set(int index, E element);
	void add(int index, E element);
	E remove(int index);
}
```


List ADT有两种流行的实现方式。
ArrayList类提供了List ADT的一种可增长数组的实现。使用ArrayList的优点在于，对get和set的调用花费常数时间。其缺点是新项的插入和现有项的删除代价昂贵，除非变动是在ArrayList的末端进行。LinkedList类则提供了List ADT的双链表实现。

使用LinkedList的优点在于，新项的插人和现有项的删除均开销很小，这里假设变动项的位置是已知的。这意味着，在表的前端进行添加和删除都是常数时间的操作，由此LinkedList更提供了方法addFirst和removeFirst、addLast和removeLast、以及getFirst和getLast等以有效地添加、删除和访问表两端的项。使用LinkedList的缺点是它不容易作索引，因此对get的调用是昂贵的，除非调用非常接近表的端点。

# 栈ADT
栈(stack)是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫作栈的顶(top)。对栈的基本操作有push(进栈)和pop(出栈)，前者相当于插入，后者则是删除最后插入的元素。最后插入的元素可以通过使用top例程在执行pop之前进行考查。

对空栈进行的pop或top一般被认为是栈ADT中的一个错误。另一方面，当运行push时空间用尽是一个实现限制，但不是ADT错误。

栈是LIFO后进先出表。

## 栈的实现
由于栈是一个表，因此任何实现表的方法都能实现栈。显然，ArrayList和LinkedList 都支持栈操作；99%的时间它们都是最合理的选择。偶尔设计一种特殊目的的实现可能会更快(例如，如果被放到栈上的项属于基本类型)。因为栈操作是常数时间操作，所以，除非在非常独特的环境下，这是不可能产生任何明显的改进的。

对于栈的操作无论是使用那种数据结构实现，都是以非常快的常数时间运行。在某些机器上甚至可以将push和pop写成一条机器指令。
最现代化的计算机将栈操作作为其指令系统的一部分，这个事实强化了这样一种观念，**即栈很可能是在计算机科学中在数组之后的最基本的数据结构。**

## 栈的应用
> 少量的操作却非常强大和重要。

**平衡符号**
编译器检查语法错误。括号以及各种符号的匹配。
检查是否存在开放符号，满足封闭符号的要求。

**后缀表达式**
加减乘除运算时的优先级解决。

这个记法叫作后缀(postfix)或逆波兰(reverse Polish)记法，其求值过程恰好就是上面所描述的过程。计算这个问题最容易的方法是使用一个栈。当见到一个数时就把它推人栈中；在遇到一个运算符时该算符就作用于从该栈弹出的两个数（符号）上，再将所得结果推入栈中。

计算一个后缀表达式的时间复杂度是*O(N)*，因为对输入中的每个元素的处理都是一些由栈操作组成从而花费常数的时间。计算非常简单，且不必知道任何优先级规则。

**中缀到后缀的转换**
这个算法的想法是，当看到一个操作符的时候，把它放到栈中。栈代表挂起的操作符。然而，栈中有些具有高优先级的操作符现在知道当它们不再被挂起时要完成使用，应该被弹出。
这样，在把当前操作符放入栈中之前，那些在栈中并在当前操作符之前要完成使用的操作符被弹出。

只需要*O(N)* 时间复杂度并经过一趟输入后完成。

**方法调用**
这里的问题是，当调用一个新方法时，主调例程的所有局部变量需要由系统存储起来，否则被调用的新方法将会重写由主调例程的变量所使用的内存。

不仅如此，该主调例程的当前位置也必须要存储，以便在新方法运行完后知道向哪里转移。这些变量一般由编译器指派给机器的寄存器，但存在某些冲突（通常所有的方法都是获取指定给1号寄存器的某些变量），特别是涉及递归的时候。

递归总是能够被彻底去除（编译器是在转变成汇编语言时完成递归去除的），一般是使用一个递归栈来完成这项任务。

# 队列ADT
像栈一样，队列也是表。然而使用队列时插入在一端而删除则在另一端进行。

如同栈的情形一样，对于队列而言任何的表的实现都是合法的。像栈一样，对于每一种操作，链表实现和数组实现都给出快速的O(1)运行时间。

## 队列的数组实现
使用数组存放队列并且解决空间利用问题——循环数组。只要front或back到达数组尾端，它就又绕回到开头。

## 队列的应用
有许多使用队列给出高效运行时间的算法。他们当中有些可以在图论中找到。

排队，排队论，文件服务器排队使用etc


# 小结
表、栈和队列或许在全部计算机科学中是三个基本的数据结构，大量的例子证明了它们广泛的用途。特别地，我们看到栈是如何用来记录过程和方法调用的，以及递归实际上是如何实现的。这对于我们的理解非常重要，其原因不只因为它使得过程语言成为可能，而且还因为知道递归的实现从而消除了围绕其使用的大量谜团。虽然递归非常强大，但是它并不是完全随意的操作；递归的误用和乱用可能导致程序崩溃。