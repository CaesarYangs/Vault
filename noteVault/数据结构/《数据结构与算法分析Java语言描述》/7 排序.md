# Intro
> 在这一章，我们讨论元素数组的排序问题。为简单起见，假设例子中的数组只包含整数， 当然我们的程序也允许更一般的对象。对于本章的大部分内容，我们还假设整个排序工作能够在主存中完成，因此，元素的个数相对来说比较小（小于几百万）。当然，不能在主存中完成而必须在磁盘或磁带上完成的排序也相当重要。这种类型的排序叫作外部排序(external sorting), 将在本章末尾进行讨论。

# 插入排序
最简单的排序算法之一是插入排序(insertion sort)。插入排序由N-1趟排序组成。'对于p=1到N-1趟，插入排序保证从位置0到位置p上的元素为已排序状态。插入排序利用了这样的事实：已知位置0到位置p-1上的元素已经处于排过序的状态。图7-1显示一个数组样例在每一趟插入排序后的情况。











# 希尔排序
希尔排序(Shellsort)的名称源于它的发明者Donald Shell,该算法是冲破二次时间屏障的第一批算法之一，不过，直到它最初被发现的若干年后才证明了它的亚二次时间界。正如上节所提到的，它通过比较相距一定间隔的元素来工作；各趟比较所用的距离随着算法的进行而减小， 直到只比较相邻元素的最后一趟排序为止。由于这个原因，希尔排序有时也叫作缩减增量排序(diminishing increment sort)。

先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录"基本有序"时，再对全体记录进行依次直接插入排序。

# 堆排序
正如第6章提到的，优先队列可以用于以O(N1ogN)时间的排序。基于该思想的算法叫作堆排序(heapsort),它给出了我们至今所见到的最佳的大O运行时间。

回忆在第6章建立N个元素的二叉堆的基本策略，这个阶段花费O(N)时间。然后我们执行N次deleteMin操作。按照顺序，最小的元素先离开堆。通过将这些元素记录到第二个数组然后再将数组拷贝回来，得到N个元素的排序。由于每个deleteMin花费时间O(logN), 因此总的运行时间是O(N log N)。

该算法的主要问题在于它使用了一个附加数组。因此存储需求增加了一倍。

使用这种策略，在最后一次deleteMin后，该数组将以递减的顺序包含这些元素。如果我们想要这些元素排成更典型的递增顺序，那么可以改变有序的特性使得父亲的关键字的值大于儿子的关键字的值。这样就得到(max)堆。

在我们的实现方法中将使用一个(max)堆，但由于速度的原因避免了实际的ADT。
**照通常的习惯，每一件事都是在数组中完成的。第一步以线性时间建立一个堆。然后通过每次将堆中的最后元素与第一个元素交换，执行N-1次deleteMax操作，每次将堆的大小缩减1并进行下滤。当算法终止时，数组则以排好的顺序包含这些元素。**

# 归并排序
现在我们把注意力转到归并排序(mergesort)。归并排序以O(N log N)最坏情形时间运行， 而所使用的比较次数几乎是最优的。它是递归算法一个好的实例。

**这个算法中基本的操作是合并两个已排序的表**。因为这两个表是已排序的，所以若将输出放到第3个表中，则该算法可以通过对输入数据一趟排序来完成。

==就是利用双指针的思路==+递归

> 因此，归并排序算法很容易描述。如果N=1，那么只有一个元素需要排序，答案是显然的。否则，递归地将前半部分数据和后半部分数据各自归并排序，得到排序后的两部分数据， 然后使用上面描述的合并算法再将这两部分合并到一起。例如，欲将8元素数组24,13,26,1,2,27,38,15排序，递归地将前4个数据和后4个数据分别排序，得到1,13,24,26,2,15， 27,38。然后，像上面那样将这两部分合并，得到最后的表1,2,13,15,24,26,27,38。该算法是经典的分治(divide-and-conquer)策略，它将问题分(divide)成一些小的问题然后递归求解， 而治(conquer)的阶段则将分的阶段解得的各答案修补在一起。分而治之是递归非常有效的用法。

# 快速排序


# 线性时间的排序：桶排序和基数排序


# 外部排序


