# 图的定义
## 基本概念
> 一个图(graph)G=(V,E)由顶点(vertex)的集 V 和边(edge)的集 E 组成。每一条边就是一幅点对(v,w),其中 v,w∈V。有时也把边称作弧(arc)。
> 如果点对是有序的，那么图就是有向(directed)的。有向的图有时也叫作有向图(digraph)。顶点 w 和 v 邻接(adjacent)当且仅当(v, w)∈E。
> 在一个具有边(v,w)从而具有边(w,v)的无向图中，w 和 v 邻接且 v 也和 w 邻接。有时候边还具有第三种成分，称作权(weight)或值(cost)。

如果图含有一条从一个顶点到其自身的边(v,v)，那么路径 v，v 也被称为环(loop)。我们要讨论的图一般是无环的。
一条简单路径，其上的所有顶点都是互异的，但第一个顶点和最后一个可能相同。

**连通**/**强连通**
一个无向图中从每一个顶点到每个其他顶点都存在一条路径

**弱联通**
如果一个有向图不是强连通的，但是它的基础图(underlying graph),即其弧上去掉方向所形成的图，是连通的。

**完全图**
是其每一对顶点间都存在一条边的图。

## 图的表示
### 邻接矩阵
表示图的一种简单的方法是使用一个二维数组，称为邻接矩阵(adjacent matrix)表示法。

边在数组中的一个值来代表：`A[u][v]`；∞表示不连通。

| 0   | 1   | 2   | 3   | 4   | 5   |
| --- | --- | --- | --- | --- | --- |
| 1   |     |     |     |     |     |
| 2   |     |     |     |     |     |
| 3   |     |     |     |     |     |
| 4   |     |     |     |     |     |
| 5   |     |     |     |     |     |

**优点**
表示简单，容易理解和容易被人类观察
**缺点**
空间需求大。如果图的边不多（稀疏图），则空间需求则更为明显。若图示稠密（dense）的，则邻接矩阵是合适的表示方法。

### 邻接表
对每一个顶点，我们使用一个表存放所有邻接的顶点。
此时的空间需求相对于图的大小而言是线性的。

邻接表是表示图的标准方法。无向图可以类似地表示；每条边(u,v)出现在两个表中，因此空间的使用基本上是双倍的。在图论算法中通常需要找出与某个给定顶点 v 邻接的所有的顶点。而这可以通过简单地扫描相应的邻接表来完成，所用时间与这些找到的顶点的个数成正比。

# 拓扑排序
> 拓扑排序是对有向无圈图的顶点的一种排序，使得如果存在一条从 vi 到 vj 的路径，那么在排序中 vj 就出现在 vi 的后面。有向边(v,w)表明课程 v 必须在课程 w 选修前修完。这些课程的拓扑排序是不破坏课程结构要求的任意的课程序列。

**如果图中含有圈，则拓扑排序就是不可能的。对于圈上的任意两个顶点，互为先后，与定义矛盾。**
拓扑排序也不是唯一的；任何合理的排序都可以被称为一种拓扑排序。

- **一种简单想法的拓扑排序**

>一个简单的求拓扑排序的算法是先找出任意一个没有入边的顶点。然后显示出该顶点，并将它及其边一起从图中删除。然后，我们对图的其余部分同样应用这样的方法处理。——*寻找起始节点，删除之，然后继续寻找下一节点*

其时间复杂度会达到*O(V<sup>2</sup>)*。原因是对顶点数组的重复顺序扫描。尽管只有少部分节点被更新，但每次迭代期间为了检索入度为 0 的顶点，都扫描了所有顶点。

- **迭代 1：减少对全体顶点的遍历次数**

使用一个栈或队列保存入度为 0 的顶点序列。下次选择只需在这个盒子中挑选即可。
算法时间复杂度*O(E+V)* 使用邻接表

# 最短路径算法
考虑最短路径时，使用的均为赋权图。弧长被赋予了两顶点之间路径长的现实意义。

**单源最短路径问题**
*给定一个顶点 s 作为输入，找出从 s 到 G 中每一个其他节点的最短路径。*

p.s.考虑在权值为负数时，所产生的负值圈问题。

## 无权最短路径
在无权图中寻找最短路径，我们只关心经过边的数量。即此时的“最短”。

**广度优先搜索**
逐步推进：找接入点出发距离为 1 的点；距离为 2 的点，etc.
进一步精进算法——使用队列来辅助操作。

## Dijkstra 算法
对赋权图进行求解。但仍可使用来自无权图中的想法。

解决单源最短路径问题的一般方法是 Dijkstra 算法。
>这个有 30 年历史的解法是贪婪算法最好的例子。
>贪婪算法一般分阶段求解一个问题，在每个阶段都把出现当做最好的去处理。

**unknown 的定义**
在每个阶段，Dijkstra 算法选择一个顶点 v,它在所有 unknown 顶点中具有最小的 d.,同时算法声明从 s 到 v 的最短路径是 known 的。阶段的其余部分由 d 值的更新工作组成。

#myAlgoInspect
- 三个辅助数组：
path[]记录前一个节点
dist[]记录到此点最短路径
set[]记录是否已遍历过
- djikstra 关键：找出度

## 具有负边值的图
Dijkstra 无效

**方法想法：将无权的思想与赋权的思想结合起来实现。**

## 无圈图
可以通过改变声明 known 的顺序或顶点的选择法则来改进 Dijkstra 算法。

使用这种法则无需优先队列辅助；选择顶点常数时间+算法常数时间结果：*O(E+V)*

**关键路径问题**——AOE 网

动作节点图 AOE 网
边代表活动 顶点代表事件（开始或结束）

**关键假设：互相不依赖的动作可以由不同服务器并行执行**
- 最早完成时间——*EC* （max）
- 最晚完成时间——*LC* （min）
- 松弛时间——*LC-EC*

最早完成时间通过表，以线性时间算出。
最晚完成时间通过倒转他们的拓扑顺序来计算。

松弛时间为 0 的点即是关键路径。也即最早完成时间。
#myAlgoInspect
- 关键在于两个表格：**点的发生时间表格** **边/事件的发生时间表格**
- 点表格——从前向后拓扑 从后向前拓扑
- 事件表格——逐个边向前遍历 早加晚减

# 最小生成树
在一个无向图中寻找一棵最小生成树。
**最小生成树**
由连接 G 的边构成的树，且总价值最低。

> 对于任一生成树 T,如果将一条不属于 T 的边添加进来，则产生一个圈。如果从该圈中除去任意一条边，则又恢复生成树的特性。如果边的值比除去的边的值低，那么新的生成树的值就比原生成树的值低。如果在建立生成树时所添加的边在所有避免成圈的边中其值最小，那么最后得到的生成树的值不能再改进，因为任意一条替代的边都将与已经存在于该生成树中的一条边至少具有相同的值。这说明，对于最小生成树，贪婪的做法是成立的。我们介绍两种算法，它们的区别在于最小（值的）边如何选取上。
## Prim 算法
使其一步步长成。在每一步，把一个节点当做根并往上加边。

#myAlgoInspect
- 与 Dijkstra 思想相同
- 遍历更新表格时无需加和，只需比较当前边长度。
- Prim 关键词：扩散
==选择最小点 连接到树上 扩散周围未被标未 T 的点==

## Kruskal 算法
连续地按照最小的权选择边。并且当选择的边不产生圈时就把它作为索取定的边。

#myAlgoInspect
还是一种贪婪策略。
形式上，Kruskal 在处理一个森林——树的集合。当算法终止时就都合并为一棵树。

- Kruskal 核心关键词：选择
选择最小的边是否成立，除非没有环路的情况。

以上两种算法都可以利用堆将运行时间优化。

# 深度优先搜索的应用
**深度优先生成树**

**深度优先生成森林**
整个生成树的集合。

### 双连通性
> 一个连通的无向图如果不存在被删除之后使得剩下的图不再连通的顶点。称其为双连通的。

### 欧拉回路

### 查找强分支

# NP-完全性（intro）
