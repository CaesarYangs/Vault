# Preset
对于大量输入的数据，链表的线性访问时间太慢，不宜使用。而使用树这种数据结构，其大部分操作的运行时间平均为 *O(logN)* 。

这种数据结构叫作二叉查找树(binary search tree)。二叉查找树是两种库集合类TreeSet 和TreeMap实现的基础，它们用于许多应用之中。在计算机科学中树(tree)是非常有用的抽象概念，因此，我们将讨论树在其他更一般的应用中的使用。

> 树型结构是一类重要的非线性数据结构。其中以树和二叉树最为常用，直观看来，树是以分支关系定义的层次结构。树结构在客观世界中广泛存在，如人类社会的族谱和各种社会组织机构都可用树来形象表示。
> 树在计算机领域中也得到广泛应用，如在编译程序中，可用树来表示源程序的语法结构。又如在数据库系统中，树形结构也是信息的重要组织形式之一。

树可以用多种方式定义。定义树的一种自然方式是递归。



## 树的定义
- 根root
- 边edge
- 父亲parent
- 孩子child
- 叶子leaf
- 路径path
- 深度depth

**树的实现**

## **树的遍历及应用**
**先序遍历 preorder traverse**
对节点的处理工作是在它的其余孩子节点被处理之前进行的。

**后序遍历 postorder traverse**
对节点的处理工作是在它的各个孩子节点被计算之后进行的。

**中序遍历 inorder traverse**
利用左中右的方法进行遍历。



# 二叉树 Binary Tree
二叉树是一棵树，其中每个节点都不能有多于两个的儿子。

二叉树的一个性质是一棵平均二叉树的深度要比节点个数N小得多，这个性质有时很重要。分析表明，其平均深度为*O(N^-1)*,而对于特殊类型的二叉树，即二叉查找树(binary search tree),其深度的平均值是*O(logN)*

**实现**
因为一个二叉树节点最多有两个子节点，所以我们可以保存直接链接到它们的链。树节点的声明在结构上类似于双链表的声明，在声明中，节点就是由element(元素)的信息加上两个到其他节点的引用(left 和 right)组成的结构。

**存储结构**
- 顺序存储结构
仅适用于完全二叉树

- 链式存储结构

**遍历二叉树**
在二叉树的一些应用中，常常要求在树中查找具有某种特征的结点，或者对树中全部结点逐一进行某种处理。
这就提出了一个遍历二叉树(traversing binary tree)的问题，即如何按某条搜索路径巡访树中每个结点，使得每个结点均被访问一次，而且仅被访问一次。

==对非线性结构的线性化操作==

“访问”的含义很广，可以是对结点作各种处理，如输出结点的信息等。遍历对线性结构来说，是一个容易解决的问题。而对二叉树则不然，由于二叉树是一种非线性结构，每个结点都可能有两棵子树，因而需要寻找一种规律，以便使二叉树上的结点能排列在一个线性队列上，从而便于遍历。

**线索二叉树**
为了保存二叉树中一个节点的左右孩子信息。

在每个结点上增加两个指针域fwd和bkwd,分别指示结点在依任一次序遍历时得到的前驱和后继信息。
显然，这样做使得结构的存储密度大大降低。另一方面，在有n个结点的二叉链表中必定存在n+1个空链域。由此设想能否利用这些空链域来存放结点的前驱和后继的信息。

| lchild | LTag          | data | RTag          | rchild |
| ------ | ------------- | ---- | ------------- | ------ |

LTag：0左孩子 1前驱
RTag：0右孩子 1后继 

以这种结点结构构成的二叉链表作为二叉树的存储结构，叫做线索链表，其中指向结点前驱和后继的指针，叫做线索。加上线索的二叉树称之为线索二叉树(Threaded Bina- ry Tree)。
其中实线为指针（指向左、右子树），虚线为线索（指向前驱和后继）。对二叉树以某种次序遍历使其变为线索二叉树的过程叫做线索化。

**中序线索二叉树**
可见，在中序线索二叉树上遍历二叉树，虽则时间复杂度亦为O(n),但常数因子要比上节讨论的算法小，且不需要设栈。因此，若在某程序中所用二叉树需经常遍历或查找结点在遍历所得线性序列中的前驱和后继，则应采用线索链表作存储结构。

**二叉树线索化**
线索化实质：将二叉链表中的空指针改为指向前驱或后继的线索。
线索化的过程就是在遍历的过程中修改空指针的过程。



# 查找树ADT——二叉查找树
二叉树的一个重要的应用是它们在查找中的使用。假设树中的每个节点存储一项数据。在我们的例子中，虽然任意复杂的项在Java中都容易处理，但为简单起见还是假设它们是整数。
还将假设所有的项都是互异的，以后再处理有重复元的情况。

使二叉树成为二叉查找树的性质是，对于树中的每个节点X,**它的左子树中所有项的值小于X中的项，而它的右子树中所有项的值大于X中的项**。注意，这意味着该树所有的元素可以用某种一致的方式排序。

二叉查找树的平均深度是*O(logN)*

在定义二叉查找树的时候，BinaryNode类与链表中的节点类一样，是一个嵌套类。

**contains方法**
系统层级使用递归的方法来处理相应的问题。

**findMin方法和findMax方法**

**insert方法**
在传统的方法考虑中，好像在运行contains方法，在根据结构遍历该树。

**remove方法**
1. 如果是叶子节点：可以立即被删除。
2. 如果该节点有一个孩子：该节点可以在其父节点调整自己的链以绕过该节点后删除。
3. 如果该节点有两个孩子

**懒惰删除**
如果删除的次数不多，通常使用的策略是懒惰删除(lazy deletion):当一个元素要被删除时， 它仍留在树中，而只是被标记为删除。这特别是在有重复项时很常用，因为此时记录出现频率数的域可以减1。如果树中的实际节点数和“被删除”的节点数相同，那么树的深度预计只上升一个小的常数（为什么？），因此，存在一个与懒惰删除相关的非常小的时间损耗。再有，如果被删除的项是重新插入的，那么分配一个新单元的开销就避免了。

## 平均情况分析
假设所有的插入序列都是等可能的，则树的所有节点平均深度为*O(logN)*

**内部路径长度**
一棵树的所有节点的深度的和。

计算内部路径长D(N)时，能够发现上一节所讨论的所有操作的平均运行时间是*O(logN)*.任意预期节点的深度为*O(logN)*。
但这并不完全正确，因为并不能完全确定所有的二叉查找树都是等可能出现的。尤其是上述的删除算法会使得左子树比右子树更深，因为我们总是用右子树节点代替删除节点。

==insert/remove会导致整棵树严重的向左偏移，才会引出能够自平衡的二叉查找树。AVL即为其中比较经典的一种。==

>许多一般的算法都能实现平衡树。但是，大部分算法都要比标准的二叉查找树复杂得多， 而且更新要平均花费更长的时间。不过，它们确实防止了处理起来非常麻烦的一些简单情形。
>下面，我们将介绍最古老的一种平衡查找树，即AVL树。

## AVL树
即平衡二叉查找树

AVL(Adelson-Velskii和Landis)树是带有平衡条件(balance condition)的二叉查找树。**这个平衡条件必须要容易保持，而且它保证树的深度须是*O(logN)***。最简单的想法是要求左右子树具有相同的高度。

**一棵AVL树是其每个节点的左子树和右子树的高度最多差1的二叉查找树（空树的高度定义为-1)**。每一个节点（在其节点结构中)保留高度信息。

**最少节点数**
在高度为h的AVL树中，最少节点数S(h)由S(h)=S(h-1)+S(h-2)+1给出。对于h=0,S(h)=1;h=1,S(h)=2。函数S(h)与***斐波那契数***密切相关，由此推出上面提到的关于AVL树的高度的界。

**插入操作——旋转**
因此，除去可能的插入外（我们将假设懒惰删除），所有的树操作都可以以时间O(logN)执行。当进行插入操作时，我们需要更新通向根节点路径上那些节点的所有平衡信息，而插入操作隐含着困难的原因在于，插入一个节点可能破坏AVL树的特性。如果发生这种情况，那么就要在考虑这一步插人完成之前恢复平衡的性质。事实上，这总可以通过对树进行简单的修正来做到，我们称其为旋转(rotation)。

在插入以后，只有那些从插入点到根节点的路径上的节点的平衡可能被改变，因为只有这些节点的子树可能发生变化。当我们沿着这条路径上行到根并更新平衡信息时，可以发现一个节点，它的新平衡破坏了AVL条件。我们将指出如何在第一个这样的节点（即最深的节点）重新平衡这棵树，并证明这一重新平衡保证整个树满足AVL性质。

四种主要情形：
1. 对a的左儿子的左子树进行一次插入。
2. 对a的左儿子的右子树进行一次插入。
3. 对a的右儿子的左子树进行一次插入。
4. 对a的右儿子的右子树进行一次插入。

**

## 伸展树

## 赫夫曼树 
#碎片摄入👌🏻 
即最优二叉树。是一类带权路径长度最短的树。




## B树
又叫做多路平衡查找树

> 迄今为止，我们始终假设可以把整个数据结构存储到计算机的主存中。可是，如果数据更多装不下主存，那么这就意味着必须把数据结构放到磁盘上。此时，因为大0模型不再适用， 所以导致游戏规则发生了变化。

==将数据结构存储在外置磁盘上==

处理器的速度还在以比磁盘速度快得多的速度增长（增长相当快的是磁盘容量的大小）。因此， 为了节省一次磁盘访问，我们愿意进行大量的计算。几乎在所有的情况下，控制运行时间的都是磁盘访问的次数。于是，如果把磁盘访问次数减少一半，那么运行时间也将减半。

*分析之前的数据模型：普通二叉查找树和AVL树*
二叉查找树：
最坏情况下不平衡，具有线性的深度，可能需要千万次级别的磁盘访问。
AVL树：
典型的情形是接近于*logN*，平均需要25次磁盘访问，所需时间是4秒

==设计目的：把磁盘访问次数减少到一个非常小的常数。通过增加程序处理即处理器的处理量来实现。==

intuition：如果有更多的分支，则会有更少的高度。

**M叉查找树**
一棵M叉查找树(M-ary search tree)可以有M路分支。随着分支增加，树的深度在减少。一棵完全二叉树(complete binary tree)的高度大约为log2N,而一棵完全M叉树(complete M-ary tree) 的高度大约是logm N。

*=>M叉平衡查找树即B树*

节点
关键词——存储的数据和内容

**定义**
阶为M的B树是一棵具有下列特性的树： 
1. 数据项存储在树叶上。
2. 非叶节点存储直到M-1个关键字以指示搜索的方向；关键字i代表子树i+1中的最小的关键字。
3. 树的根或者是一片树叶，或者其儿子数在2和M之间。
4. 除根外，所有非树叶节点的儿子数在M/2和M之间。
5. 所有的树叶都在相同的深度上并有L/2和L之间个数据项，L的确定稍后描述。
### B树查找
在B树上查找的过程和二叉排序树类似。是一个顺指针查找节点和在节点关键字中进行查找交叉进行的过程。

在B-树上进行查找包含两种基本操作：
1. 在B树中找结点； 
2. 在结点中找关键字。

**由于B树通常存储在磁盘上，则前一查找操作是在磁盘上进行的，而后一查找操作是在内存中进行的，即在磁盘上找到指针P所指结点后，先将结点中的信息读入内存，然后再利用顺序查找或折半查找查询等于K 的关键字。显然，在磁盘上进行一次查找比在内存中进行一次查找耗费时间多得多，因此，在磁盘上进行查找的次数、即待查关键字所在结点在B树上的层次数，是决定B-树查找效率的首要因素。**

*含有N个关键字的m阶B树的最大深度是多少？* #待精读 
- 每个非终端节点至少有m/2向上取整棵子树
- l+1层至少有


### B树操作
重点：从定义入手
多路-平衡查找树——类似于AVL的处理思路。自平衡的过程。

**B树插入**——即不断平衡的过程
==沿着树向上分裂直到找到一个不需要再分裂的父亲节点==
#myAlgoInspect 
- 分裂
正如这里的情形所示，当一个非叶节点分裂时，它的父节点得到了一个儿子。如果父节点的儿子个数已经达到规定的限度怎么办呢？
在这种情况下，**继续沿树向上分裂节点直到找到一个不需要再分裂的父节点**，或者到达树根。如果分裂树根，那么我们就得到两个树根。显然这是不可接受的，但我们可以建立一个新的根，这个根以分裂得到的两个树根作为它的两个儿子。这就是为什么准许树根可以最少有两个儿子的特权的原因。**这也是B树增加高度的唯一方式。**
不用说， 一路向上分裂直到根的情况是一种特别少见的异常事件，因为一棵具有4层的树意味着在整个插入序列中已经被分裂了3次（假设没有删除发生）。事实上，任何非叶节点的分裂也是相当少见的。


**B树删除**
==合适条件直接删除 不合适寻找替补的根/兄弟或合并==
类似于AVL树的操作

根据被删关键字节点以及其相邻节点的B树限制节点数做删除操作
1. 被删关键字所在节点的关键字数目不小于m/2上取整
2. 被删关键字所在节点的关键字熟不等于m/2上取整-1
3. 被删关键字所在节点及其相邻兄弟节点的关键字数目均等于m/2上取整-1

## B+树
是应文件系统所需而提出的一种B树的变形树。
一棵m阶B+树与对应的B树的差异在于：
1. 有n棵子树的结点中含有n个关键字。
2. 所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针， 且叶子结点本身依关键字的大小自小而大顺序链接。
3. 所有的非终端结点可以看成是索引部分，结点中仅含有其子树（根结点）中的最大（或最小）关键字。

**“双指针”**
- B+树头上指针，指向根节点。root——**根节点开始随机查找。**
- 指向关键字最小的叶子节点。sqt——**最小关键字起顺序查找。**

### B+树查找
在B+树上进行随机查找、插入和删除的过程基本上与B树类似。只是在查找时，若非终端结点上的关键字等于给定值，并不终止，而是继续向下直到叶子结点。

因此，在B+ 树，不管查找成功与否，每次查找都是走了一条从根到叶子结点的路径。



## 标准库中的集合与映射
在第3章中讨论过的List容器即ArrayList和LinkedList用于查找效率很低。因此，Collections API提供了两个附加容器Set和Map,它们对诸如插入、删除和查找等基本操作提供有效的实现。

**Set接口**


**Map接口**

**TreeSet类与TreeMap类的实现**

