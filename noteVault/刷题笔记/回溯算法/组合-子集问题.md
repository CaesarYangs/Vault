
# 子集
## 子集 1
[78. 子集 - 力扣（LeetCode）](https://leetcode-cn.com/problems/subsets/)
接着，我们可以通过 `S_2` 推出 `S_3`，实际上 `S_3` 中只有一个集合 `[1,2,3]`，它是通过 `[1,2]` 推出的。
整个推导过程就是这样一棵树：
![](https://labuladong.github.io/algo/images/%e6%8e%92%e5%88%97%e7%bb%84%e5%90%88/5.jpeg)
生成一棵极度非对称决策树

- 主要思想：**通过保证元素之间的相对顺序不变来防止出现重复的子集**。
- 剪枝策略：保证元素间的相对顺序

刚才讲的组合/子集问题使用 `start` 变量保证元素 `nums[start]` 之后只会出现 `nums[start+1..]` 中的元素，通过固定元素的相对位置保证不出现重复的子集。


### 子集 2（元素可重不可复选）
**包含重复元素的子集**
给你一个整数数组 `nums`，其中可能包含重复元素，请你返回该数组所有可能的子集。

所以我们需要进行剪枝，如果一个节点有多条值相同的树枝相邻，则只遍历第一条，剩下的都剪掉，不要去遍历

**体现在代码上，需要先进行排序，让相同的元素靠在一起，如果发现 `nums[i] == nums[i-1]`，则跳过**

这段代码和之前标准的子集问题的代码几乎相同，就是添加了排序和剪枝的逻辑。
至于为什么要这样剪枝，结合前面的图应该也很容易理解，这样带重复元素的子集问题也解决了。

**我们说了组合问题和子集问题是等价的**
![](https://labuladong.github.io/algo/images/%e6%8e%92%e5%88%97%e7%bb%84%e5%90%88/9.jpeg)

# 组合
[77. 组合 - 力扣（LeetCode）](https://leetcode-cn.com/problems/combinations/submissions/)
组合的一个最简单的情况：属于子集问题的扩展，只选取其中某一特定 size 的子集数组
**组合和子集是一样的：大小为 `k` 的组合就是大小为 `k` 的子集**。

